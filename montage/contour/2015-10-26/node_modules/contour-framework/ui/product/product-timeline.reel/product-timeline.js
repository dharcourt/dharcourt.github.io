/**
 * @module "ui/product/product-timeline.reel"
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    PressComposer = require("montage/composer/press-composer").PressComposer,
    moment = require("moment-timezone"),
    Map = require("collections/map");

/**
 * @class ProductTimeline
 * @extends Component
 */
exports.ProductTimeline = Component.specialize(/** @lends ProductTimeline.prototype */{

    identifier: {
        value: "productTimeline"
    },

    _firstProductsInSubset: { value: null },

    _handleProductChange: {
        value: function (plus, minus, index) {
            this._products.all = this.products;
            this._processProducts();
        }
    },

    _isFirstProductInInterval: {
        value: function (product) {
            return this._firstProductsInSubset && this._firstProductsInSubset.has(product);
        }
    },

    _normalizeValueForSort: {
        value: function (product) {
            return this._sortField === "name" ? product.name.toUpperCase() : product.timelineDate.unix();
        }
    },

    _processTimelineBreakpointsForDate: {
        value: function (products) {
            var currentThreshold, comparisonFn,
                productInterval, dateProperty,
                i, len, dateModifier,
                intervalValue;

            if (this.sortDirection === "Ascending") {
                currentThreshold = moment({year: 1000});
                comparisonFn = "isAfter";
                dateModifier = 1;
            } else {
                currentThreshold = moment({year: 3000});
                comparisonFn = "isBefore";
                dateModifier = 0;
            }

            for (i = 0, len = products.length; i < len; i++) {
                dateProperty = products[i][this.sortField];
                if (dateProperty[comparisonFn](currentThreshold)) {
                    productInterval = dateProperty.clone();
                    productInterval.add(dateModifier, "day");
                    productInterval.hour(0);
                    productInterval.minute(0);
                    productInterval.second(0);
                    productInterval.millisecond(0);
                    currentThreshold = productInterval;
                    intervalValue = currentThreshold.clone().subtract(dateModifier, "day").format('MMMM Do, YYYY');
                    this._firstProductsInSubset.add(intervalValue, products[i]);
                    if (this._firstProductsInSubset.length === 1) {
                        this._timelineHeader.value = intervalValue;
                    }
                }
            }
        }
    },

    _processTimelineBreakpointsForTitle: {
        value: function (products) {
            var currentThreshold,
                stringProperty,
                i, len;
            currentThreshold = this._sortDirection === "Ascending" ? "A" : "Z";
            for (i = 0, len = products.length; i < len; i++) {
                stringProperty = products[i].name.toUpperCase();
                if ((this._sortDirection === "Ascending" && stringProperty > currentThreshold) ||
                    this._sortDirection === "Descending" && stringProperty < currentThreshold){
                    currentThreshold = stringProperty.substring(0, 1).toUpperCase();
                    this._firstProductsInSubset.add(currentThreshold, products[i]);
                    if (this._sortDirection === "Ascending") {
                        currentThreshold = currentThreshold + "Z";
                    }
                }
            }
        }
    },

    _processProducts: {
        value: function () {
            var hiddenProductCount = 0,
                visibleProducts,
                self = this,
                isProductHidden;
            if (this._products.all && this._products.all.length) {
                visibleProducts = this._products.all.slice();
                visibleProducts = visibleProducts.filter(function (product) {
                    isProductHidden = product.isHidden === "Y";
                    isProductHidden && hiddenProductCount++;
                    return product.type !== "FOLDER_PRODUCT" && (self.shouldDisplayHiddenProducts || !isProductHidden);
                });
                this._sortProducts(visibleProducts);
                if (this._firstProductsInSubset) {
                    this._firstProductsInSubset.clear();
                } else {
                    this._firstProductsInSubset = new Map();
                }
                if (this.sortField === "timelineDate") {
                    this._processTimelineBreakpointsForDate(visibleProducts);
                } else {
                    this._processTimelineBreakpointsForTitle(visibleProducts);
                }

                this._products.visible = visibleProducts;
                this.title = this._products.visible.length + " Items";
                this.title += this.shouldDisplayHiddenProducts ? "" : " (" + hiddenProductCount + " Hidden)";
            } else {
                if (this.isRootFolder) {
                    this.title = "No products to display"
                }
                this._products.visible = [];
            }


        }
    },

    _products: {
        value: {
            all: null,
            visible: null
        }
    },

    _repetition: { value: null },

    _sortProducts: {
        value: function (visibleProducts) {
            var holder, index, swapOccured,
                valueAtNextIndex, nextIndex, valueAtIndex, lastIndex,
                self = this;
                lastIndex = visibleProducts.length - 1;
                visibleProducts.some(function () {
                    swapOccured = false;
                    for (index = 0; index < lastIndex; ++index) {
                        nextIndex = index + 1;
                        valueAtIndex = self._normalizeValueForSort(visibleProducts[index]),
                            valueAtNextIndex = self._normalizeValueForSort(visibleProducts[nextIndex]);
                        if ((self._sortDirection === "Ascending" && valueAtIndex > valueAtNextIndex) ||
                            (self._sortDirection === "Descending" && valueAtNextIndex > valueAtIndex)) {
                            holder = visibleProducts[nextIndex];
                            visibleProducts[nextIndex] = visibleProducts[index];
                            visibleProducts[index] = holder;
                            swapOccured = true;
                        }
                    }

                    if (!swapOccured) {
                        return true;
                    }
                    return false;
                });

        }
    },

    _shouldDisplayHiddenProducts: { value: false },

    _sortDirection: { value: null },

    _sortField: { value: null },

    _timelineHeader: { value: null },

    enterDocument: {
        value: function (firstTime) {
            if (firstTime) {
                this.addRangeAtPathChangeListener("products", this, "_handleProductChange");
                this._repetition.element.addEventListener("scroll", this);
            }
        }
    },

    handlePress: {
        value: function (event) {
            event.stopPropagation();
            var component = event.targetElement.component,
                identifier = component && component.identifier,
                product, coords;
            if (identifier === "geoLocations") {
                product = MapDataConverter.wktToGeojson(component.geoLocations);
                coords = ProjectionUtilities.inverse(Projections["102100"], product);
                this.application.delegate.setCenter(coords);
            } else if (identifier === "info") {
                product = component.product;
                this.application.delegate.inspectProduct(product);
            }
        }
    },

    handleScroll: {
        value: function (e) {
            e.stopPropagation();
            this.needsDraw = true;
        }
    },

    isRootFolder: {value: true},

    prepareForActivationEvents: {
        value: function () {
            this._pressComposer = new PressComposer();
            this.addComposerForElement(this._pressComposer, this._repetition.element);
            this._pressComposer.addEventListener("press", this);
        }
    },

    products: { value: null },

    shouldDisplayHiddenProducts: {
        get: function () {
            return this._shouldDisplayHiddenProducts;
        },
        set: function (value) {
            if (typeof value !== "undefined" && value !== null && value !== this._shouldDisplayHiddenProducts) {
                this._shouldDisplayHiddenProducts = value;
                this._processProducts();
            }
        }
    },

    sortDirection: {
        get: function () {
            return this._sortDirection;
        },
        set: function (value) {
            if (value && value !== this._sortDirection) {
                this._sortDirection = value;
                this._processProducts();
            }
        }
    },

    sortField: {
        get: function () {
            return this._sortField;
        },
        set: function (value) {
            if (value && value !== this._sortField) {
                this._sortField = value;
                this._processProducts();
            }
        }
    },

    title: {value: null},

    _headerCache: {
        value: {
            above: null,
            current: null,
            below: null
        }
    },

    willDraw: {
        value: function () {
            var repetitionTop = this._repetition.element.getBoundingClientRect().top+30,
                timelineHeaders = this._repetition.element.querySelectorAll(".contour-ProductTimeline-timelineInterval.contour-ProductTimeline-timelineInterval--visible"),
                header, i, len, currentHeader;
            if (timelineHeaders && timelineHeaders.length) {
                for (i = 0, len = timelineHeaders.length; i < len; ++i) {
                    header = timelineHeaders[i];
                    if ((header.getBoundingClientRect().bottom) <= repetitionTop) {
                        currentHeader = header;
                        if (i == len-1) {
                            this._timelineHeader.value = currentHeader.component.value;
                        }
                    } else if (currentHeader) {
                         this._timelineHeader.value = currentHeader.component.value;
                         break;
                    }
                }


            }
        }
    }


});
