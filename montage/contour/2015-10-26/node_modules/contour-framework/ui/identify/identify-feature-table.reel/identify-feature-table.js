/**
 * @module ui/identify-feature-table.reel
 */
var Component = require("montage/ui/component").Component,
    PressComposer = require("montage/composer/press-composer").PressComposer,
    RangeController = require("montage/core/range-controller").RangeController,
    TreeController = require("montage/core/tree-controller").TreeController;

/**
 * @class IdentifyFeatureTable
 * @extends Component
 */
exports.IdentifyFeatureTable = Component.specialize(/** @lends IdentifyFeatureTable# */ {

    _normalizeValueForSort: {
        value: function (value) {
            return this._sortField.type === "string" ? value.toUpperCase() : this._sortField.type === "number" ? parseFloat(value) : value;
        }
    },

    _sortFeatures: {
        value: function () {

            var next2last = this._sortedFeatures.length - 1,
                holder, swapOccured, index, valueAtIndex, nextIndex, valueAtNextIndex,
                self = this;
            this._sortedFeatures.some(function () {
                swapOccured = false;
                for (index = 0; index < next2last; index += 1) {
                    nextIndex = index + 1;
                    valueAtIndex = self._normalizeValueForSort(self._sortedFeatures[index].properties[self._sortField.propertyName]),
                    valueAtNextIndex = self._normalizeValueForSort(self._sortedFeatures[nextIndex].properties[self._sortField.propertyName]);
                    if ((self._sortDirection === "asc" && valueAtIndex > valueAtNextIndex) ||
                        (self._sortDirection === "desc" && valueAtNextIndex > valueAtIndex)) {
                        holder = self._sortedFeatures[nextIndex];
                        self._sortedFeatures[nextIndex] = self._sortedFeatures[index];
                        self._sortedFeatures[index] = holder;
                        swapOccured = true;
                    }
                }

                if (!swapOccured) {
                    return true;
                }
                return false;
            });

        }
    },

    _featureTreeController: { value: null },

    __featureList: { value: null },

    _featureList: {
        get: function () {
            return this.__featureList;
        },
        set: function (value) {
            if (value) {
                this.__featureList = value;
                this._featureTreeController = new TreeController();
                this.__featureList.controller = this._featureTreeController;
                this._featureTreeController.data = { name: "root" };
                this._featureTreeController.owner = this;
                this._featureTreeController.defineBinding("data.children", {"<-": "owner._searchPane.data"});
            }
        }
    },

    _hasZoomableFeatures: {
       value: true
    },

    _fieldRangeController: { value: null},

    _fields: { value: null },

    __needsResetScroll: { value: false },

    _needsResetScroll: {
        get: function () {
            return this.__needsResetScroll;
        },
        set: function (value) {
            this.__needsResetScroll = value;
            if (this.__needsResetScroll) {
                this.__needsResetVerticalScroll = true;
                this.needsDraw = true;
            }
        }
    },

    __needsResetVerticalScroll: {
        value: false
    },

    _needsResetVerticalScroll: {
        get: function () {
            return this.__needsResetVerticalScroll;
        },
        set: function (value) {
            this.__needsResetVerticalScroll = value;
            if (this.__needsResetVerticalScroll) {
                this.needsDraw = true;
            }
        }
    },


    _preparedForAction: { value: false },

    _pressComposer: { value: null },

    _searchBody: {
        value: null
    },

    _sortDirection: { value: "asc" },

    _sortField: { value: null },

    _updateSort: {
        value: function (field) {
            if (this._sortField !== field) {
                this._sortField = field;
            } else {
                this._sortDirection = this._sortDirection === "asc" ? "desc" : "asc";
            }

            this._sortFeatures();
            this._featureList.handleTreeChange();
        }
    },

    draw: {
        value: function () {
            var a, href, i, n;
            for (i = 0, n = this._anchors.length; i < n; i++) {
                a = this._anchors[i];
                if (a.component.link) {
                    a.setAttribute("href", a.component.link.url);
                }
            }
            if (this._needsResetScroll) {
                this._searchBody.scrollLeft = 0;
                this._needsResetScroll = false;
            }
            if (this._needsResetVerticalScroll) {
                this._featureList.element.scrollTop = 0;
                this._needsResetVerticalScroll = false;
            }

        }
    },

    enterDocument: {
        value: function (firstTime) {
            if (!this._pressComposer) {
                this._pressComposer = new PressComposer();
                this.addComposer(this._pressComposer);
            }
            if (!firstTime) {
                this.prepareForActivationEvents();
            } else {
                this._fieldRangeController = new RangeController();
            }
        }
    },

    exitDocument: {
        value: function () {
            if (this._preparedForAction) {
                this._preparedForAction = false;
                this.removeComposer(this._pressComposer);
                this._pressComposer.removeEventListener("press", this, false);
                this._pressComposer = null;
            }
        }
    },

    features: {
        get: function () {
            return this._features;
        },
        set: function (value) {
            this._features = value;
            if (value && Array.isArray(value)) {
                this._hasZoomableFeatures = value && value[0] && (value[0].geometry.type === "Point" || value[0].geometry.type === "MultiPoint");
                this._sortedFeatures = value.slice();
                this._needsResetScroll = true;
            }
        }
    },

    _features: { value: null },

    _sortedFeatures: { value: null },

    fields: { value: null },

    handleBackAction: {
        value: function (e) {
            e.stopPropagation();
            this.succession.components.pop();
        }
    },

    handlePress: {
        value: function (e) {
            e.stopPropagation();
            var component = e.targetElement.component;
            if (component) {
                if (component.field && component.identifier === "fieldHeader") {
                    this._updateSort(component.field );
                } else if (component.feature && component.identifier === "zoomToCell") {
                    this.application.map.centerOnAndZoomToFeature(component.feature);
                }
            }
        }
    },

    prepareForActivationEvents: {
        value: function () {
            if (!this._preparedForAction) {
                this._preparedForAction = true;
                this._pressComposer.addEventListener("press", this, false);
                this._titleBar.addEventListener("backAction", this, false);

            }
        }
    },

    searchTextDidChange: {
        value: function(text, callback) {
            this._needsResetVerticalScroll = true;
            callback();
        }
    },

    willDraw: {
        value: function () {
            if (!this._searchBody) {
                this._searchBody = this._searchPane.element.querySelector(".contour-SearchPane-bodyWrapper");
            }
            this._anchors = this._featureList.element.querySelectorAll("a");

        }
    }
});
