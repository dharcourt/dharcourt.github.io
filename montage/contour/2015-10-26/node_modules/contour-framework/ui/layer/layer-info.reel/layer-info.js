var Component = require("montage/ui/component").Component,
    Layer = require("logic/model/layer").Layer,
    Protocol = require("logic/model/protocol").Protocol;

/**
 * @class LayerInfo
 * @extends external:Component
 */
exports.LayerInfo = Component.specialize(/** @lends LayerInfo@ */{

    // Set by owner.
    layerReference: {
        get: function () {
            return this._layerReference;
        },
        set: function (value) {
            if (value && value !== this._layerReference) {
                this.dispatchBeforeOwnPropertyChange("isClustering", this.isClustering);
                this.dispatchBeforeOwnPropertyChange("transparency", this.transparency);
                this._layerReference = value;
                this.dispatchOwnPropertyChange("isClustering", this.isClustering);
                this.dispatchOwnPropertyChange("transparency", this.transparency);
            }
        }
    },

    // Changes map's bounds to the initial bounds of layer.
    handleZoomButtonAction: {
        value: function () {
            if (this.layerReference.layers[0] && this.layerReference.layers[0].initialBounds) {
                this.application.delegate.fitToBounds(this.layerReference.layers[0].initialBounds);
            }
        }
    },

    // cover method to turn off other feature layers that are clustered.
    // only one feature layer can be clustered at a time.
    isClustering: {
        get: function () {
            return this._layerReference ? this._layerReference.layers[0].isClustering : false;
        },
        set: function (value) {
            if (this._layerReference && value !== undefined && value !== this._layerReference.layers[0].isClustering) {
                if (value === true) {
                    if (this.application.delegate.layers.clustered !== undefined) {
                        this.application.delegate.layers.clustered.isClustering = false;
                    }
                    this.application.delegate.layers.clustered = this._layerReference.layers[0];
                } else {
                    delete this.application.delegate.layers.clustered;
                }
                this._layerReference.layers[0].isClustering = value;
            }
        }
    },

    // cover method to convert transparency to opacity
    transparency: {
        get: function () {
            return this.layerReference ? (1 - this.layerReference.opacity) * 100 : 0;
        },
        set: function (value) {
            if (this.layerReference && typeof value === "number") {
                this.layerReference.opacity = 1 - value / 100;
            }
        }
    }

});