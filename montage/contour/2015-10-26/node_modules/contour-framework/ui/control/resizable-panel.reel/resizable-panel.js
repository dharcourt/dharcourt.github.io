/**
 * @module "ui/control/resizable-pane.reel"
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    TranslateComposer = require("montage/composer/translate-composer").TranslateComposer;

/**
 * @class ResizablePanel
 * @extends Component
 *
 * A Resizable panel has following features
 *
 *
 * Landscape mode
 *
 * 1. Quickly drag handle of left/right panel, it will go full open mode.
 * 2. When dragging left panel, the right panel will move base on left panel posisiton if they are goint to touch.
 * 3. Left or right panel can't drag smaller than min width.
 *
 *Portrait mode
 *
 * 1. Quickly drag handle of left/right panel, it will go full open mode.
 * 2. When dragging panel to near bottom, panel will go full down automatically. If panel contains a tab-bar, It will have 2 levels to auto go down.
 * When dragging near the tab-bar and release, will auto go down to show tab-bar height. When keep dragging to touch the bottom, will go full down.
 */
exports.ResizablePanel = Component.specialize(/** @lends ResizablePanel.prototype */{

    _leftFrame: {
        set: function (value) {
            this._needsDraw = true;
            this._needsFrameUpdate = true;
            this._isLeftSuccessionAddingContent = true;
        }
    },

    _rightFrame: {
        set: function (value) {
            this._needsDraw = true;
            this._needsFrameUpdate = true;
            this._isRightSuccessionAddingContent = true;
        }
    },

    _updateFrame: {
        value: function () {
            var changed = false;
            var self = this;
            setFrame(this.leftSuccession, this._leftResizablePanel, "left");
            setFrame(this.rightSuccession, this._rightResizablePanel, "right");
            if (changed) {
                this.dispatchOwnPropertyChange("frame", this.frame);
            }
            this._needsFrameUpdate = false;

            function setFrame(succession, resizablePanel, side) {
                if (succession.components.length > 0 && !self["_is" + side + "FrameSet"]) {
                    if (parseFloat(resizablePanel.element.style.width) !== self.frame[side + "Width"]) {
                        self.frame[side + "Width"] = parseFloat(resizablePanel.element.style.width);
                        changed = true;
                    }
                    if (parseFloat(resizablePanel.element.style.height) !== self.frame[side + "Height"]) {
                        changed = true;
                        self.frame[side + "Height"] = parseFloat(resizablePanel.element.style.height);
                    }
                    self["_is" + side + "FrameSet"] = true;
                } else if (succession.components.length < 1) {
                    self["_is" + side + "FrameSet"] = false;
                    self.frame[side + "Width"] = 0;
                    self.frame[side + "Height"] = 0;
                    changed = true;
                }
            }
        }
    },

    /*
     * Left side Succession.
     */
    displayHandleDelayTime: {
        value: 0
    },

    frame: {
        value: {leftWidth: 0, rightWidth: 0, leftHeight: 0, rightHeight: 0}
    },

    /*
     * Left side Succession.
     */
    leftSuccession: {
        value: null
    },

    /*
     * Right side Succession.
     */
    rightSuccession: {
        value: null
    },

    /*
     * The gap between resizable panel and top edge.
     */
    reservedHeight: {
        value: 0
    },

    /*
     * How far will left/right container go when open by default in both landscape and protriate mode.
     */
    defaultSize: {
        value: 320
    },

    _isLeftPanelFullOpen: {
        value: false
    },

    _isRightPanelFullOpen: {
        value: false
    },

    _hasTabBarAsChild: {
        value: false
    },

    /*
     * How far will left container go when open.
     */
    _leftPanelSize: {
        value: 0
    },

    /*
     * How far will right container go when open.
     */
    _rightPanelSize: {
        value: 0
    },

    /*
     * The direction when dragging handle.
     */
    _leftPanelDirection: {
        value: null
    },

    /*
     * The direction when dragging handle.
     */
    _rightPanelDirection: {
        value: null
    },

    /*
     * Use this for now to judge mobile _leftPanelSize, should have a global way to know this
     */
    _isPortrait: {
        get: function () {
            return (!this._leftLandscapeHandle.element.offsetParent);
        }
    },

    /*
     * If start dragging to resize.
     */
    _isDragging: {
        value: false
    },

    /*
     * The minimum _leftPanelSize left container can be stay, auto close if left container small than this _leftPanelSize.
     */
    _minimumSize: {
        value: 40
    },

    _leftLandscapeTranslateComposer: {
        value: null
    },

    _leftPortraitHandleTranslateComposer: {
        value: null
    },

    _rightLandscapeTranslateComposer: {
        value: null
    },

    _rightPortraitHandleTranslateComposer: {
        value: null
    },

    /*
     * The X/Y position when start dragging handle.
     */
    _startPosition: {
        value: null
    },

    /*
     * Moving dragging panel.
     */
    _handleDragging: {
        value: function () {
            var e = this._draggingEvent;
            var resizablePanel = this._isRightHandleDragging ? this._rightResizablePanel : this._leftResizablePanel;
            this._isRightHandleDragging ? this._isRightPanelFullOpen = false : this._isLeftPanelFullOpen = false;
            var moveOffset;
            if (this._isPortrait) {
                if (this._startPosition > e.translateY) {
                    this._isRightHandleDragging ? this._rightPanelDirection = 'UP' : this._leftPanelDirection = 'UP';
                } else {
                    this._isRightHandleDragging ? this._rightPanelDirection = 'DOWN' : this._leftPanelDirection = 'DOWN';
                }
                moveOffset = resizablePanel.element.clientHeight - (e.translateY - this._startPosition);
                if (moveOffset >= this.element.clientHeight - 20 - this.reservedHeight) {
                    moveOffset = this.element.clientHeight - 20 - this.reservedHeight;
                }
                resizablePanel.element.style.setProperty('height', moveOffset + 'px');
                this._isRightHandleDragging ? this._rightPanelSize = resizablePanel.element.clientHeight : this._leftPanelSize = resizablePanel.element.clientHeight;
                this._startPosition = e.translateY;
            } else {
                if (this._startPosition > e.translateX) {
                    this._isRightHandleDragging ? this._rightPanelDirection = 'LEFT' : this._leftPanelDirection = 'LEFT';
                } else {
                    this._isRightHandleDragging ? this._rightPanelDirection = 'RIGHT' : this._leftPanelDirection = 'RIGHT';
                }
                moveOffset = this._isRightHandleDragging ? resizablePanel.element.clientWidth - e.translateX + this._startPosition : resizablePanel.element.clientWidth + e.translateX - this._startPosition;
                if (moveOffset >= this.element.clientWidth - 20) {
                    moveOffset = this.element.clientWidth - 20;
                }
                if (moveOffset <= this.defaultSize) {
                    moveOffset = this.defaultSize;

                }
                this._startPosition = e.translateX;
                resizablePanel.element.style.setProperty('width', moveOffset + 'px');
                this._isRightHandleDragging ? this._updateSize('RIGHT') : this._updateSize('LEFT');
                this._isRightHandleDragging ? this._rightPanelSize = resizablePanel.element.clientWidth : this._leftPanelSize = resizablePanel.element.clientWidth;
            }
            this._needsFrameUpdate = true;
        }
    },

    /*
     * Move another panel when dragging left or right panel, make sure these 2 don't cover on each other.
     */
    _updateSize: {
        value: function (side) {
            var self = this;
            var otherPanelMoveOffset;
            var _leftPanelSize = this._leftResizablePanel.element.clientWidth;
            var _rightPanelSize = this._rightResizablePanel.element.clientWidth;
            if (side === 'RIGHT') {
                setPanelWidth(_rightPanelSize, _leftPanelSize, "right", "left");
            } else if (side === 'LEFT') {
                setPanelWidth(_leftPanelSize, _rightPanelSize, "left", "right");
            }

            function setPanelWidth(draggingPanelSize, otherPanelSize, draggingSide, otherSide) {

                if (draggingPanelSize > self.element.clientWidth - otherPanelSize - 20) {
                    otherPanelMoveOffset = otherPanelSize - (draggingPanelSize - (self.element.clientWidth - otherPanelSize - 20));
                    if (otherPanelMoveOffset < self.defaultSize) {
                        otherPanelMoveOffset = self.defaultSize;
                        draggingPanelSize = self.element.clientWidth - otherPanelMoveOffset - 20;
                        self["_" + draggingSide + "ResizablePanel"].element.style.setProperty('width', draggingPanelSize + 'px');
                        self["_" + draggingSide + "PanelSize"] = draggingPanelSize;
                    }
                    self["_" + otherSide + "ResizablePanel"].element.style.setProperty('width', otherPanelMoveOffset + 'px');
                    self["_" + otherSide + "PanelSize"] = otherPanelMoveOffset;
                    self["_is" + otherSide + "FrameSet" ] = false;
                }
            }

        }
    },

    /*
     * Judge if needs auto full open or go to bottom when drag end
     */
    _handleDraggingEnd: {
        value: function () {
            var e = this._draggingEvent;
            var time = e.timeStamp - this._startTimestamp;
            var resizablePanel = this._isRightHandleDragging ? this._rightResizablePanel : this._leftResizablePanel;
            var direction = this._isRightHandleDragging ? this._rightPanelDirection : this._leftPanelDirection;
            var translate;
            if (this._isPortrait) {
                translate = e.translateY;
            } else {
                translate = e.translateX;
            }
            if (direction === 'DOWN' || direction === 'UP') {
                if (this._hasTabBarAsChild) {
                    if ((time < 100 && Math.abs(translate) > 20 && direction === 'DOWN' && resizablePanel.element.clientHeight < (this._minimumSize + 60)) || resizablePanel.element.clientHeight < (this._minimumSize - 10)) {
                        resizablePanel.element.style.setProperty('height', 0 + 'px');
                    } else if ((time < 100 && Math.abs(translate) > 20 && direction === 'DOWN') || resizablePanel.element.clientHeight < (this._minimumSize + 60)) {
                        resizablePanel.element.style.setProperty('height', 58 + 'px');
                    }
                } else {
                    if ((time < 100 && Math.abs(translate) > 20 && direction === 'DOWN') || resizablePanel.element.clientHeight < this._minimumSize) {
                        resizablePanel.element.style.setProperty('height', 0 + 'px');
                    }
                }
                if ((time < 100 && Math.abs(translate) > 20 && direction === 'UP') || resizablePanel.element.clientHeight >= this.element.clientHeight - this._minimumSize - 20 - this.reservedHeight) {
                    resizablePanel.element.style.setProperty('height', this.element.clientHeight - 20 - this.reservedHeight + 'px');
                    this._isRightHandleDragging ? this._isRightPanelFullOpen = true : this._isLeftPanelFullOpen = true;
                }
                this._isRightHandleDragging ? this._rightPanelSize = resizablePanel.element.clientHeight : this._leftPanelSize = resizablePanel.element.clientHeight;
            } else if (direction === 'LEFT' || direction === 'RIGHT') {
                if ((time < 150 && Math.abs(translate) > 20 && direction === 'LEFT') ||
                    ( this._isRightHandleDragging && resizablePanel.element.clientWidth >= this.element.clientWidth - 20) ||
                    (!this._isRightHandleDragging && resizablePanel.element.clientWidth < (this.defaultSize + this._minimumSize) )) {
                    this._isRightHandleDragging ? resizablePanel.element.style.setProperty('width', (this.element.clientWidth - 20) + 'px') : resizablePanel.element.style.setProperty('width', this.defaultSize + 'px');
                }
                if ((time < 100 && Math.abs(translate) > 20 && direction === 'RIGHT') ||
                    ( this._isRightHandleDragging && resizablePanel.element.clientWidth < (this.defaultSize + this._minimumSize)) ||
                    (!this._isRightHandleDragging && resizablePanel.element.clientWidth >= this.element.clientWidth - 20)) {
                    this._isRightHandleDragging ? resizablePanel.element.style.setProperty('width', this.defaultSize + 'px') : resizablePanel.element.style.setProperty('width', (this.element.clientWidth - 20) + 'px');
                }
                this._isRightHandleDragging ? this._rightPanelSize = resizablePanel.element.clientWidth : this._leftPanelSize = resizablePanel.element.clientWidth;
                this._isRightHandleDragging ? this._updateSize('RIGHT') : this._updateSize('LEFT');
            }
            this._isTranslateEnd = false;
            this._isRightHandleDragging = false;
        }
    },

    draw: {
        value: function () {
            // Doing dragging.
            if (this._isDragging && this._draggingEvent) {
                this._handleDragging();
            }
            // Do minimize _leftPanelSize handle
            if (this._isTranslateEnd && this._draggingEvent) {
                this._handleDraggingEnd();
            }
            // Set transition position base on landscape mode or portrait mode;
            if (this._needsResizablePanelInit) {
                this._initLeftResizablePanel();
                this._initRightResizablePanel();
                this._needsResizablePanelInit = false;
            }

            if (this._isLeftSuccessionAddingContent) {
                this._updateSize('LEFT');
                this._isLeftSuccessionAddingContent = false;
            } else if (this._isRightSuccessionAddingContent) {
                this._updateSize('RIGHT');
                this._isRightSuccessionAddingContent = false;
            }

            if (this._needsFrameUpdate) {
                this.element.querySelector('.contour-TabBar') ? this._hasTabBarAsChild = true : this._hasTabBarAsChild = false;
                if (this._isRightHandleDragging) {
                    this._isrightFrameSet = false;
                } else {
                    this._isleftFrameSet = false;
                }
                this._updateFrame();
            }
        }
    },

    _initLeftResizablePanel: {
        value: function () {
            if (this._leftPanelSize === 0) {
                this._leftPanelSize = this.defaultSize;
            }
            this._leftResizablePanel.element.style.setProperty('height', this._leftPanelSize + 'px');
            this._leftResizablePanel.element.style.setProperty('width', this._leftPanelSize + 'px');
        }
    },

    _initRightResizablePanel: {
        value: function () {
            if (this._rightPanelSize === 0) {
                this._rightPanelSize = this.defaultSize;
            }
            this._rightResizablePanel.element.style.setProperty('height', this._rightPanelSize + 'px');
            this._rightResizablePanel.element.style.setProperty('width', this._rightPanelSize + 'px');
        }
    },

    handleHandleTranslateStart: {
        value: function (e) {
            if (this._isPortrait) {
                this._startPosition = e.translateY;
            } else {
                this._startPosition = e.translateX;
            }
            this._isDragging = true;
            if (e.target.element.component.identifier.indexOf('right') >= 0) {
                this._isRightHandleDragging = true;
            }
            this._startTimestamp = e.timeStamp;
        }
    },

    handleHandleTranslate: {
        value: function (e) {
            this.needsDraw = true;
            this._draggingEvent = e;
        }
    },

    handleHandleTranslateEnd: {
        value: function (e) {
            this._isDragging = false;
            this._isTranslateEnd = true;
            this._draggingEvent = e;
            this.needsDraw = true;
        }
    },

    prepareForActivationEvents: {
        value: function () {
            var self = this;
            addEventListener("left", "Landscape");
            addEventListener("right", "Landscape");
            addEventListener("left", "Portrait");
            addEventListener("right", "Portrait");

            function addEventListener(side, direction) {
                self["_" + side + direction + "TranslateComposer"].addEventListener('translateStart', self);
                self["_" + side + direction + "TranslateComposer"].addEventListener('translate', self);
                self["_" + side + direction + "TranslateComposer"].addEventListener('translateEnd', self);
            }
        }
    },

    handleBuildInEnd: {
        value: function (e) {
            this._isBuildInEnd = true;
        }
    },

    handleBuildOutEnd: {
        value: function (e) {
            if (this.leftSuccession.components.length === 0 || this.leftSuccession.components.length === 0) {
                this._isBuildInEnd = false;
            }
        }
    },

    handleTransitionend: {
        value: function () {
            this.needsDraw = true;
        }
    },

    enterDocument: {
        value: function (firstTime) {
            if (firstTime) {
                var self = this;
                addTranslateComposer("left", "Landscape");
                addTranslateComposer("right", "Landscape");
                addTranslateComposer("left", "Portrait");
                addTranslateComposer("right", "Portrait");
                this.addEventListener('buildOutEnd', this);
                this.addEventListener('buildInEnd', this);
                this.element.addEventListener("transitionend", this, false);
                this._needsResizablePanelInit = true;

                function addTranslateComposer(side, direction) {
                    self["_" + side + direction + "TranslateComposer"] = new TranslateComposer();
                    self["_" + side + direction + "TranslateComposer"].identifier = "Handle";
                    self["_" + side + direction + "TranslateComposer"].hasMomentum = false;
                    self.addComposerForElement(self["_" + side + direction + "TranslateComposer"], self["_" + side + direction + "Handle"].element);
                }
            }
        }
    }

});
