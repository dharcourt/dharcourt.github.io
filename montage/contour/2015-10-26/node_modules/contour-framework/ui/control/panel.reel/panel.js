var Component = require("montage/ui/component").Component,
    Promise = require("bluebird");

/**
 * @class Panel
 * @extends Component
 */
exports.Panel = Component.specialize(/** @lends Panel.prototype */{

    /**
     * Cache panel instances for comparison
     */
    contents: {
        value: {}
    },

    /**
     * @example Menu uses this property to highlight icons based on the prototype of the first item
     * in a stack of panels
     */
    leftFirstContentPrototype: {
        value: null
    },

    /**
     * @see Panel#leftFirstContentPrototype
     */
    rightFirstContentPrototype: {
        value: null
    },

    insets: {
        get: function () {
            var frame = this._resizablePanelFrame,
                portrait = frame && this._isPortrait,
                landscape = frame && !portrait;
            return {
                top: portrait && (frame.leftHeight || frame.rightHeight) ? 44 : 0,
                left: landscape && frame.leftWidth || 0,
                right: landscape && frame.rightWidth || 0,
                bottom: portrait && frame.leftHeight || portrait && frame.rightHeight || 0
            }
        }
    },

    _resizablePanelFrame: {
        get: function () {
            return this.__resizablePanelFrame;
        },
        set: function (frame) {
            this.dispatchBeforeOwnPropertyChange("insets", this.insets);
            this.__resizablePanelFrame = frame;
            this.dispatchOwnPropertyChange("insets", this.insets);
        }
    },

    _isPortrait: {
        value: null
    },

    /**
     * Cache promises as API needs to return previous promises
     *
     * @type {Promise} Resolves with panel instance, not panel class return from require.async
     */
    _contentPromises: {
        value: {}
    },

    toggleLeft: {
        value: function (prototype) {
            return this._toggle(prototype, this.left);
        }
    },

    toggleRight: {
        value: function (prototype) {
            return this._toggle(prototype, this.right);
        }
    },

    _toggle: {
        value: function (prototype, succession) {
            var self = this;

            // if hasn't been opened previously or not the currently opened panel
            return this._getContentPromise(prototype).then(function (content) {

                // Stack isn't empty
                if (succession.components.length) {

                    // Not top of stack, not in stack
                    if (succession.content !== content && !succession.components.has(content)) {
                        self._close(succession); // close must happen after checking the stack
                        return self._open(prototype, succession);

                    } else { // Not top of stack, in stack
                        return self._close(succession);
                    }

                } else { // Stack is empty
                    return self._open(prototype, succession);
                }

            });
        }
    },

    openLeft: {
        value: function (prototype) {
            return this._open(prototype, this.left);
        }
    },

    openRight: {
        value: function (prototype) {
            return this._open(prototype, this.right);
        }
    },

    _openingPanel: {
        value: null
    },

    _closingPanel: {
        value: null
    },

    _dispatchWillOpen: {
        value: function (panel) {
            this._openingPanel = panel;

            if (this._closingPanel) {
                this.removeEventListener(
                    "buildOutEnd", this._contentBuildOutHandlers[this._closingPanel.uuid]
                );
                if (typeof this._closingPanel.didClose === "function") this._closingPanel.didClose();
                this._closingPanel = null;
            }

            if (typeof panel.willOpen === "function") panel.willOpen();
        }
    },

    _dispatchDidOpen: {
        value: function (panel) {
            this._openingPanel = null;

            if (typeof panel.didOpen === "function") panel.didOpen();
        }
    },

    _dispatchWillClose: {
        value: function (panel) {
            this._closingPanel = panel;

            if (this._openingPanel) {
                this.removeEventListener(
                    "buildInEnd", this._contentBuildInHandlers[this._openingPanel.uuid]
                );
                if (typeof this._openingPanel.didOpen === "function") this._openingPanel.didOpen();
                this._openingPanel = null;
            }

            if (typeof panel.willClose === "function") panel.willClose();
        }
    },

    _dispatchDidClose: {
        value: function (panel) {
            this._closingPanel = null;

            if (typeof panel.didClose === "function") panel.didClose();
        }
    },

    /**
     * Sometimes we need to get panel promise if it's already open, but don't want to close
     * the panel if it's already open, hence separate method from _toggle
     */
    _open: {
        value: function (prototype, succession) {
            var self = this;

            this._previousSuccessionUsed = succession;

            return this._getContentPromise(prototype).then(function (content) {
                var promise;

                // If not on the stack
                if (!succession.components.has(content)) {
                    // _getBuildInEndPromise sets up a event listener, must be called
                    // before setting succession.content
                    promise = self._getBuildInEndPromise(content).then(function (panel) {
                        self._dispatchDidOpen(panel);
                        return panel;
                    });

                    if (succession === self.left) {
                        self.leftFirstContentPrototype = prototype;
                    } else {
                        self.rightFirstContentPrototype = prototype;
                    }

                    self._dispatchWillOpen(content);
                    // TODO: remove isVisible
                    content.isVisible = true;
                    // In case this panel needs to drill down to another panel, e.g. HazardBrowser
                    content.panelSuccession = succession;
                    succession.content = content;
                    self._resolvePortraitVisiblePanel();
                    self.application.delegate.availableMapModes = content.availableMapModes;

                } else {
                    promise = Promise.resolve(content);
                }

                return promise;
            });
        }
    },

    /**
     * Only portrait mode needs resolution due to a single panel being shown.
     * Only resolve when previously ued Succession has content
     */
    _resolvePortraitVisiblePanel: {
        value: function () {
            if (this._isPortrait &&
                this._previousSuccessionUsed &&
                this._previousSuccessionUsed.content) {

                if (this._previousSuccessionUsed === this.left && this.right.content) {
                    this.closeRight();
                } else if (this._previousSuccessionUsed === this.right && this.left.content) {
                    this.closeLeft();
                }
            }
        }
    },

    _getContentPromise: {
        value: function (prototype) {
            if (!this._contentPromises[prototype]) {
                this._contentPromises[prototype] = require.async(prototype)
                    .then(function (exports) {
                        return new exports[Object.keys(exports)[0]];
                    });
            }
            return this._contentPromises[prototype];
        }
    },

    _contentBuildInHandlers: {
        value: {}
    },

    _contentBuildOutHandlers: {
        value: {}
    },

    /**
     * Must construct and return a new promise as promises can only be resolved once
     */
    _getBuildInEndPromise: {
        value: function (content) {
            var self = this;

            return new Promise(function (resolve) {
                self._contentBuildInHandlers[content.uuid] = function (event) {
                    event.stopPropagation();
                    self.removeEventListener("buildInEnd", self._contentBuildInHandlers[content.uuid]);
                    resolve(event.target);
                };

                self.addEventListener("buildInEnd", self._contentBuildInHandlers[content.uuid]);
            });
        }
    },

    /**
     * Must construct and return a new promise as promises can only be resolved once
     */
    _getBuildOutEndPromise: {
        value: function (content) {
            var self = this;

            return new Promise(function (resolve) {
                self._contentBuildOutHandlers[content.uuid] = function (event) {
                    event.stopPropagation();
                    self.removeEventListener("buildOutEnd", self._contentBuildOutHandlers[content.uuid]);
                    resolve(event.target);
                };

                self.addEventListener("buildOutEnd", self._contentBuildOutHandlers[content.uuid]);
            });
        }
    },

    closeLeft: {
        value: function () {
            return this._close(this.left);
        }
    },

    closeRight: {
        value: function () {
            return this._close(this.right);
        }
    },

    _close: {
        value: function (succession) {
            var promise,
                self = this;

            this.application.delegate.availableMapModes = null;

            if (succession === this.left) {
                this.leftFirstContentPrototype = null;
            } else {
                this.rightFirstContentPrototype = null;
            }

            promise = this._getBuildOutEndPromise(succession.content).then(function (panel) {
                self._dispatchDidClose(panel);
                return panel;
            });

            this._dispatchWillClose(succession.content);
            succession.content = null;

            return promise;
        }
    },

    enterDocument: {
        value: function () {
            // MediaQueryList must match what's in CSS
            var portraitMediaQuery = window.matchMedia(
                "(max-width: 1199px) and (max-aspect-ratio: 999999/1000000), (max-width: 299px)"
            );
            portraitMediaQuery.addListener(this.handleMediaQueryChange.bind(this));
            this._isPortrait = portraitMediaQuery.matches;
        }
    },

    prepareForActivationEvents: {
        value: function () {
            this.addEventListener("closeAction", this, false);
            this.addEventListener("backAction", this, false);
        }
    },

    handleMediaQueryChange: {
        value: function (event) {
            event.stopPropagation();
            this.dispatchBeforeOwnPropertyChange("insets", this.insets);
            this._isPortrait = event.matches;
            this._resolvePortraitVisiblePanel();
            this.dispatchOwnPropertyChange("insets", this.insets);
        }
    },

    popLeft: {
        value: function () {
            return this._pop(this.left);
        }
    },

    popRight: {
        value: function () {
            return this._pop(this.right);
        }
    },

    _pop: {
        value: function (succession) {
            var previous = succession.components[succession.components.length - 2],
                top = succession.content,
                self = this;

            this._getBuildOutEndPromise(top)
                .then(function (panel) {
                    self._dispatchDidClose(panel);
                });
            this._getBuildInEndPromise(previous)
                .then(function (panel) {
                    self._dispatchDidOpen(panel);
                });

            this._dispatchWillClose(top);
            this._dispatchWillOpen(previous);

            succession.components.pop();
        }
    },

    handleBackAction: {
        value: function (event) {
            var titleBar = event.target,
                container = this._getTitleBarContainer(titleBar),
                previous = container.components[container.components.length - 2];

            if (container) {
                event.stopPropagation();

                this._pop(container);

                // TODO: remove
                if (container.components.length) {
                    previous.isVisible = true;
                }
            }
        }
    },

    handleCloseAction: {
        value: function (event) {
            var container = this._getTitleBarContainer(event.target);

            if (container) {
                event.stopPropagation();
                this.floatingButton.context = this.floatingButton.HOME;
                return this._close(container);
            }
        }
    },

    _getTitleBarContainer: {
        value: function (titleBar) {
            return titleBar.parentComponent == this.left.content ? this.left :
                titleBar.parentComponent == this.right.content ? this.right :
                    undefined;
        }
    }

});
