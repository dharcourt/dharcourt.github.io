/**
 * @module ui/control/select-bar.reel
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    Set = require("collections/set"),
    TranslateComposer = require("montage/composer/translate-composer").TranslateComposer;

/**
 * @class SelectBar
 * @extends Component
 */
exports.SelectBar = Component.specialize(/** @lends SelectBar.prototype */ {

    constructor: {
        value: function SelectBar() {
            this._options = [];
            this._values = [];
        }
    },

    highlight: {
        value: 'above'
    },

    _isReady: {
        get: function () {
            return (this._isMultipleSelectionAllowed !== null && this._options.length > 0);
        }
    },

    _isMultipleSelectionAllowed: {
        value: null // Three states: true, false, or null = not known yet.
    },

    isMultipleSelectionAllowed: {
        set: function (allowed) {
            var wasReady = this._isReady,
                wasAllowed = this._isMultipleSelectionAllowed;
            // Change the state
            this._isMultipleSelectionAllowed = allowed;
            // Sort and clip values if necessary.
            if (!wasReady && this._isReady) {
                // If the new options caused the select bar to become ready,
                // restore the last set values, sorting and filtering them
                // according to the current options.
                this.values = this.__values;
                this.__values = null;
            } else if (this._isReady && !wasAllowed && allowed && this._values.length > 1) {
                // If the select bar was and remains ready but has more than the
                // allowed number of selected values, clip the values.
                this._values.length = 1;
            }
        },
        get: function () {
            return (this._isMultipleSelectionAllowed === true);
        }
    },

    _options: {
        value: [] // Always an array and never contains undefined values.
    },

    options: {
        set: function (options) {
            var i, n, wasReady = this._isReady;
            // Record options, filtering out undefined values.
            this._options.length = 0;
            for (i = 0, n = Array.isArray(options) ? options.length : 0; i < n; ++i) {
                if (typeof options[i].value !== 'undefined') {
                    this._options.push(options[i]);
                }
            }
            // Updated values correspondingly.
            if (this._isReady && !wasReady) {
                // If the new options caused the select bar to become ready,
                // restore the last set values, sorting and filtering them based
                // on the new options.
                this.values = this.__values;
                this.__values = null;
            } else if (this._isReady) {
                // If the select bar was and remains ready, keep the current
                // values but filter and sort them according to the new options.
                this.values = this._values;
            } else if (wasReady) {
                // If the new options caused the select bar to stop being ready,
                // clear the current values after recording them for future use.
                this.__values = this._values;
                this._values = [];
            }
        },
        get: function () {
            return this._options;
        }
    },

    __values: {
        value: null // Records the last used values when select bar is not ready.
    },

    _values: {
        value: [] // Always an array, empty or with valid values in option order.
    },

    values: {
        set: function (values) {
            var previousValue, spliceArguments, valueCount;
            if (!this._isReady) {
                // If not ready, just record the values. This is necessary in
                // case the "values" property is set before the "options" or
                // "isMultipleSelectionAllowed" properties.
                this.__values = values.slice();
            } else {
                // Sort the values into a splice() call argument.
                spliceArguments = [0, this._values.length];
                valueCount = this._appendSortedValues(spliceArguments, values);
                // Clip the sorted values or provide a default if necessary.
                if (!this._isMultipleSelectionAllowed && valueCount !== 1) {
                    spliceArguments.splice(2, valueCount, valueCount ? [spliceArguments[2]] : this._options[0].value);
                }
                // Notify of the imminent value change if appropriate.
                previousValue = this._values[0];
                if (spliceArguments[2] !== previousValue) {
                    this.dispatchBeforeOwnPropertyChange("value", spliceArguments[2]);
                }
                // Set the values if necessary.
                if (!this._areValuesEqual(this._values, 0, spliceArguments, 2)) {
                    this._values.splice.apply(this._values, spliceArguments);
                }
                // Notify of the just completed value change if appropriate.
                if (spliceArguments[2] !== previousValue) {
                    this.dispatchOwnPropertyChange("value", spliceArguments[2]);
                }
            }
        },
        get: function () {
            return this._values;
        }
    },

    value: {
        set: function (value) {
            if (!this._isReady) {
                // If not ready, just record the value. This is necessary in
                // case the "values" property is set before the "options" or
                // "isMultipleSelectionAllowed" properties.
                this.__values = [value];
            } else {
                // Adjust invalid values if necessary.
                if (!this._isValueValid(value)) {
                    if (typeof value !== 'undefined') {
                        value = this._values[0];
                    } else if (!this._isMultipleSelectionAllowed) {
                        value = this._options[0].value;
                    }
                }
                // Clear or set the value as appropriate.
                if (typeof value === 'undefined') {
                    this._values.splice(0, this._values.length);
                } else if (this._values.length !== 1 || this._values[0] !== value) {
                    this._values.splice(0, this._values.length, value);
                }
            }
        },
        get: function () {
            return this._values[0];
        }
    },

    _appendSortedValues: {
        value: function (array, values) {
            var i, n, set, count = Array.isArray(values) ? values.length : 0;
            if (count) {
                if (this._areValuesSorted(values)) {
                    // Values valid and already sorted, push them as they are.
                    array.push.apply(array, values);
                } else if (count > 1) {
                    // Values in an unknown order, push them one at a time
                    // following the order of their corresponding option.
                    set = new Set(values);
                    count = 0;
                    for (i = 0, n = this._options.length; i < n; ++i) {
                        if (set.has(this._options[i].value)) {
                            array.push(this._options[i].value);
                            ++count;
                        }
                    }
                }
            }
            return count;
        }
    },

    _areValuesSorted: {
        value: function (values) {
            var i, j, n, sorted = false;
            for (i = 0, j = 0, n = this._options.length; i < n && !sorted; ++i) {
                if (this.options[i].value === values[j]) {
                    sorted = (++j === values.length);
                }
            }
            return sorted;
        }
    },

    _areValuesEqual: {
        value: function (values1, offset1, values2, offset2) {
            var i, n, equal = (values1 === values2);
            if (!equal) {
                equal = (values1.length - offset1 === values2.length - offset2);
                for (i = 0, n = values1.length - offset1; i < n && equal; ++i) {
                    equal = (values1[i + offset1] === values2[i + offset2]);
                }
            }
            return equal;
        }
    },

    _isValueValid: {
        value: function (value) {
            var i, n, valid = false;
            if (typeof value !== 'undefined') {
                for (i = 0, n = this._options.length; i < n && !valid; ++i) {
                    valid = (this._options[i].value === value);
                }
            }
            return valid;
        }
    },

    _toggleValue: {
        value: function (value) {
            var i, n, m, index;
            if (this._isReady && typeof value !== 'undefined') {
                // Find the index the value has or would have.
                index = 0;
                for (i = 0, n = this._options.length, m = this._values.length; i < n && index < m; ++i) {
                    if (value === this.options[i].value) {
                        break;
                    } else if (this._values[index] === this.options[i].value) {
                        ++index;
                    }
                }
                // Notify of the imminent value change if appropriate.
                if (index === 0) {
                    this.dispatchBeforeOwnPropertyChange("value", value);
                }
                // Add or remove the value.
                if (this._values[index] !== value) {
                    this._values.splice(index, 0, value);
                } else {
                    this._values.splice(index, 1);
                }
                // Notify of the just completed value change if appropriate.
                if (index === 0) {
                    this.dispatchOwnPropertyChange("value", value);
                }
            }
        }
    },

    _toggleOption: {
        value: function (option) {
            if (this._isReady && option) {
                if (this._isMultipleSelectionAllowed) {
                    this._toggleValue(option.value);
                } else {
                    this.value = option.value;
                }
                this.dispatchEventNamed("select", true, true, {selectBar: this});
            }
        }
    },

    _activeOption: {
        value: null
    },

    _isPrepared: {
        value: false
    },

    prepareForActivationEvents: {
        value: function () {
            if (!this._isPrepared) {
                this.element.addEventListener("touchstart", this, false);
                this.element.addEventListener("mousedown", this, false);
                this._isPrepared = true;
            }
        }
    },

    _handledIdentifier: {
        value: null
    },

    handleTouchstart: {
        value: function (event) {
            if (this._handledIdentifier === null && event.changedTouches.length === 1) {
                this._handledIdentifier = event.changedTouches[0].identifier;
                this.element.addEventListener("touchmove", this, false);
                this.element.addEventListener("touchleave", this, false);
                this.element.addEventListener("touchenter", this, false);
                document.addEventListener("touchend", this, false);
                document.addEventListener("touchcancel", this, false);
                this.handleTouchmove(event);
            }
        }
    },

    handleTouchmove: {
        value: function (event) {
            if (this._isEventHandled(event)) {
                this._activeOption = this._optionForEvent(event);
            }
        }
    },

    handleTouchleave: {
        value: function (event) {
            this.handleTouchmove(null);
        }
    },

    handleTouchenter: {
        value: function (event) {
            this.handleTouchmove(event);
        }
    },

    handleTouchend: {
        value: function (event) {
            if (this._isEventHandled(event)) {
                document.removeEventListener("touchcancel", this, false);
                document.removeEventListener("touchend", this, false);
                this.element.removeEventListener("touchenter", this, false);
                this.element.removeEventListener("touchleave", this, false);
                this.element.removeEventListener("touchmove", this, false);
                this._handledIdentifier = null;
                this._activeOption = null;
                this._toggleOption(this._optionForEvent(event));
            }
        }
    },

    handleTouchcancel: {
        value: function (event) {
            this.handleTouchend(null);
        }
    },

    handleMousedown: {
        value: function (event) {
            if (this._handledIdentifier === null && !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey) {
                this._handledIdentifier = "mouse";
                this.element.addEventListener("mousemove", this, false);
                this.element.addEventListener("mouseout", this, false);
                this.element.addEventListener("mouseover", this, false);
                document.addEventListener("mouseup", this, false);
                this.handleMousemove(event);
            }
        }
    },

    handleMousemove: {
        value: function (event) {
            if (this._isEventHandled("mouse")) {
                this._activeOption = this._optionForEvent(event);
            }
        }
    },

    handleMouseout: {
        value: function (event) {
            this.handleMousemove(null);
        }
    },

    handleMouseover: {
        value: function (event) {
            this.handleMousemove(event);
        }
    },

    handleMouseup: {
        value: function (event) {
            if (this._isEventHandled("mouse")) {
                document.removeEventListener("mouseup", this, false);
                this.element.removeEventListener("mouseover", this, false);
                this.element.removeEventListener("mouseout", this, false);
                this.element.removeEventListener("mousemove", this, false);
                this._handledIdentifier = null;
                this._activeOption = null;
                this._toggleOption(this._optionForEvent(event));
            }
        }
    },

    _isEventHandled: {
        value: function (event) {
            var i, n, handled = (!event || event === this._handledIdentifier);
            if (!handled && event.changedTouches) {
                for (i = 0, n = event.changedTouches.length; i < n && !handled; ++i) {
                    handled = (event.changedTouches[i].identifier === this._handledIdentifier);
                }
            }
            return handled;
        }
    },

    _optionForEvent: {
        value: function (event) {
            var element = event && event.target,
                component = null;
            while (element && !component) {
                component = element.component;
                element = element.parentElement;
            }
            while (component && !component.classList.has("contour-SelectBar-option")) {
                component = component.parentComponent;
            }
            return (component && component.ownerComponent == this) ? component : null;
        }
    },

    draw: {
        value: function (option) {
            // Become ready if necessary.
            if (this._isMultipleSelectionAllowed === null) {
                this.isMultipleSelectionAllowed = false;
            }
        }
    }
});
