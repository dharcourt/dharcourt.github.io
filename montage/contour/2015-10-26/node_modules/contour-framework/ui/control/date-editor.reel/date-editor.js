/**
 * @module ui/control/date-editor.reel
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    moment = require("moment-timezone");

/**
 * @class DateEditor
 * @extends Component
 */
exports.DateEditor = Component.specialize(/** @lends DateEditor# */ {
    constructor: {
        value: function DateEditor() {

            var months = moment.months().map(function (month, index) {
                return index + 1;
            });
            this._months = {"start": months[0], "end": months[months.length - 1]};
            this._hours = {"start": 0, "end": 23};
            this._minutes = {"start": 0, "end": 59};
            this._seconds = {"start": 0, "end": 59};
        }
    },

    _years: {
        value: false
    },

    _months: {
        value: false
    },

    _dates: {
        value: false
    },

    _hours: {
        value: false
    },

    _minutes: {
        value: false
    },

    _seconds: {
        value: false
    },

    /**
     * Default a very big number make no limits for year future, still keep this in case we need a small range
     */
    _yearRange: {
        value: 1000000
    },

    _yearStart: {
        value: 1582
    },

    __year: {
        value: false
    },

    _year: {
        get: function () {
            return this.__year;
        },
        set: function (value) {
            if (this._moment && typeof(value) !== "undefined" && this.__year !== value) {
                this.__year = value;
                this._moment.year(value);
                this._calculateDatesInMonth();
                this.dispatchOwnPropertyChange("value", this.value);
            }
        }
    },

    __month: {
        value: false
    },

    _month: {
        get: function () {
            return this.__month;
        },
        set: function (value) {
            if (this._moment && typeof(value) !== "undefined" && this.__month !== value) {
                this.__month = value;
                this._moment.month(value - 1);
                this._calculateDatesInMonth();
                this.dispatchOwnPropertyChange("value", this.value);
            }
        }
    },

    __date: {
        value: false
    },

    _date: {
        get: function () {
            return this.__date;
        },
        set: function (value) {
            if (this._moment && typeof(value) !== "undefined" && this.__date !== value) {
                this.__date = value;
                this._moment.date(value);
                this.dispatchOwnPropertyChange("value", this.value);
            }
        }
    },

    __hour: {
        value: false
    },

    _hour: {
        get: function () {
            return this.__hour;
        },
        set: function (value) {
            if (this._moment && typeof(value) !== "undefined" && this.__hour !== value) {
                this.__hour = value;
                if (!this._is24Hours) {
                    if (this._dayNightLabel == 'PM') {
                        this._moment.hour(value === 12 ? 12 : value + 12);
                    } else {
                        this._moment.hour(value === 12 ? 0 : value);
                    }
                } else {
                    this._moment.hour(value);
                }
                this.dispatchOwnPropertyChange("value", this.value);
            }
        }
    },

    __minute: {
        value: false
    },

    _minute: {
        get: function () {
            return this.__minute;
        },
        set: function (value) {
            if (this._moment && typeof(value) !== "undefined" && this.__minute !== value) {
                this.__minute = value;
                this._moment.minute(value);
                this.dispatchOwnPropertyChange("value", this.value);
            }
        }
    },

    __second: {
        value: false
    },

    _second: {
        get: function () {
            return this.__second;
        },
        set: function (value) {
            if (this._moment && typeof(value) !== "undefined" && this.__second !== value) {
                this.__second = value;
                this._moment.second(value);
                this.dispatchOwnPropertyChange("value", this.value);
            }
        }
    },

    _dayNightLabel: {
        value: 'AM'
    },

    _is24Hours: {
        value: false
    },

    hasTime: {
        value: false
    },

    _moment: {
        value: false
    },

    _currentSelectedDateItem: {
        value: null
    },

    disabled: {
        value: false
    },

    _needSetPlaceholder: {
        value: false
    },

    value: {
        get: function () {
            return this._moment;
        },
        set: function (value) {
            if (value) {
                if (!this._moment || !value.isSame(this._moment)) {
                    this._moment = value;
                    var year = this._moment.year();
                    this._years = {"start": this._yearStart, "end": year + this._yearRange};
                    this._refreshPropertiesValueFromMoment();
                    this._needsAutoLayout = true;
                    this._needSetPlaceholder = false;
                    this.needsDraw = true;
                }
            } else {
                this._moment = null;
                this._needSetPlaceholder = true;
                this.needsDraw = true;
            }
        }
    },

    _locale: {
        value: false
    },

    locale: {
        get: function () {
            return this._moment ? this._moment.locale() : this._locale;
        },
        set: function (value) {
            if (this._moment) {
                if (value !== this._moment.locale()) {
                    this._moment.locale(value);
                    this.dispatchOwnPropertyChange("value", this.value);
                    this._refreshPropertiesValueFromMoment();
                    this._locale = value;
                    this._needsAutoLayout = true;
                    this.needsDraw = true;
                }
            } else {
                this._locale = value;
                this._needsAutoLayout = true;
                this.needsDraw = true;
            }
        }
    },

    _timezone: {
        value: false
    },

    timezone: {
        get: function () {
            return this._moment ? this._moment.tz() : this._timezone;
        },
        set: function (value) {
            if (this._moment) {
                if (value !== this._moment.tz()) {
                    this._moment.tz(value);
                    this.dispatchOwnPropertyChange("value", this.value);
                    this._timezone = value;
                    this._refreshPropertiesValueFromMoment();
                }
            } else {
                this._timezone = value;
            }
        }
    },

    /**
     * Get local dataformat for layout UI elements return format: H means time in 24 hours otherwise h means 12 hours.
     * [Y,M,D,H]
     * [M,D,Y,h]
     */
    getLocalDateFormat: {
        value: function () {
            var momentObj = this._moment;
            if (!momentObj) {
                momentObj = moment();
                if (this._locale) {
                    momentObj.locale(this._locale);
                }
                if (this._timezone) {
                    momentObj.tz(this._timezone);
                }
            }
            var format = [];
            var dateFormat = momentObj._locale.longDateFormat('LLL');
            var len = dateFormat.length;
            var lastProcessedChar = "";
            for (var i = 0; i < len; i++) {
                var ch = dateFormat[i];
                if (ch == "Y" && ch !== lastProcessedChar) {
                    format.push("Y");
                    lastProcessedChar = ch;
                } else if (ch == "M" && ch !== lastProcessedChar) {
                    format.push("M");
                    lastProcessedChar = ch;
                } else if (ch == "D" && ch !== lastProcessedChar) {
                    format.push("D");
                    lastProcessedChar = ch;
                }
                if (format.length == 3) {
                    break;
                }
            }
            var timeFormat = momentObj._locale.longDateFormat("LT");
            format[3] = timeFormat.indexOf("h") > -1 ? "h" : "H";
            return format;
        }
    },

    _refreshPropertiesValueFromMoment: {
        value: function () {
            if (this.getLocalDateFormat()[3] === 'h') {
                // Clear __hour and set later if _is24Hours is changed
                if (this._is24Hours) {
                    this.__hour = -1;
                    this._is24Hours = false;
                }
            } else {
                if (!this._is24Hours) {
                    this.__hour = -1;
                    this._is24Hours = true;
                }
            }
            if (this.__year !== this._moment.year()) {
                this.__year = this._moment.year();
                this.dispatchOwnPropertyChange("_year", this._year);
            }
            if (this.__month !== this._moment.month() + 1) {
                this.__month = this._moment.month() + 1;
                this.dispatchOwnPropertyChange("_month", this._month);
            }
            if (this.__date !== this._moment.date()) {
                this.__date = this._moment.date();
                this.dispatchOwnPropertyChange("_date", this._date);
            }
            if (this.__hour !== this._moment.hour()) {
                if (!this._is24Hours) {
                    if (this._moment.hour() > 12) {
                        this.__hour = this._moment.hour() - 12;
                        this._dayNightLabel = 'PM'
                    } else {
                        this.__hour = this._moment.hour();
                        this._dayNightLabel = 'AM'
                    }
                } else {
                    this.__hour = this._moment.hour();
                }
                this.dispatchOwnPropertyChange("_hour", this._hour);
            }
            if (this.__minute !== this._moment.minute()) {
                this.__minute = this._moment.minute();
                this.dispatchOwnPropertyChange("_minute", this._minute);
            }
            if (this._second !== this._moment.second()) {
                this._second = this._moment.second();
                this.dispatchOwnPropertyChange("_second", this._second);
            }
            this._calculateDatesInMonth();
        }
    },

    _calculateDatesInMonth: {
        value: function () {
            var days = this._moment.daysInMonth();
            this._dates = {"start": 1, "end": days};
        }
    },

    enterDocument: {
        value: function (firstDraw) {
            if (firstDraw) {
                this._needsAutoLayout = true;
                this.element.addEventListener('keydown', this);
                this.addEventListener("dateItemSelected", this, false);
            }
        }
    },

    draw: {
        value: function () {
            if (this._needsAutoLayout) {
                var format = this.getLocalDateFormat();
                if (!this._is24Hours) {
                    this._hours = {"start": 1, "end": 12};
                } else {
                    this._hours = {"start": 0, "end": 23};
                }
                // this.element.children[3] is hour html node.
                var keyNode = this.element.children[3];
                for (var i = 2; i >= 0; i--) {
                    var c = format[i];
                    var node = false;
                    if (c == "Y") {
                        node = this.templateObjects.yearDateEditorItem.element;
                    } else if (c == "M") {
                        node = this.templateObjects.monthDateEditorItem.element;
                    } else if (c == "D") {
                        node = this.templateObjects.dayDateEditorItem.element;
                    }
                    // item node already at the correct position skop changing  it's index.
                    if (node === this.element.children[i]) {
                        keyNode = node;
                    } else {
                        keyNode = this.element.insertBefore(node, keyNode);
                    }
                }
                this._needsAutoLayout = false;
            }
            if (this._needSetPlaceholder) {
                this.__year = false;
                this.__month = false;
                this.__date = false;
                this.__hour = false;
                this.__minute = false;
                this.dispatchOwnPropertyChange("_month", this._month);
                this.dispatchOwnPropertyChange("_date", this._date);
                this.dispatchOwnPropertyChange("_year", this._year);
                this.dispatchOwnPropertyChange("_hour", this._hour);
                this.dispatchOwnPropertyChange("_minute", this._minute);
                this._needSetPlaceholder = false;
            }
        }
    },

    handleAction: {
        value: function () {
            this._dayNightLabel = this._dayNightLabel === 'AM' ? 'PM' : 'AM';
            var currentHour = this.__hour;
            this.__hour = -1;
            this._hour = currentHour;
        }
    },

    handleKeydown: {
        value: function (event) {
            var self = this;
            // Press TAB key
            if (event.which == 9) {
                event.stopPropagation();
                event.preventDefault();
                this._currentSelectedDateItem.setSelected(false);
                var nodeList = Array.prototype.slice.call(this.element.children);
                var tabIndex = nodeList.indexOf(this._currentSelectedDateItem.element);
                tabIndex++;
                if (this.hasTime) {
                    if (tabIndex > 4) {
                        tabIndex = 0;
                    }

                } else {
                    if (tabIndex > 2) {
                        tabIndex = 0;
                    }
                }
                var dateItemComponent = this.element.children[tabIndex].component;
                if (dateItemComponent) {
                    self._currentSelectedDateItem = dateItemComponent;
                    dateItemComponent.setSelected(true);
                }
                return false;
            }
        }
    },

    handleDateItemSelected: {
        value: function (event) {
            this._currentSelectedDateItem = event.target;
        }
    }

});
