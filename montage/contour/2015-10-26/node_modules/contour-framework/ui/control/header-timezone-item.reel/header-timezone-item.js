/**
 * @module ui/control/header-timezone-item.reel
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    moment = require("moment-timezone"),
    PressComposer = require("montage/composer/press-composer").PressComposer;

/**
 * @class HeaderTimezoneItem
 * @extends Component
 */
exports.HeaderTimezoneItem = Component.specialize(/** @lends HeaderTimezoneItem.prototype */ {

    constructor: {
        value: function HeaderTimezoneItem() {

        }
    },

    _pressComposer: {
        value: null
    },

    _moment: {
        value: null
    },

    moment: {
        set: function (value) {
            if (value) {
                this._moment = value.clone();
                this._invalidate();
            }
        },
        get: function () {
            return this._moment;
        }
    },

    _value: {
        value: null
    },

    value: {
        set: function (value) {
            this._value = value;
        },
        get: function () {
            return this._value;
        }
    },

    time: {
        get: function () {
            if (!this.value || !this.moment) {
                return "";
            }
            return this.moment.format("HH:mm");
        }
    },

    date: {
        get: function () {
            if (!this.value || !this.moment) {
                return "";
            }
            return this.moment.format("DD MMMM YYYY");
        }
    },

    enterDocument: {
        value: function (firstTime) {
            if (firstTime) {
                this._pressComposer = new PressComposer();
                this.addComposerForElement(this._pressComposer, this.element);
            }
        }
    },

    prepareForActivationEvents: {
        value: function () {
            if (!this._preparedForAction && this._pressComposer) {
                this._pressComposer.addEventListener("press", this, false);
                this._preparedForAction = true;
            }
        }
    },

    handlePress: {
        value: function (event) {
            event.preventDefault();
            this.application.delegate.toggleUserTimeZoneList();
        }
    },

    _invalidate: {
        value: function () {
            if (this.value) {
                if (this.value.hasOwnProperty("timezoneOffset")) {
                    var utcOffset = this.value.timezoneOffset * 60;
                    this.moment.utcOffset(utcOffset);
                } else {
                    this.moment.tz(this.getMomentTZ());
                }
            }
            this.dispatchOwnPropertyChange("time", this.time);
            this.dispatchOwnPropertyChange("date", this.date);
        }
    },

    getMomentTZ: {
        value: function () {
            var tz = "";
            if (this.value.city == "Washington, D.C.") {
                tz = "US/Pacific";
            }
            else if (this.value.city == "Honolulu") {
                tz = "US/Central";
            }
            else if (this.value.city == "Tokyo") {
                tz = "Asia/Tokyo";
            }
            else if (this.value.city == "Sydney") {
                tz = "Australia/Sydney";
            }
            else if (this.value.city == "London") {
                tz = "Europe/London";
            }
            else if (this.value.label == "UTC") {
                tz = "UTC";
            }
            return tz;
        }
    }

});
