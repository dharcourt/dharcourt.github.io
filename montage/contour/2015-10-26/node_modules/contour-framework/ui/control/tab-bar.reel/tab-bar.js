var Component = require("montage/ui/component").Component,
    Map = require("collections/map"),
    Promise = require("bluebird"),
    RangeController = require("montage/core/range-controller").RangeController;


/**
 * A {@link TabBarTab} pane is a component that allows an optional substitute
 * component to be used instead of it in a tab. This allows tabs to have
 * multiple modes with different components used for each mode.
 *
 * @typedef TabBarPane
 * @type {external:Component}
 * @property {external:Component} substitute - Specified another component that
 *                                             should be used instead of this
 *                                             one for the selected tab.
 */

/**
 * A {@link TabBarTab} reference provides deferred access to a
 * {@link TabBarPane}. The value of the property providing the pane will be
 * looked up from the object providing the pane only when the pane is needed,
 * allowing the pane to be created only when it is needed.
 *
 * @typedef TabBarReference
 * @type {Object}
 * @property {object} object       - Object providing the value.
 * @property {string} propertyName - Name of the property containing the value.
 */

/**
 * @typedef TabBarTab
 * @type {Object}
 * @property {string}           iconClass     - Name of the class to set on the
 *                                              tab icon element to style it
 *                                              with the appropriate icon.
 * @property {string}           label         - Text displayed in the tab label.
 * @property {?TabBarReference} paneReference - Reference to a component or a
 *                                              promise for a component to use
 *                                              as the tab's pane in the tab bar
 *                                              succession.
 */

/**
 * A bar of tabs
 *
 * @class TabBar
 * @extends external:Component
 */
exports.TabBar = Component.specialize(/** @lends TabBar.prototype */ {

    /**
     * When this is set it will be used to display the pane component defined
     * for the currently selected tab.
     *
     * @type {?external:Succession}
     */
    succession: {
        value: undefined
    },

    /**
     * Defines the tabs to display in the bar.
     *
     * @type {TabBarTab[]}
     */
    tabs: {
        get: function () {
            return this._tabs || [];
        },
        set: function (tabs) {
            var self = this;
            // While loading the template, just record the tabs value. After the
            // template is loaded, though, reset the selection to the first tab
            // when tab values change. This is done in a timeout because any
            // seletion set directly here will be clobberred by the bindings
            // of the selectedTab to the repetitionController's selection.
            tabs = Array.isArray(tabs) ? tabs : [];
            if (!this._isTemplateLoaded) {
                this._tabs = tabs;
            } else if (tabs !== this._tabs) {
                this._tabs = tabs;
                window.setTimeout(function () {
                    self._selectedTab = null;
                    self.selectedTab = tabs[0];
                }, 0);
            }
        }
    },

    selectedIndex: {
        get: function () {
            return this._selectedIndex || 0;
        },
        set: function (index) {
            var tab = this._selectedTab;
            // While loading the template, just record the index value. After
            // the template is loaded, clean up the index value and clear the
            // selection when that value is invalid.
            if (!this._isTemplateLoaded) {
                this._selectedIndex = index;
            } else if ((typeof index === "number" || index instanceof Number) && index >= 0 && index < this.tabs.length) {
                this._selectedIndex = Math.floor(index);
                tab = this.tabs[this._selectedIndex];
            } else if (typeof index !== "undefined") {
                this._selectedIndex = null;
                tab = null;
            }
            // Update the selected tab if necessary.
            if (tab !== this._selectedTab) {
                this.selectedTab = tab;
            }
        }
    },

    selectedTab: {
        get: function () {
            return this._selectedTab || this.tabs[0];
        },
        set: function (tab) {
            var index = this._isTemplateLoaded && this.tabs.indexOf(tab);
            // While loading the template, just record the tab value. After
            // the template is loaded, verify that the tab value is valid and
            // clear the selection when it's not.
            if (!this._isTemplateLoaded) {
                this._selectedTab = tab;
                index = this._selectedIndex;
            } else if (typeof tab === "undefined") {
                tab = this._selectedTab;
                index = this._selectedIndex;
            } else if (index < 0) {
                tab = null;
                index = null;
            }
            // Update the selected tab if necessary.
            if (tab !== this._selectedTab) {
                this._selectedTab = tab;
            }
            // Update the selected index if necessary.
            if (index !== this._selectedIndex) {
                this.selectedIndex = index;
            }

            this.needsDraw = true;
        }
    },

    _selectedPaneReference: {
        get: function () {
            return (this.selectedTab || {}).paneReference;
        }
    },

    //templateDidLoad: {
    //    value: function () {
    //        this._isTemplateLoaded = true;
    //        if (this._selectedTab) {
    //            this.selectedTab = this._selectedTab;
    //        } else {
    //            this.selectedIndex = this._selectedIndex || 0;
    //        }
    //        //this.needsDraw = true;
    //    }
    //},

    draw: {
        value: function () {
            if (!this._selectedPaneReference) return;

            var succession = this.succession,
                promise = succession && this._getPanePromise(this._selectedPaneReference);

            if (promise !== this._drawnPanePromise) {
                this._drawnPanePromise = promise;
                if (promise) {
                    promise.then(function (pane) {
                        succession.content = pane.substitute || pane;
                    }, function (error) {
                        console.trace(error);
                    });
                }
            }
        }
    },

    _getPanePromise: {
        value: function (reference) {
            // Pane promises are cached so the panes themselves will be cached.
            // The cache has two levels: The first level is a map of reference
            // objects to second level caches, the second level caches are a map
            // of their object's property names to that object's pane promises.
            var cache = this._panePromises && this._panePromises.get(reference && reference.object) || {};
            if (!cache[reference && reference.propertyName]) {
                cache[reference && reference.propertyName] = this._getReferencePromise(reference);
                this._panePromises = this._panePromises || new Map();
                this._panePromises.set(reference && reference.object, cache);
            }
            return cache[reference && reference.propertyName];
        }
    },

    _getReferencePromise: {
        value: function (reference) {
            // Pane references deffer each pane's creation until it is needed.
            var value = null;
            if (reference && reference.object && reference.propertyName) {
                value = reference.object[reference.propertyName];
                if (typeof value === "undefined") {
                    value = null;
                }
            }
            return (value && typeof value.then === "function") ? value : Promise.resolve(value);
        }
    }

});
