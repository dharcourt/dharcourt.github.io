/**
 * @module "ui/control/search-bar.reel"
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    PressComposer = require("montage/composer/press-composer").PressComposer;
/**
 * @class SearchBar
 * @extends Component
 *
 */
exports.SearchBar = Component.specialize(/** @lends SearchBar.prototype */{
    _pressComposer: {
        value: null
    },

    /*
     * A delegate that handle search-bar text change.
     *
     * delegate object must implement method:
     * searchTextDidChange(text, callback)
     */
    delegate: {
        value: null
    },

    _hasCenterMode: {
        value: true
    },

    /*
     * If hasCenterMode, search-bar icon and place holder will be shown at center at first.
     *
     */
    hasCenterMode: {
        set: function (value) {
            if (this._hasCenterMode != value) {
                this._hasCenterMode = value;
                if (!value) {
                    this._state = "";
                }
                this.needsDraw = true;
            }
        },
        get: function () {
            return this._hasCenterMode;
        }
    },

    _state: {
        value: "CENTER"
    },

    _text: {
        value: null
    },

    text: {
        set: function (value) {
            if (this._text !== value) {
                this._text = value;
                if (!this._isDelegateSearching) {
                    this._delegateSearchCurrentText();
                }
            }
        },
        get: function () {
            return this._text;
        }
    },

    _placeholder: {
        value: null
    },

    placeholder: {
        set: function (value) {
            if (value !== this._placeholder) {
                this._isChangingPlaceholder = true;
                this.needsDraw = true;
            }
            this._placeholder = value;
        },
        get: function () {
            return this._placeholder;
        }
    },

    cancel: {
        value: function () {
            // if there is text in search-bar, clean it and call delegate.
            if (this.text) {
                this.text = "";
                this._delegateSearchCurrentText();
            }
            this.dispatchEventNamed("cancelAction", true, true, {});
            if (this.hasCenterMode) {
                this._state = "CENTER";
            } else {}
            this._isCancling = true;
            this.needsDraw = true;
        }
    },

    handleAction: {
        value: function () {
            this.cancel();
        }
    },

    handlePress: {
        value: function () {
            if (this.hasCenterMode) {
                this._state = "";
                if (document.activeElement != this.templateObjects.textField.element) {
                    this._isFocusingInputField = true;
                    this.needsDraw = true;
                }
            }
        }
    },

    /**
     * If delegate is doing searching
     */
    _isDelegateSearching: {
        value: false
    },

    _previousSearchText: {
        value: false
    },

    _delegateSearchCurrentText: {
        value: function () {
            var self = this;
            if (this.delegate) {
                this._isDelegateSearching = true;
                this._previousSearchText = this.text;
                this.delegate.searchTextDidChange(this.text, function () {
                    self._searchTextDidChangeFinishedCallBack();
                });
            }
        }
    },

    /**
     * delegate searching function callback, set _isDelegateSearching = false, 'debounce' searching
     */
    _searchTextDidChangeFinishedCallBack: {
        value: function () {
            this._isDelegateSearching = false;
            if (this.text != this._previousSearchText) {
                this._delegateSearchCurrentText();
            }
        }
    },

    prepareForActivationEvents: {
        value: function () {
            var self = this;
            // Do cancel if focus out textField and no search text
            this.templateObjects.textField.element.addEventListener('blur', function () {
                if (!self.text) {
                    self.cancel();
                }
            }, false);
        }
    },

    draw: {
        value: function () {

            if (this.hasCenterMode && !this._pressComposer) {
                this._pressComposer = new PressComposer();
                this.addComposerForElement(this._pressComposer, this.element.children[0]);
                if (!this.text) {
                    this._state = "CENTER";
                }
                this._pressComposer.addEventListener("press", this, false);
            } else if (!this.hasCenterMode && this._pressComposer) {
                this._state = "";
                this._pressComposer.removeEventListener("press", this, false);
                this.removeComposer(this._pressComposer);
                this._pressComposer = null;
            }

            // When placeholder changed, reset it.
            if (this._isChangingPlaceholder) {
                this.templateObjects.textField.element.setAttribute("placeholder", this.placeholder);
                this.templateObjects.textField.element.setAttribute('size', this.templateObjects['textField'].element.getAttribute('placeholder').length);
                this._isChangingPlaceholder = false;
            }
            // When clicking on text input wrapper, need set focus in text input
            if (this._isFocusingInputField) {
                this.templateObjects.textField.element.focus();
                this._isFocusingInputField = false;
            }
            // Cancel focus from input when doing cancel.
            if (this._isCancling) {
                this.templateObjects.textField.element.blur();
                this._isCancling = false;
            }
        }
    }
});
