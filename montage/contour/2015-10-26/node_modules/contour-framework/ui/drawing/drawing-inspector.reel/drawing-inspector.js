/**
 * @module ui/drawing-inspector.reel
 */
var Component = require("montage/ui/component").Component,
    Mode = require("ui/map/map.reel/map").Mode,
    RangeController = require("montage/core/range-controller").RangeController,
    Mode = require("ui/map/map.reel").Mode;

/**
 * @class DrawingInspector
 * @extends Component
 */
exports.DrawingInspector = Component.specialize(/** @lends DrawingInspector.prototype */{

    availableMapModes: {
        value: [
            Mode["AnnotationTool"],
            Mode["Circle"],
            Mode["FreeLineTool"],
            Mode["FreePolygonTool"],
            Mode["PlacemarkTool"],
            Mode["ImageTool"],
            Mode["LineTool"],
            Mode["PolygonTool"],
            Mode["Rectangle"]
        ]
    },

    _deletedFigures: { value: null },

    deletedFigures: {
        get: function() {
            if (!this._deletedFigures) {
                this._deletedFigures = new RangeController();
                this._deletedFigures.multiSelect = true;
            }
            return this._deletedFigures;
        },
        set: function(value) {
            this._deletedFigures = value;
        }
    },

    _eraserPane: {
        get: function() {
            var self = this;
            return require.async("ui/drawing/figure-list.reel").then(function (exports) {
                var pane = new exports.FigureList();
                pane.rangeController = self.deletedFigures;
                pane.listIsEmptyText = "Select a figure to remove it from the map";
                pane.isEraser = true;
                pane.addEventListener("clearAction", self, false);
                pane.addEventListener("undoAction", self, false);
                pane.addEventListener("selectFigureAction", self, false);
                return pane;
            });
        }
    },

    //Set in serialization
    _hasSelectedFigureBinding: {
        set: function (value) {
            if (value && !this.getBinding("selectedFigure")) {
                //TODO: Move selectedFigure to delegate and remove private variable accessor
                this.defineBinding("selectedFigure", {"<-": "application.delegate.map._selectedFigureOverlay"});
            } else if (!value && this.getBinding("selectedFigure")) {
                this.cancelBinding("selectedFigure");
                this.application.delegate.map.setSelectedFigureOverlay(null);
            }
        }
    },

    _listPane: {
        get: function() {
            var self = this;
            return require.async("ui/drawing/figure-list.reel").then(function (exports) {
                var pane = new exports.FigureList();
                pane.rangeController = self.rangeController;
                pane.listIsEmptyText = "Figure list is empty";
                pane.addEventListener("selectFigureAction", self, false);
                return pane;
            });
        }
    },

    __toolPane: { value: null },

    _toolPane: {
        get: function() {
            return this.__toolPane
        },
        set: function (value) {
            this.__toolPane = value;
            this.tabBar.selectedTab = this.tabBar.tabs[1];
        }
    },
    handleClearAction: {
        value: function(e) {
            e.stopPropagation();
            if (this.deletedFigures.content) {
                (this.deletedFigures.selection.length > 0 && this.deletedFigures.deleteEach(this.deletedFigures.selection.slice())) || this.deletedFigures.clear();
            }
        }
    },
    handleUndoAction: {
        value: function(e) {
            e.stopPropagation();
            if (this.deletedFigures.content) {
                if (this.deletedFigures.selection.length > 0) {
                    var figures = this.deletedFigures.selection.slice(), i, length;
                    this.deletedFigures.deleteEach(figures);
                    for (i = 0, length = figures.length; i < length; i++) {
                        this.application.delegate.figures.push(figures[i]);
                    }
                } else {
                    this.application.delegate.figures.push(this.deletedFigures.pop());
                }
            }
        }
    },
    handleSelectFigureAction: {
        value: function (event) {
            event.stopPropagation();
            this._selectFigure(event.detail.figure);
        }
    },
    _isBound: {
        value: false
    },
    _isVisible: {
        value: false
    },
    isVisible: {
        set: function (value) {
            this._isVisible = value;
            if (this._isVisible) {
                this._figureInspector && (this._figureInspector.isVisible = false);
                this.application.map.currentMode = Mode["Pan"];
            } else {
                if (this._toolPane) {
                    this._toolPane.clearSelection(false);
                }
            }
        },
        get: function () {
            return this._isVisible;
        }
    },

    rangeController: { value: new RangeController() },

    selectedFigure: {
        set: function(value) {
            if (value) {
                this._selectFigure(value.figure);
            }
        }
    },
    _selectFigure: {
        value: function(figure) {
            if (figure) {
                if (this._figureInspector && this._figureInspector.isVisible) {
                    this._figureInspector.figure = figure;
                } else if (this.tabBar.selectedIndex === 2 && this.application.delegate.currentMapMode === Mode["Pan"]) {
                    if (!this.deletedFigures.has(figure)) {
                        this.deletedFigures.add(figure);
                        this.application.delegate.figures.delete(figure);
                    } else if (this.deletedFigures.selection.has(figure)) {
                        this.deletedFigures.deselect(figure);
                    } else {
                        this.deletedFigures.select(figure);
                    }
                    this.application.map.setSelectedFigureOverlay(null);
                    this.application.map.enterPanMode();
                } else {
                    this.openFigureInspector(figure);
                }
            } else {
                this.openFigureInspector(figure);
            }
        }
    },

    _figureInspector: { value: null},

    _figureInspectorPromise: { value: null },

    openFigureInspector: {
        value: function (figure) {
            var self = this;

            // opening for first time
            if (!this._figureInspectorPromise) {
                this._figureInspectorPromise = require.async("ui/drawing/figure-inspector.reel")
                    .then(function (exports) {
                        self._figureInspector = new exports.FigureInspector();
                        self._figureInspector.isVisible = true;
                        self.panelSuccession.components.push(self._figureInspector);
                        self._figureInspector.figure = figure;
                        return self._figureInspector;
                    });

            // not currently open
            } else if (this.panelSuccession.content !== this._figureInspector) {
                this._figureInspector.figure = figure;
                this._figureInspector.isVisible = true;
                this.panelSuccession.components.push(this._figureInspector);
            }

            return this._figureInspectorPromise;
        }
    }
});
