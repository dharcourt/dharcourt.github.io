/**
 * @module ui/drawing/figure-preview.reel
 */
var FigureComponent = require("ui/map/figure-component").FigureComponent,
    FigureType = require("logic/model/figure").FigureType;

/**
 * @class FigurePreview
 * @extends Component
 */
exports.FigurePreview = FigureComponent.specialize(/** @lends FigurePreview# */ {
    constructor: {
        value: function FigurePreview() {
            this.super();
        }
    },
    draw: {
        value: function () {
            this.super();
            var allElements = this.element.querySelectorAll("*"), i, length;

            for (i = 0, length = allElements.length; i < length; i++) {
                this._setFloatAttributeOnElement(allElements[i],"x",this._normalizePosition.bind(this));
                this._setFloatAttributeOnElement(allElements[i],"y",this._normalizePosition.bind(this));
                this._setFloatAttributeOnElement(allElements[i],"stroke-width",function(val) {
                    return !isNaN(this._scale) ? val/this._scale : val;
                });
                this._normalizePointsAttributeOnElement(allElements[i]);

                allElements[i].setAttributeNS(null,"transform",this._previewTransformValue);
            }
            this.element.setAttributeNS(null,"transform",this._previewTransformValue);
        }
    },
    _elementCache: {
        value: []
    },
    _normalizePointsAttributeOnElement: {
        value: function(element) {
            var attr = element.getAttribute("points"),
                points, i, length, x, y, point, normalizedPoints;
            if (attr && (points = attr.trim().split(" "))) {
                normalizedPoints = [];
                for (i = 0, length = points.length; i < length; i++) {
                    point = points[i].split(",");
                    x = this._normalizePosition(parseFloat(point[0])), y = this._normalizePosition(parseFloat(point[1]));
                    normalizedPoints.push(x + "," + y);
                }
                attr = normalizedPoints.join(" ");
                element.setAttribute("points",attr);
            }
        }
    },
    _normalizePosition: {
        value: function(coordinateToNormalize) {
            var val = !isNaN(this._scaledBuffer) && coordinateToNormalize !== 0 ? coordinateToNormalize-10+this._scaledBuffer : coordinateToNormalize;
            return val;
        }
    },
    _previewTransformValue: {
        value: 0
    },
    _setPreviewAttributes: {
        value: false
    },
    _scale: {
        value: 0
    },
    _scaledBuffer: {
        value: 0
    },
    _setFloatAttributeOnElement: {
        value: function(element,attributeName,transform) {
            var attr = parseFloat(element.getAttribute(attributeName));
            if (!isNaN(attr)) {
                if (transform) {
                    attr = transform(attr);
                }
                element.setAttribute(attributeName,attr);
            }
        }
    },
    updateGeometry: {
        value: function () {
            this.super();
            var distanceToTranslate,translateOverflow,
                figureHeight = this.bounds.yMax - this.bounds.yMin,
                figureWidth = this.bounds.xMax - this.bounds.xMin,
                useHeight = figureHeight > figureWidth;
                this._scaledBuffer = useHeight ? figureHeight/25 : figureWidth /25;

            figureHeight = figureHeight  + (this._scaledBuffer*2);
            figureWidth = figureWidth  + (this._scaledBuffer*2);
            if (this.figure.type !== FigureType["Placemark"]) {
                figureHeight-= 20;
                figureWidth-=20;
            }

            this._scale = useHeight ? 48 / figureHeight : 48 / figureWidth,
                distanceToTranslate = Math.abs(figureHeight - figureWidth)/ 2,
                translateOverflow = 0;
            this._scale = isFinite(this._scale) ? this._scale : 1;
            if (useHeight && figureHeight < (distanceToTranslate + figureWidth)) {
                translateOverflow = (distanceToTranslate + figureWidth) - figureHeight;
            } else if (!useHeight && figureWidth < (figureHeight + distanceToTranslate)) {
                translateOverflow = (figureHeight + distanceToTranslate) - figureWidth;
            }
            distanceToTranslate = distanceToTranslate - translateOverflow;
            var translate = useHeight ? distanceToTranslate  + ",0": "0,"+distanceToTranslate;
            this._previewTransformValue = "scale("+this._scale+") translate("+translate+")";
        }
    }
});
