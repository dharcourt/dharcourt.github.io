/**
 * @module ui/map/leaflet-engine.reel
 * @requires montage/ui/component
 */
var MapEngine = require("ui/map/map-engine").MapEngine,
    Figure = require("logic/model/figure").Figure,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    L = require("leaflet"),
    OverlayType = require("logic/map/overlay-type").OverlayType;

// @todo create some gloabal ASSETS_PATH variable
L.Icon.Default.imagePath = "node_modules/contour-framework/design/assets/images/map/";

/**
 * @class LeafletEngine
 * @extends MapEngine
 *
 * All coordinates in the API below are in EPSG:3857.
 */
exports.LeafletEngine = MapEngine.specialize(/** @lends LeafletEngine# */ {

    constructor: {
        value: function LeafletEngine() {
            //this.super();

            L.Point.prototype.ceil = function () {
                return this.clone()._ceil();
            };

            L.Point.prototype._ceil = function () {
                this.x = Math.ceil(this.x);
                this.y = Math.ceil(this.y);
                return this;
            };
        }
    },

    _centerChanged: {
        value: false
    },

    _coordinateNeedsNormalization: {
        value: function (coordinate) {
            return this._distanceBetweenPoints([this.position.center[0], coordinate[1]], coordinate) > 180;
        }
    },

    _disablePan: {
        value: function() {
            this.map.dragging.disable();
        }
    },

    _drawFeatureCluster: {
        value: function (cluster) {

            var style = cluster.clusterer.renderer.render(cluster),
                self = this,
                coordinate = this._normalizedCoordinate(cluster.center),
                size = style.scaledSize || style.size,
                icon = L.icon({
                    iconSize: [size.width, size.height],
                    iconUrl: style.url
                }),
                marker = L.marker([coordinate[1], coordinate[0]], { icon: icon, zIndexOffset: 900 });

            marker.addTo(this.map);
            marker.on("click", function (event) {
                var bounds = cluster.geographicBounds();
                self.map.fitBounds([
                    [bounds[0][1], bounds[0][0]],
                    [bounds[1][1], bounds[1][0]]
                ]);
            });
            return [marker];
        }
    },

    _drawHazardCluster: {

        value: function (cluster) {

            var angle = 360 / cluster.size,
                radius = 22,
                theta = 90,
                feature,
                coordinate,
                hazardIcons = [],
                icon,
                iconCounter,
                marker,
                overlay = this.overlayRegistry[cluster.features[0].properties.componentId],
                symbols = [],
                style,
                size,
                normalizedCluster = this._normalizedCoordinate(cluster.center),
                clusterCenter = this.map.latLngToLayerPoint(L.latLng(normalizedCluster[1], normalizedCluster[0])),
                i, length,
                x, y;

            var centerCoordinate = L.latLng(normalizedCluster[1], normalizedCluster[0]);
            var hub = L.circleMarker(centerCoordinate, {
                clickable: false,
                color: "#FF0000",
                fill: true,
                fillColor: "#FF0000",
                fillOpacity: 1.0,
                opacity: 1.0,
                weight: 3
            });

            hub.setRadius(2);
            hub.addTo(this.map);
            symbols.push(hub);

            for (i = 0, length = cluster.size; i < length; i++) {

                feature = cluster.features[i];
                x = clusterCenter.x + radius * Math.cos(theta * (Math.PI / 180));
                y = clusterCenter.y - (radius * Math.sin(theta * (Math.PI / 180)));
                coordinate = this.map.layerPointToLatLng(L.point(x, y));

                var spoke = L.polyline([centerCoordinate, coordinate], {
                    clickable: false,
                    color: "#FF0000",
                    fill: false,
                    opacity: 1.0,
                    weight: 3
                });
                spoke.addTo(this.map);
                symbols.push(spoke);

                style = overlay.component.layer.renderer.render(feature.properties);
                size = style.scaledSize || style.size;
                icon = L.icon({
                    iconSize: [size.width, size.height],
                    iconUrl: style.url
                });
                hazardIcons.push({
                    coordinate: coordinate,
                    icon: icon
                });
                theta -= angle;
            }

            for (iconCounter = 0, i = hazardIcons.length - 1; i >= 0; iconCounter++, i--) {
                icon = hazardIcons[i];
                marker = L.marker(icon.coordinate, {
                    icon: icon.icon,
                    zIndexOffset: overlay.component.layer.depth + (iconCounter * 100)
                });
                marker.addTo(this.map);
                symbols.push(marker);
            }
            return symbols;
        }
    },

    _drawPointFeature: {
        value: function (feature) {
            var overlay = this.overlayRegistry[feature.properties.componentId],
                style = overlay.component.layer.renderer.render(feature.properties),
                coordinate = this._normalizedCoordinate(feature.geometry.coordinates),
                size = style.scaledSize || style.size;

            size = size ? [size.width, size.height] : null;

            var icon = L.icon({
                    iconSize: size,
                    iconUrl: style.url
                }),
                marker = L.marker([coordinate[1], coordinate[0]], { icon: icon, zIndexOffset: overlay.component.layer.depth });

            marker.addTo(this.map);
            return marker;
        }
    },

    _drawPointSymbol: {
        value: function (symbol) {
            var mapSymbol,
                style = symbol.properties.style;
            if (symbol.properties.radius) {
                var r = symbol.properties.radius,
                    d = r * 2,
                    b = d + (d/5),
                    c = b/ 2,
                    path = "M "+c+","+c+" m -"+r+", 0 a "+r+", "+r+" 0 1,0 "+d+", 0 a "+r+","+r+" 0 1,0 -"+d+" ,0 Z",
                    svgString = "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' ",
                    svgUrl, icon;

                svgString += "height='"+b+"px' ";
                svgString += "width='"+b+"px' >";
                svgString += "<path ";
                svgString += "stroke='"+(style.strokeColor || "#000")+"' ";
                svgString += "stroke-width='"+(style.strokeWeight || 1)+"' ";
                svgString += "stroke-opacity='"+(style.strokeOpacity || 1)+"' ";
                svgString += "fill='"+(style.fillColor || "none")+"' ";
                svgString += "fill-opacity='"+(style.fillOpacity|| 0)+"' ";
                svgString += "d='"+path+"' />";
                svgString += " </svg>";
                svgUrl = "data:image/svg+xml;base64," + btoa(svgString);
                icon = L.icon({
                    iconUrl: svgUrl,
                    iconSize: [b,b]
                });
                mapSymbol = L.marker([symbol.geometry.coordinates[1],symbol.geometry.coordinates[0]], {icon:icon});
                mapSymbol.addTo(this.map);
            }
            return mapSymbol;
        }
    },

    _drawMultiPointFeature: {
        value: function (feature) {

            var overlay = this.overlayRegistry[feature.properties.componentId],
                style = overlay.component.layer.renderer.render(feature.properties),
                coordinate,
                symbol,
                icon = L.icon({
                    iconSize: [style.size.width, style.size.height],
                    iconUrl: style.url
                }),
                marker,
                i, length;

            // TODO add handling for drawFeature returning an array...
            for (i = 0, length = feature.geometry.coordinates.length; i < length; i++) {
                coordinate = this._normalizedCoordinate(feature.geometry.coordinates[i]);
                marker = L.marker([coordinate[1], coordinate[0]], { icon: icon });
                marker.addTo(this.map);
                symbol = marker;
            }
            return symbol;
        }
    },

    _drawLineFeature: {
        value: function (feature) {
            var coordinates = [],
                normalizedCoordinate,
                paths = feature.geometry.coordinates,
                polyline,
                overlay = this.overlayRegistry[feature.properties.componentId],
                style = overlay.component.layer.renderer.render(feature.properties),
                i, length;

            for (i = 0, length = paths.length; i < length; i++) {
                var path = paths[i];
                normalizedCoordinate = this._normalizedCoordinate([path[0], path[1]]);
                coordinates.push([normalizedCoordinate[1], normalizedCoordinate[0]]);
            }

            polyline = L.polyline(coordinates, {
                    color: style.strokeColor,
                    weight: Math.round(style.strokeWeight)}
            );
            polyline.addTo(this.map);
            return polyline;
        }
    },

    _drawMultiLineFeature: {
        value: function (feature) {
            var coordinates = [],
                normalizedCoordinate,
                paths = feature.geometry.coordinates,
                polyline,
                overlay = this.overlayRegistry[feature.properties.componentId],
                style = overlay.component.layer.renderer.render(feature.properties),
                i, length,
                j, jLength;

            for (i = 0, length = paths.length; i < length; i++) {
                var path = paths[i];
                for (j = 0, jLength = path.length; j < jLength; j++) {
                    normalizedCoordinate = this._normalizedCoordinate([path[j][0], path[j][1]]);
                    coordinates.push([normalizedCoordinate[1], normalizedCoordinate[0]]);
                }
            }

            polyline = L.polyline(coordinates, {
                    color: style.strokeColor,
                    weight: Math.round(style.strokeWeight)}
            );
            polyline.addTo(this.map);
            return polyline;
        }
    },

    _drawPolygonFeature: {
        value: function (feature) {

            var linearRings = [],
                rings = feature.geometry.coordinates,
                overlay = this.overlayRegistry[feature.properties.componentId],
                style = overlay.component.layer.renderer.render(feature.properties),

                polygon,
                i, length,
                j, jLength;

            for (i = 0, length = rings.length; i < length; i++) {

                var ring = rings[i],
                    path = [];

                for (j = 0, jLength = ring.length; j < jLength; j++) {
                    path.push(this._normalizedCoordinate([ring[j][1], ring[j][0]]));
                }

                linearRings.push(path);

            }

            polygon = L.multiPolygon(linearRings, {
                color: style.strokeColor,
                fillColor: style.fillColor,
                weight: Math.round(style.strokeWeight)
            });
            polygon.addTo(this.map);
            return polygon;
        }
    },

    _drawGroundOverlayFeature: {
        value: function( feature ) {
            var coordinates = feature.geometry.coordinates;
            var properties = feature.properties;
            var options = {
                opacity: properties.opacity
            };
            return  L.imageOverlay(properties.url, coordinates, options).addTo(this.map);
        }
    },


    _enablePan: {
        value: function () {
            this.map.dragging.enable();
        }
    },

    _eventContexts: {
        value: {}
    },

    _featureRequiresNormalization: {
        value: function (feature, symbol) {
            var requiresNormalization = false;
            if (GeometryUtilities.boundingBoxContainsFeature(this.bbox, feature)) {
                switch (feature.geometry.type) {
                    case "Point":
                        requiresNormalization = this._pointFeatureRequiresNormalization(symbol);
                        break;
                    case "MultiPoint":
                        requiresNormalization = this._multiPointFeatureRequiresNormalization(symbol);
                        break;
                    case "MultiLineString":
                        requiresNormalization = this._lineFeatureRequiresNormalization(symbol);
                        break;
                    case "MultiPolygon":
                        requiresNormalization = this._multiPolygonFeatureRequiresNormalization(symbol);
                        break;
                }
            }
            return requiresNormalization;
        }
    },

    _initializeEventListeners: {
        value: function () {

            var self = this;

            this.map.addEventListener("moveend", function () {
                self._setPositionAndBounds();
            });

            this.map.addEventListener("viewreset", function () {
                self._origin = self.map.project(self.map.unproject(self.map.getPixelOrigin()), self.map.getZoom()).round();
                self.drawQueuedObjects();
            });

            this.map.addEventListener("zoomstart", function () {
                self.willZoom();
            });

            this.map.addEventListener("zoomend", function () {
                self._setPositionAndBounds();
                self.didZoom();
            });

            this.map.addEventListener("resize", function () {

                self._resize();
                var size = self.map.getSize(),
                    minZoom = self._calculateMinimumZoomLevel(size.x, size.y);

                if (self.map.options.minZoom !== minZoom) {
                    self.map.options.minZoom = minZoom;
                    if (self.map.getZoom() < minZoom) {
                        self.map.setZoom(minZoom);
                    }
                }
            });
        }
    },

    _initializeFigureOverlay: {
        value: function (overlay) {
            var component = overlay.component,
                context = {
                    map: this.map,
                    component: component
                };
            this._eventContexts[component.uuid] = context;
            this.appendElementToOverlayPaneWithId(component.element, "PopUp");
            if (component.figure && component.figure.isNewObject === false) {
                component.figure.needsDraw = true;
                component.needsDraw = true;
            }
            if (component.isPersistent === false || (component.figure && component.figure.isNewObject)) {
                this.map.addEventListener("move", this._positionFigureOverlay, context);
                this.map.addEventListener("resize", this._positionFigureOverlay, context);
            }
            component.engineShift = 0;
            this._positionFigureOverlay.call(context);
        }
    },

    _initializeMap: {

        value: function () {

            var layer = L.tileLayer('http://{s}.tiles.mapbox.com/v3/gegao0124.kff6be36/{z}/{x}/{y}.png', {zIndex: 1}),
                element = this.element.querySelector(".contour-LeafletEngine-map"),
                position = this.mapComponent.position;

            this.maxScale = layer.options.maxZoom;
            if (this.maxScale < position.zoom) {
                position.zoom = this.maxScale;
            }
            this.map = L.map(element, {

                center: [position.center[1], position.center[0]],
                dragging: true,
                layers: [layer],
                // this turned out to have a strange effect with the World literally jumping.
                worldCopyJump: true,
                minZoom: this._calculateMinimumZoomLevel(element.offsetWidth, element.offsetHeight),
                zoom: position.zoom,
                zoomControl: false
            });
            this.isInitialized = true;
            this._initializeEventListeners();
            this._setPositionAndBounds();
            this._origin = this.map.project(this.map.unproject(this.map.getPixelOrigin()), this.map.getZoom()).round();
            this.updateTileBounds();
        }
    },

    _initializeHeatMapOverlay: {
        value: function (overlay) {

            if (this.map) {

                var component = overlay.component,
                    context = {
                        map: this.map,
                        component: component
                    };

                this._eventContexts[component.uuid] = context;
                this.map.getPanes()["overlayPane"].appendChild(component.element);
                this.map.addEventListener("move", this._positionHeatMapOverlay, context);
                this.map.addEventListener("resize", this._positionHeatMapOverlay, context);
                this._positionHeatMapOverlay.call(context);

            } else {
                var self = this;
                setTimeout(function() {
                    self._queuedOverlays.push({
                        overlay: overlay,
                        action: "add"
                    });
                    self.needsDraw = true;
                }, 0);
            }
        }
    },

    _lineFeatureRequiresNormalization: {
        value: function (symbol) {

            var coordinate,
                path = symbol.getLatLngs(),
                requiresNormalization = false,
                i, length = path.length;

            for (i = 0; i < length; i++) {
                coordinate = path[i];
                requiresNormalization = this._distanceBetweenPoints([this.position.center[0], coordinate.lat], [coordinate.lng, coordinate.lat]) > 180;
                if (requiresNormalization) break;
            }

            return requiresNormalization;
        }
    },

    _multiPointFeatureRequiresNormalization: {
        value: function (symbol) {
            var coordinate = symbol.getLatLng();
            return this._distanceBetweenPoints([this.position.center[0], coordinate.lat], [coordinate.lng, coordinate.lat]) > 180;
        }
    },

    _multiPolygonFeatureRequiresNormalization: {
        value: function (symbol) {

            var coordinate,
                requiresNormalization = false;

            if (symbol.getLatLngs().length > 0) {
                var outerRing = symbol.getLatLngs()[0],
                    i, length = outerRing.length;

                for (i = 0; i < length; i++) {
                    coordinate = outerRing[i];
                    requiresNormalization = this._distanceBetweenPoints(
                            [this.position.center[0], coordinate.lat], [coordinate.lng, coordinate.lat]
                        ) > 180;
                    if (requiresNormalization) break;
                }
            }
            return requiresNormalization;
        }
    },

    _normalizeClusterCoordinates: {
        value: function (symbol) {
            var normalizedCoordinate;
            if (symbol && typeof symbol.getLatLng === "function") {

                var coordinate = symbol.getLatLng();
                normalizedCoordinate = this._normalizedCoordinate([coordinate.lng, coordinate.lat]);
                symbol.setLatLng([normalizedCoordinate[1], normalizedCoordinate[0]]);

            } else if (symbol && typeof symbol.getLatLngs === "function") {

                var normalizedPath = [],
                    path = symbol.getLatLngs(),
                    offset = 0,
                    i, length = path.length;

                for (i = 0; i < length; i++) {
                    offset = this._normalizationOffset([path[i].lng, path[i].lat]);
                    if (offset !== 0) {
                        break;
                    }
                }

                for (i = 0; i < length; i++) {
                    normalizedPath.push([path[i].lat, path[i].lng + offset]);
                }

                symbol.setLatLngs(normalizedPath);
            }
        }
    },

    _normalizedCoordinate: {
        value: function (coordinate) {
            return [coordinate[0] + this._normalizationOffset(coordinate), coordinate[1]];
        }
    },

    _normalizeFeatureCoordinates: {
        value: function (feature, symbol) {
            switch (feature.geometry.type) {
                case "Point":
                    this._normalizePointFeatureCoordinates(feature, symbol);
                    break;
                case "MultiPoint":
                    this._normalizeMultiPointFeatureCoordinates(feature, symbol);
                    break;
                case "MultiLineString":
                    this._normalizeLineFeatureCoordinates(feature, symbol);
                    break;
                case "MultiPolygon":
                    this._normalizeMultiPolygonFeatureCoordinates(feature, symbol);
                    break;
            }
        }
    },

    _normalizeLineFeatureCoordinates: {
        value: function (feature, symbol) {

            var i, length,
                coordinate,
                normalizedPath,
                offset = 0,
                path;

            path = feature.geometry.coordinates[0];
            length = path.length;

            for (i = 0; i < length; i++) {
                coordinate = path[i];
                offset = this._normalizationOffset(coordinate);
                if (offset !== 0) {
                    break;
                }
            }

            normalizedPath = [];
            for (i = 0; i < length; i++) {
                coordinate = path[i];
                normalizedPath.push(L.latLng(coordinate[1], coordinate[0] + offset));
            }

            symbol.setLatLngs(normalizedPath);
        }
    },

    _normalizeMultiPointFeatureCoordinates: {
        value: function (feature, symbol) {
            var normalizedCoordinate = this._normalizedCoordinate(feature.geometry.coordinates[0]);
            symbol.setLatLng([normalizedCoordinate[1], normalizedCoordinate[0]]);
        }
    },

    _normalizeMultiPolygonFeatureCoordinates: {
        value: function (feature, symbol) {

            var i, length,
                j, jLength,
                coordinate,
                normalizedRings = [],
                offset = 0,
                outerRing,
                rings;

            rings = feature.geometry.coordinates;
            outerRing = rings[0];

            for (i = 0, length = outerRing.length; i < length; i++) {
                coordinate = outerRing[i];
                offset = this._normalizationOffset(coordinate);
                if (offset !== 0) {
                    break;
                }
            }

            length = feature.geometry.coordinates.length;
            for (i = 0; i < length; i++) {

                var ring = feature.geometry.coordinates[i],
                    normalizedRing = [];

                for (j = 0, jLength = ring.length; j < jLength; j++) {
                    coordinate = ring[j];
                    normalizedRing.push(L.latLng(coordinate[1], coordinate[0] + offset));
                }

                normalizedRings.push(normalizedRing);
            }
            symbol.setLatLngs(normalizedRings);
        }
    },

    _normalizationOffset: {
        value: function (coordinate) {
            var distance = this._distanceBetweenPoints(coordinate, [this.position.center[0], coordinate[1]]),
                normalizedCoordinate = [coordinate[0], coordinate[1]],
                normalizationOffset = 0;

            if (distance > 180) {
                var incrementer = this.position.center[0] > coordinate[0] ? 360 : -360;
                do {
                    normalizedCoordinate[0] = normalizedCoordinate[0] + incrementer;
                    normalizationOffset += incrementer;
                    distance = this._distanceBetweenPoints(normalizedCoordinate, [this.position.center[0], normalizedCoordinate[1]]);
                } while (distance > 180);
            }

            return normalizationOffset;
        }
    },

    _normalizePointFeatureCoordinates: {
        value: function (feature, symbol) {
            var normalizedCoordinate = this._normalizedCoordinate(feature.geometry.coordinates);
            symbol.setLatLng([normalizedCoordinate[1], normalizedCoordinate[0]]);
        }
    },

    _oldCenter: {
        value: null
    },

    _origin: {
        value: null
    },

    _overlayRegistry: {
        value: null
    },

    _pointFeatureRequiresNormalization: {
        value: function (symbol) {
            var coordinate = symbol.getLatLng();
            return this._distanceBetweenPoints([this.position.center[0], coordinate.lat], [coordinate.lng, coordinate.lat]) > 180;
        }
    },

    _positionFigureOverlay: {
        value: function (component) {

            var self = this._eventContexts ? this._eventContexts[component.uuid]: this,
                map = self.map,
                component = self.component,
                width = map.getContainer().offsetWidth,
                height = map.getContainer().offsetHeight,
                pixelCenter = map.latLngToLayerPoint(map.getCenter()),
                offset = {
                    left: pixelCenter.x - width / 2,
                    top: pixelCenter.y - height / 2
                },
                element = component.element;

            element.setAttributeNS(null, "width", width);
            element.setAttributeNS(null, "height", height);
            element.style.left = offset.left + "px";
            element.style.top = offset.top + "px";
            element.style.zIndex = 10000;
            component.offset = offset;
        }
    },

    _positionHeatMapOverlay: {
        value: function () {
            var map = this.map,
                component = this.component,
                width = map.getContainer().offsetWidth,
                height = map.getContainer().offsetHeight,
                pixelCenter = map.latLngToLayerPoint(map.getCenter()),
                offset = {
                    left: pixelCenter.x - width / 2,
                    top: pixelCenter.y - height / 2
                },
                element = component.element;

            element.setAttribute("width", width + "px");
            element.setAttribute("height", height + "px");
            element.style.left = offset.left + "px";
            element.style.top = offset.top + "px";
            element.style.zIndex = 10000;
            component.offset = offset;
        }
    },

    _resize: {
        value: function () {
            this.map.setView([this.position.center[1], this.position.center[0]]);
            this._setPositionAndBounds();
        }
    },

    _setPositionAndBounds: {

        value: function () {

            var mapBounds = this.map.getBounds(),
                zoom = this.map.getZoom(),
                center = this.map.getCenter();

            this._centerChanged = this._oldCenter !== center.lng;
            this.worldCount = Math.floor((center.lng + 180) / 360);

            if (this._centerChanged) {
                this.drawQueuedObjects();
            }
            this._oldCenter = center.lng;

            this.super(
                center.lat,
                center.lng,
                zoom,
                mapBounds.getSouthWest().lat,
                mapBounds.getSouthWest().lng,
                mapBounds.getNorthEast().lat,
                mapBounds.getNorthEast().lng
            );
        }
    },

    _worldCount: {
        value: 0
    },

    clearOverlayEvents: {
        value: function (component) {
            var context = this._eventContexts[component.uuid];
            if (context) {
                this.map.removeEventListener("move", this._positionFigureOverlay, context);
                this.map.removeEventListener("resize", this._positionFigureOverlay, context);
            }
        }
    },

    coordinateToPoint: {
        value: function (coordinate) {
            var point = this.map.latLngToLayerPoint([coordinate[1], coordinate[0]]);
            return {x: point.x, y: point.y};
        }
    },

    createBounds: {
        value: function (minPoint, maxPoint) {
            return L.latLngBounds(
                [minPoint[1], minPoint[0]],
                [maxPoint[1], maxPoint[0]]
            );
        }
    },

    draw: {
        value: function () {
            this.super();
            if (this.map && this._centerChanged) {

                var key, feature, symbol;

                for (key in this.overlayRegistry) {
                    var overlay = this.overlayRegistry[key],
                        component = overlay.component;
                    if (component.type === OverlayType["Feature"]) {

                        var layer = component.layer,
                            features = layer.features;
                        if (component.clustered) {

                            var clusterSymbols = component.clusterSymbols[this.uuid],
                                i, length = clusterSymbols.length;

                            for (i = 0; i <= length; i++) {
                                this._normalizeClusterCoordinates(clusterSymbols[i]);
                            }
                        } else {

                            for (key in features) {
                                feature = features[key];
                                symbol = component.symbols[this.uuid][feature.id];
                                if (symbol && this._featureRequiresNormalization(feature, symbol)) {
                                    this._normalizeFeatureCoordinates(feature, symbol);
                                }
                            }
                        }
                    }
                }
            }
        }
    },



    enterDocument: {

        value: function (firstTime) {

            if (firstTime) {
                this._mapLoaded = true;
            }
            this.needsDraw = true;
        }
    },

    exitDocument: {
        value: function () {
            this.super();

            for (var key in this.figureRegistry) {
                delete this.figureRegistry[key];
            }
            this.map.removeEventListener("moveend");
            this.map.removeEventListener("viewreset");
            this.map.remove();
            this.map = null;
        }
    },

    extendBounds: {
        value: function (bounds, pixelRadius) {

            var extendedNorthEastCoordinate,
                extendedSouthWestCoordinate;

            // Convert the points to pixels and the extend out by the grid size.
            topRightPixel = this.map.latLngToLayerPoint(bounds.getNorthEast());
            topRightPixel.x += pixelRadius;
            topRightPixel.y -= pixelRadius;

            bottomLeftPixel = this.map.latLngToLayerPoint(bounds.getSouthWest());
            bottomLeftPixel.x -= pixelRadius;
            bottomLeftPixel.y += pixelRadius;

            // Convert the pixel points back to LatLng
            extendedNorthEastCoordinate = this.map.layerPointToLatLng(topRightPixel);
            extendedSouthWestCoordinate = this.map.layerPointToLatLng(bottomLeftPixel);

            // Extend the bounds to contain the new bounds.
            bounds.extend(extendedNorthEastCoordinate);
            bounds.extend(extendedSouthWestCoordinate);

            return bounds;
        }
    },

    fitToBounds: {
        value: function (bounds) {
            this.map.fitBounds([[bounds[0][1], bounds[0][0]], [bounds[1][1], bounds[1][0]]]);
        }
    },

    getCenter: {
        value: function () {
            var center = this.map.getCenter();
            return [center.lng, center.lat];
        }
    },

    // Note: this has a callback because Google Maps has a more sophisticated method of determining the maximum zoom level
    // Which requires an asynchronous call.
    maxZoomLevelAtCoordinate: {
        value: function (coordinate, callback) {
            if (this.map.options.layers && this.map.options.layers.length > 0) {
                callback(this.map.options.layers[0].options.maxZoom);
            } else {
                callback(this.map.getZoom());
            }
        }
    },

    overlayPaneWithId: {
        value: function (paneId) {
            var pane;
            switch (paneId) {
                case "OverlayLayer":
                    pane = this.map.getPanes()["overlayPane"];
                    break;
                case "PopUp":
                    pane = this.map.getPanes()["popupPane"];
                    break;
                case "TileLayer":
                    pane = this.map.getPanes()["tilePane"];
                    break;
            }
            return pane;
        }
    },

    pointToCoordinate: {
        value: function (point) {
            var coordinate = this.map.layerPointToLatLng([point.x, point.y]);
            return [coordinate.lng, coordinate.lat];
        }
    },

    pointWithinBounds: {
        value: function (point, bounds) {
            var inBounds = false,
                latLngPoint = L.latLng(point[1], point[0]);

            if (bounds.getWest() > bounds.getEast()) {

                var westBounds = L.latLngBounds(
                        [bounds.getSouth(), bounds.getWest()],
                        [bounds.getNorth(), 180]
                    ),
                    eastBounds = L.latLngBounds(
                        [bounds.getSouth(), -180],
                        [bounds.getNorth(), bounds.getEast()]
                    );

                inBounds = westBounds.contains(latLngPoint) || eastBounds.contains(latLngPoint);
            } else {
                inBounds = bounds.contains(latLngPoint);
            }

            return inBounds;
        }
    },

    positionFigureOverlay: {
        value: function (component) {

            var context = {
                map: this.map,
                component: component
            };
            this._eventContexts[component.uuid] = context;
            this.appendElementToOverlayPaneWithId(component.element, "PopUp");
            if (component.isPersistent === false || (component.figure && component.figure.isNewObject)) {
                this.map.addEventListener("move", this._positionFigureOverlay, context);
                this.map.addEventListener("resize", this._positionFigureOverlay, context);
            }
            this._positionFigureOverlay.call(context);
        }
    },

    removeSymbol: {
        value: function (symbol) {
            this.map.removeLayer(symbol);
        }
    },

    setCenter: {
        value: function (coordinate) {
            this.map.setView([coordinate[1], coordinate[0]]);
        }
    },

    setCenterAndZoom: {
        value: function (coordinate, level) {
            if (this.map) {
                this.map.setView([coordinate[1], coordinate[0]], level);
            }
        }
    },

    setZoom: {
        value: function (level) {
            if (this.map) {
                this.map.setZoom(level);
            }
        }
    },

    tilePosition: {
        value: function (tile, tilePosition, origin, minX, minY) {
            var point = L.point(tilePosition.x, tile.y).multiplyBy(256).subtract(this._origin);
            return {
                left: point.x + 'px',
                top: point.y + 'px'
            };
        }
    },

    updateTileBounds: {
        value: function () {

            var zoom = this.map.getZoom(),
                bounds = this.map.getBounds(),
                pxBounds = new L.Bounds(
                    this.map.project(bounds.getNorthWest(), zoom),
                    this.map.project(bounds.getSouthEast(), zoom)
                ),
                tileRange = new L.Bounds(
                    pxBounds.min.divideBy(256).floor(),
                    pxBounds.max.divideBy(256).ceil()
                );

            this.tileBounds = {
                origin: this._origin,
                minX: tileRange.min.x,
                maxX: tileRange.max.x,
                minY: tileRange.min.y,
                maxY: tileRange.max.y,
                zoom: zoom
            };
        }
    },

    viewPortOffset: {
        value: function () {
            var width = this.map.getContainer().offsetWidth,
                height = this.map.getContainer().offsetHeight,
                pixelCenter = this.map.latLngToLayerPoint(this.map.getCenter());
                return {
                    left: pixelCenter.x - width / 2,
                    top: pixelCenter.y - height / 2
                };
        }
    },

    worldCount: {
        get: function () {
            return this._worldCount;
        },
        set: function (value) {
            if (this._worldCount !== value) {
                this._worldCount = value;
                var key, component;
                for (key in this.overlayRegistry) {
                    component = this.overlayRegistry[key].component;
                    if (component.type === OverlayType["Figure"]) {
                        component.engineShift = this._worldCount * (Math.pow(2, this.position.zoom) * 256);
                        component.figure.needsDraw = true;
                        component.needsDraw = true;
                    }
                }
            }
        }
    }

});
