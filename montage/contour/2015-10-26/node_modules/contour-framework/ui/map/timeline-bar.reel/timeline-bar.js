/**
 * @module ui/timeline-bar.reel
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    PressComposer = require("montage/composer/press-composer").PressComposer,
    AnimationStatus = require("logic/controller/animation-controller").AnimationStatus,
    moment = require("moment-timezone");

/**
 * @class TimelineBar
 * @extends Component
 */
exports.TimelineBar = Component.specialize(/** @lends TimelineBar# */ {

    constructor: {
        value: function TimelineBar() {
            this.super();
        }
    },

    _animationController: { value: null },

    _areSpeedControlsVisible: { value: false },

    _currentMoment: {
        value: null
    },

    __currentTime: {
        value: null
    },

    _currentTime: {
        get: function () {
            return this.__currentTime;
        },
        set: function (value) {
            this.__currentTime = value;
            this._currentMoment = moment.unix(value);
            this._currentTimeIndex = this._animationController.timestamps.indexOf(value);
            this.needsDraw = true;
        }
    },

    __currentTimeIndex: {
        value: 0
    },

    _currentTimeIndex: {
        get: function () {
            return this.__currentTimeIndex;
        },
        set: function (value) {
            if (value !== this.__currentTimeIndex) {
                this.__currentTimeIndex = value;
                this._currentTime = this._animationController.timestamps[this.__currentTimeIndex];
            }
        }
    },


    _dateConverter: {
        value: {
            convert: function(input) {
                return input ? input.format("H\\h") : "";
            }
        }
    },

    _handleTimesChange: {
        value: function (plus, minus, index) {
            var firstDay, lastDay, length, i, nextTime, currentSuperTime, nextDay;
            this._superTimes = [];
            if (this._times && this._times.length > 0) {
                firstDay = moment.unix(this._times[0].unix());
                //    nextTime = firstDay;
                //    while (nextTime.unix() < lastDay.unix()) {
                //        this._superTimes.push(nextTime);
                //        nextTime = new moment(nextTime.utc());
                //        nextTime.add(1, 'd');
                //    }
                //}

                //var length, i, nextTime, currentSuperTime, nextDay;
                firstDay.hour(0);
                firstDay.minute(0);
                firstDay.second(0);
                firstDay.millisecond(0);
                nextDay = moment.unix(firstDay.unix());
                for (i = 0, length = this._times.length; i < length; i++) {
                    nextTime = this._times[i];
                    if (nextTime.unix() < nextDay.unix()) {
                        currentSuperTime.subTimes.push(nextTime);
                    } else {
                        currentSuperTime = {
                            moment: nextDay,
                            subTimes: [nextTime]
                        };
                        this._superTimes.push(currentSuperTime);
                        nextDay = new moment.unix(nextDay.unix());
                        nextDay.add(1, 'd');
                    }
                }
            }
            this._currentTimeIndex = this._animationController.timestamps.indexOf(this._currentTime);
            this.needsDraw = true;
        }
    },

    _superDateConverter: {
        value: {
            convert: function(input) {
                return input ? input.format("M.DD.YYYY") : "";
            }
        }
    },

    _timesChangeListener: { value: null },

    _timelineItemWidth: { value: null },

    _preparedForAction: { value: false },

    _pressComposer: { value: null },

    _times: { value: null },

    _superTimelineElement: { value: null},

    _superTimes: { value: null },

    _timelineElement: { value: null },

    _toggleAnimation: {
        value: function () {
            switch (this._animationController.status) {
                case AnimationStatus["Stopped"]:
                    this._animationController.startAnimation();
                    break;
                case AnimationStatus["Paused"]:
                    this._animationController.playAnimation();
                    break;
                case AnimationStatus["Playing"]:
                    this._animationController.pauseAnimation();
                    break;
            }
        }
    },

    animationController: {
        get: function () {
            return this._animationController;
        },
        set: function(value) {
            if (this._animationController) {
                this.cancelBinding("_times");
                this._timesChangeListener();
            }
            this._animationController = value;
            if (this._animationController) {
                this.defineBinding("_times", {"<-": "_animationController.availableTimes"});
                this.defineBinding("_currentTime", {"<->": "_animationController.currentTime"});
                this._timesChangeListener = this.addRangeAtPathChangeListener("_times", this, "_handleTimesChange");
            }
        }
    },

    draw: {
        value: function () {
            var superTimeElements = this._superTimelineElement.querySelectorAll(".contour-TimelineBar-superTimelineItem"),
                element, length, i;
            for (i = 0, length = superTimeElements.length; i < length; i++) {
                element = superTimeElements[i];
                element.style.flex = element.component.flex + "";
            }

            this._bufferSliderFill.style.width = (this._timelineItemWidth * (this._bufferSlider.value+1)) + "px";
        }
    },

    enterDocument: {
        value: function (firstTime) {
            this.prepareForActivationEvents();
        }
    },

    exitDocument: {
        value: function () {
            if (this._preparedForAction) {
                this._preparedForAction = false;
                this._pressComposer.removeEventListener("press", this);
                this._showSpeedControls.removeEventListener("action", this, false);
                this._control.removeEventListener("action", this, false);
            }

        }
    },

    handleControlAction: {
        value: function (e) {
            e.stopPropagation();
            this._toggleAnimation();
        }
    },

    handleShowSpeedControlsAction: {
        value: function (e) {
            e.stopPropagation();
            this._areSpeedControlsVisible = true;
        }
    },

    handlePress: {
        value: function (e) {
            var identifer =  e.targetElement.component && e.targetElement.component.identifier;
            if (identifer === "speedControl" && !this._areSpeedControlsVisible) {
                e.stopPropagation();
                this._areSpeedControlsVisible = true;
            } else if (identifer === "speedControl" && this._areSpeedControlsVisible) {
                e.stopPropagation();
                this._animationController.speed = e.targetElement.component.speed;
                this._areSpeedControlsVisible = false;
            }

        }
    },

    prepareForActivationEvents: {
        value: function () {
            if (!this._preparedForAction) {
                this._preparedForAction = true;
                if (!this._pressComposer) {
                    this._pressComposer = new PressComposer();
                    this._speedControls.addComposer(this._pressComposer);
                }
                this._pressComposer.addEventListener("press", this, false);
                this._showSpeedControls.addEventListener("action", this, false);
                this._control.addEventListener("action", this, false);
            }
        }
    },

    willDraw: {
        value: function () {
            this._timelineItemWidth = this._timelineElement.offsetWidth / this._times.length;
        }
    }

});
