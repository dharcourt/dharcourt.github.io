/**
 * @module ui/mgrs-overlay.reel
 * @requires montage/ui/component
 */
var OverlayComponent = require("ui/map/overlay-component").OverlayComponent,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    LATITUDE_BANDS = "CDEFGHJKLMNPQRSTUVWX",
    INVALID_LETTER_DESIGNATOR = 'Z',
    POLAR_Y_BBOX = [-180, 84, 0, 90],
    POLAR_Z_BBOX = [0, 84, 180, 90],
    POLAR_A_BBOX = [-180, -90, 0, -80],
    POLAR_B_BBOX = [0, -90, 180, -80],
    MAX_MERCATOR_VALUE = 20037508.342789244,
    UTM_FONT_STYLE = "italic bold 24px Arial",
    UTM_FILL_STYLE = "rgb(0,255,0)",
    MGRS_FONT_STYLE = "12px Arial",
    MGRS_LOW_FONT_STYLE = "9px Arial",
    MGRS_FILL_STYLE = "rgb(127,255,0)";

/**
 * @class MgrsOverlay
 * @extends Component
 */
var MGRSOverlay = exports.MgrsOverlay = OverlayComponent.specialize(/** @lends MgrsOverlay# */ {
    constructor: {
        value: function MgrsOverlay() {
            this.super();
        }
    },

    _addText: {
        value: function (text, point, fontStyle, fillStyle, textAlign, offsetX, offsetY) {
            var projectedPoint = this.engine.coordinateToPoint([point.x, point.y]);
            projectedPoint.x = projectedPoint.x - this.offset[0];
            projectedPoint.y = projectedPoint.y - this.offset[1];
            this._ctx.save();
            this._ctx.fillStyle = fillStyle;
            this._ctx.font = fontStyle;
            this._ctx.textAlign = textAlign;
            this._ctx.fillText(text, projectedPoint.x + (offsetX || 0), projectedPoint.y + (offsetY || 0));
            this._ctx.restore();
        }
    },

    _bboxContainsLongitude: {
        value: function (bbox, longitude) {
            return bbox[0] <= longitude && bbox[2] >= longitude;
        }
    },

    _bboxContainsBounds: {
        value: function (bbox) {
            var doesContain = false;
            if (this.bounds.west > this.bounds.east) {
                doesContain = (this._bboxContainsLongitude(bbox, this.bounds.west) || this._bboxContainsLongitude(bbox, 180)) ||
                    (this._bboxContainsLongitude(bbox, -180) || this._bboxContainsLongitude(bbox, this.bounds.east));
            } else {
                doesContain = this._bboxContainsLongitude(bbox, this.bounds.west) || this._bboxContainsLongitude(bbox, this.bounds.east);
            }
            return doesContain;
        }
    },

    _bounds: {
        value: null
    },

    _centroidOfPolygon: {
        value: function (polygon) {
            var centroidAndArea = MGRS.Utils.getCentroidAndAreaPolygon(polygon),
                converterPoint = new MGRS.Point();
            converterPoint.x = centroidAndArea.centroid.x;
            converterPoint.y = centroidAndArea.centroid.y;
            MGRS.ProjectedCS.WEB_MERCATOR.toGeographic(converterPoint);
            centroidAndArea.centroid.x = converterPoint.x;
            centroidAndArea.centroid.y = converterPoint.y;
            return centroidAndArea.centroid;
        }
    },

    __ctx: {
        value: null
    },

    _ctx: {
        writeable: false,
        get: function () {
            if (this.__ctx === null) {
                this.__ctx = this.element.getContext("2d");
            }
            return this.__ctx;
        }
    },

    _drawLines: {
        value: function (points) {
            var bufferPoint = new MGRS.Point(),
                pixelPoint,
                i, length;
            this._ctx.save();
            this._ctx.strokeStyle = "rgba(127, 255, 0, .3)";
            this._ctx.beginPath();
            for(i = 0, length = points.length; i < length; i++) {
                bufferPoint.copyFrom(points[i]);
                MGRS.ProjectedCS.WEB_MERCATOR.toGeographic(bufferPoint);
                pixelPoint = this.engine.coordinateToPoint([bufferPoint.x, bufferPoint.y]);
                if (i === 0) {
                    this._moveTo(pixelPoint);
                } else {
                    this._lineTo(pixelPoint);
                }
            }
            this._ctx.closePath();
            this._ctx.stroke();
            this._ctx.restore();
        }
    },

    _drawRing: {
        value: function (ring) {
            var bufferPoint = new MGRS.Point(),
                pixelPoint,
                i, length;

            this._ctx.save();
            this._ctx.strokeStyle = "rgba(127, 255, 0, .3)";
            this._ctx.beginPath();
            for(i = 0, length = ring.length; i < length; i++) {
                bufferPoint.setTo(ring[i].x, ring[i].y);
                MGRS.ProjectedCS.WEB_MERCATOR.toGeographic(bufferPoint);
                pixelPoint = this.engine.coordinateToPoint([bufferPoint.x, bufferPoint.y]);
                if (i === 0) {
                    this._moveTo(pixelPoint);
                } else {
                    this._lineTo(pixelPoint);
                }
            }
            this._ctx.closePath();
            this._ctx.stroke();
            this._ctx.restore();

        }
    },

    _drawUTM: {
        value: function (polyline) {

            var i, length, point;

            this._ctx.save();
            this._ctx.strokeStyle = "rgb(255, 255, 0)";
            this._ctx.beginPath();

            for (i = 0, length = polyline.paths.length; i < length; i++) {
                point = this.engine.coordinateToPoint([
                    polyline.paths[i].x, polyline.paths[i].y
                ]);
                if (i === 0) {
                    this._moveTo(point);
                } else {
                    this._lineTo(point);
                }
            }
            this._ctx.closePath();
            this._ctx.stroke();
            this._ctx.restore();
        }
    },

    _disableOverlay: {
        value: function () {

        }
    },

    _enableOverlay: {
        value: function () {

        }
    },

    _engine: {
        value: null
    },

    _isEnabled: {
        value: false
    },

    _lineTo: {
        value: function (point) {
            this._ctx.lineTo(point.x - this.offset[0], point.y - this.offset[1]);
        }
    },

    _moveTo: {
        value: function (point) {
            this._ctx.moveTo(point.x - this.offset[0], point.y - this.offset[1]);
        }
    },

    _pointTransformer: {
        value: null
    },

    _type: {
        value: OverlayType["Mgrs"]
    },

    bounds: {
        get: function () {
            return this._bounds;
        },
        set: function (value) {
            if (value && this._bounds !== value) {
                this._bounds = value;
                if (this.isEnabled) {
                    this.needsDraw = true;
                }
            }
        }
    },

    currentZoom: {
        value: 0
    },

    draw: {
        value: function () {

            if (this.bounds) {
                var extent = new MGRS.Extent(
                        this.bounds.west,
                        this.bounds.south,
                        this.bounds.east,
                        this.bounds.north),
                    min = new MGRS.Point(this.bounds.west, this.bounds.south),
                    max = new MGRS.Point(this.bounds.east, this.bounds.north),
                    mercatorProjection = MGRS.ProjectionsFactory.WEB_MERCATOR,
                    converterPoint = new MGRS.Point(),
                    extWidth_by15, extWidth_by20,
                    extentWidthInMeters, mapWidth,
                    accuracy, gridSize, namedPolygons = [],
                    i, length, j, jLength,
                    minPoint, maxPoint, points;

                this._ctx.clearRect(0, 0, this.element.width, this.element.height);
                minPoint = this.engine.coordinateToPoint([this.bounds.west, this.bounds.south]);
                maxPoint = this.engine.coordinateToPoint([this.bounds.east, this.bounds.north]);
                this.offset = [minPoint.x, maxPoint.y];
                this.element.style.left = this.offset[0] + "px";
                this.element.style.top = this.offset[1] + "px";
                this.element.width = mapWidth = Math.abs(maxPoint.x - minPoint.x);
                this.element.height = Math.abs(maxPoint.y - minPoint.y);
                this.pointTransformer.prepareForDraw();
                mercatorProjection.fromGeographic(min);
                mercatorProjection.fromGeographic(max);

                if (max.x > min.x) {
                    extentWidthInMeters = max.x - min.x;
                } else {
                    extentWidthInMeters = (MAX_MERCATOR_VALUE - Math.abs(max.x)) + (MAX_MERCATOR_VALUE - Math.abs(min.x));
                }
                accuracy = mapWidth / extentWidthInMeters;
                if (this.currentZoom > 5) {

                    if (this.currentZoom > 17) {
                        gridSize = 10;
                    } else if (this.currentZoom > 14) {
                        gridSize = 100;
                    } else if (this.currentZoom > 11) {
                        gridSize = 1000;
                    } else {
                        gridSize = 10000;
                    }

                    for (i = 0, length = this.mgrsZones.length; i < length; i++) {
                        this.mgrsZones[i].generateMgrsGrids2(namedPolygons, accuracy / 4, extent, this.currentZoom > 8, gridSize);
                    }

                    extWidth_by15 = 15 * extentWidthInMeters / mapWidth;
                    extWidth_by20 = 20 * extentWidthInMeters / mapWidth;

                    if (gridSize && this.currentZoom > 8) {
                        for (i = 0, length = namedPolygons.length; i < length; i++) {
                            var namedPolygon = namedPolygons[i],
                            coordinateTransformation = new MGRS.CoordinateTransformation(namedPolygon.zone.utmZone.projectedSpatialReference,
                                MGRS.ProjectedCS.WEB_MERCATOR);
                            this.pointTransformer.init(1 / accuracy, coordinateTransformation);
                            if (namedPolygon.zone.polylineY !== null) {
                                for (j = 0, jLength = namedPolygon.zone.polylineY.paths.length; j < jLength; j++) {
                                    points = this.pointTransformer.warp(namedPolygon.zone.polylineY.paths[j]);
                                    if (points !== null && points.length > 1) {
                                        this._drawLines(points);
                                        converterPoint.copyFrom(points[0]);
                                        MGRS.ProjectedCS.WEB_MERCATOR.toGeographic(converterPoint);
                                        this._addText((Math.round(namedPolygon.zone.polylineY.paths[j][0].y) % 100000).toString(), converterPoint, MGRS_LOW_FONT_STYLE, MGRS_FILL_STYLE, "start", 2, -8);
                                    }
                                }
                            }
                            if (namedPolygon.zone.polylineX !== null) {
                                for (j = 0, jLength = namedPolygon.zone.polylineX.paths.length; j < jLength; j++) {
                                    points = this.pointTransformer.warp(namedPolygon.zone.polylineX.paths[j]);
                                    if (points !== null && points.length > 1) {
                                        this._drawLines(points);
                                    }
                                }
                            }
                        }
                    }

                    for (i = 0, length = namedPolygons.length; i < length; i++) {
                        namedPolygon = namedPolygons[i];
                        coordinateTransformation = new MGRS.CoordinateTransformation(namedPolygon.zone.utmZone.projectedSpatialReference,
                            MGRS.ProjectedCS.WEB_MERCATOR);
                        this.pointTransformer.init(0.2 / accuracy, coordinateTransformation);
                        for (j = 0, jLength = namedPolygon.polygon.rings.length; j < jLength; j++) {
                            var rings = namedPolygon.polygon.rings[j];
                            if (rings.length > 0) {
                                points = this.pointTransformer.warp(rings);
                                if (points !== null && points.length > 2) {
                                    var polygon = new MGRS.Polygon([points]);
                                    if (polygon !== null) {
                                        var self = this;
                                        polygon.rings.forEach(function (path) {
                                            self._drawLines(path);
                                        });
                                        if (polygon.extent.width > extWidth_by20 && polygon.extent.height > extWidth_by15) {
                                            this._addText(namedPolygon.name, this._centroidOfPolygon(polygon), MGRS_FONT_STYLE, MGRS_FILL_STYLE, "center");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                for (i = 0, length = this.mgrsZones.length; i < length; i++) {
                    var zone = this.mgrsZones[i];
                    if (zone.latLonExtent !== undefined) {
                        var polygon = MGRS.Utils.convertExtentToPolygon(zone.latLonExtent);
                        for (j = 0, jLength = polygon.rings.length; j < jLength; j++) {
                            var ring = polygon.rings[j];
                            if (ring.length > 2) {
                                this._drawUTM(new MGRS.Polyline(ring));
                            }
                        }
                        if (this.currentZoom > 3) {
                            var zoneName = zone.utmZone.isPolar ? zone.utmZone.name : zone.name();
                            this._addText(zoneName, zone.center(), UTM_FONT_STYLE, UTM_FILL_STYLE, "center", 0, 3);
                        }

                    }
                }
            }
        }
    },

    engine: {
        get: function () {
            return this._engine;
        },
        set: function (value) {
            if (value && this._engine !== value) {
                if (this.isEnabled && this._engine) {
                    this._engine.removeOverlayComponent(this);
                }
                this._engine = value;
                if (this.isEnabled) {
                    this._engine.addOverlayComponent(this);
                }
            }
        }
    },

    hasTemplate: {
        value: true
    },

    isEnabled: {
        get: function () {
            return this._isEnabled;
        },
        set: function (value) {
            if (value !== this._isEnabled) {
                this._isEnabled = value;
                if (this._isEnabled === true && this.engine) {
                    this.engine.addOverlayComponent(this);
                } else if (this._isEnabled === false && this.engine) {
                    this.engine.removeOverlayComponent(this);
                }
            }
        }
    },

    mgrsZones: {
        value: []
    },

    offset: {
        value: []
    },

    pointTransformer: {
        get: function () {
            if (this._pointTransformer === null) {
                this._pointTransformer = new MGRS.PointTransformer();
            }
            return this._pointTransformer;
        },
        set: function (value) {
            this._pointTransformer = value;
        }
    },

    position: {
        value: null
    },

    type: {
        get: function () {
            return this._type;
        }
    },

    willDraw: {
        value: function () {

            if (this.bounds) {

                this.mgrsZones = [];

                var utmZone,
                    maximumLongitude, minimumLongitude,
                    maximumLatitude, minimumLatitude,
                    standardBounds = [[this.bounds.west, this.bounds.south], [this.bounds.east, this.bounds.north]],
                    numbers = MGRSOverlay.zoneNumbersForBounds(standardBounds),
                    letters = MGRSOverlay.zoneLettersForBounds(standardBounds),
                    indexOfN = LATITUDE_BANDS.indexOf("N"),
                    number, letter,
                    i, length, j, jLength;

                for (i = 0, length = numbers.length; i < length; i++) {
                    number = numbers[i];
                    maximumLongitude = number * 6 - 180;
                    minimumLongitude = maximumLongitude - 6;
                    for (j = 0, jLength = letters.length; j < jLength; j++) {
                        letter = letters[j];
                        minimumLatitude = LATITUDE_BANDS.indexOf(letter) * 8 - 80;
                        maximumLatitude = minimumLatitude + 8;
                        var isNorth = LATITUDE_BANDS.indexOf(letter) >= indexOfN,
                            zoneIdentifier = number + (isNorth ? "N" : "S");
                        if (this.utmZones[zoneIdentifier] === undefined) {
                            this.utmZones[zoneIdentifier] = MGRS.UtmZone.createNormalUtmZone(number, isNorth);
                        }
                        utmZone = this.utmZones[zoneIdentifier];

                        var zoneMinLongitude,
                            zoneMaxLongitude,
                            zoneMaxLatitude = maximumLatitude;

                        switch (letter) {
                            case 'X':
                                if ([32, 34, 36].indexOf(number) > -1) {
                                    continue;
                                }
                                if (number === 31) {
                                    zoneMinLongitude = 0;
                                    zoneMaxLongitude = 9;
                                } else if (number === 33) {
                                    zoneMinLongitude = 9;
                                    zoneMaxLongitude = 21;
                                } else if (number === 35) {
                                    zoneMinLongitude = 21;
                                    zoneMaxLongitude = 33;
                                } else if (number === 37) {
                                    zoneMinLongitude = 33;
                                    zoneMaxLongitude = 42;
                                } else {
                                    zoneMinLongitude = minimumLongitude;
                                    zoneMaxLongitude = maximumLongitude;
                                }

                                zoneMaxLatitude = minimumLatitude + 12;
                                break;
                            case 'V':
                                if (number === 31) {
                                    zoneMinLongitude = 0;
                                    zoneMaxLongitude = 3;
                                } else if (number === 32) {
                                    zoneMinLongitude = 3;
                                    zoneMaxLongitude = 12;
                                } else {
                                    zoneMinLongitude = minimumLongitude;
                                    zoneMaxLongitude = maximumLongitude;
                                }
                                break;
                            default:
                                zoneMinLongitude = minimumLongitude;
                                zoneMaxLongitude = maximumLongitude;
                                break;
                        }
                        this.mgrsZones.push(MGRS.MgrsZone.createMgrsZone2(utmZone, zoneMinLongitude, zoneMaxLongitude, minimumLatitude, zoneMaxLatitude));
                    }
                }

                if (this.bounds.north > 84) {
                    if (this._bboxContainsBounds(POLAR_Y_BBOX)) {
                        if (this.utmZones["Y"] === undefined) {
                            this.utmZones["Y"] = MGRS.UtmZone.createPolarUtmZone(true, true);
                        }
                        utmZone = this.utmZones["Y"];
                        this.mgrsZones.push(MGRS.MgrsZone.createMgrsZone2(utmZone, -180, 0, 84, 90));
                    }
                    if (this._bboxContainsBounds(POLAR_Z_BBOX)) {
                        if (this.utmZones["Z"] === undefined) {
                            this.utmZones["Z"] = MGRS.UtmZone.createPolarUtmZone(true, false);
                        }
                        utmZone = this.utmZones["Z"];
                        this.mgrsZones.push(MGRS.MgrsZone.createMgrsZone2(utmZone, 0, 180, 84, 90));
                    }
                }
                if (this.bounds.south < -80) {
                    if (this._bboxContainsBounds(POLAR_A_BBOX)) {
                        if (this.utmZones["A"] === undefined) {
                            this.utmZones["A"] = MGRS.UtmZone.createPolarUtmZone(false, true);
                        }
                        utmZone = this.utmZones["A"];
                        this.mgrsZones.push(MGRS.MgrsZone.createMgrsZone2(utmZone, -180, 0, -90, -80));
                    }
                    if (this._bboxContainsBounds(POLAR_B_BBOX)) {
                        if (this.utmZones["B"] === undefined) {
                            this.utmZones["B"] = MGRS.UtmZone.createPolarUtmZone(false, false);
                        }
                        utmZone = this.utmZones["B"];
                        this.mgrsZones.push(MGRS.MgrsZone.createMgrsZone2(utmZone, 0, 180, -90, -80));
                    }
                }
            }
        }
    },

    utmZones: {
        value: {}
    }

}, {

    /**
     * Calculates the MGRS letter designator for the given latitude.
     *
     * @private
     * @param {number} lat The latitude in WGS84 to get the letter designator
     *     for.
     * @return {char} The letter designator.
     */
    letterDesignatorForLatitude: {
        value: function (lat) {
            //This here as an error flag to show that the Latitude is
            //outside MGRS limits
            var letterDesignator = INVALID_LETTER_DESIGNATOR;
            if ((84 >= lat) && (lat >= 72)) {
                letterDesignator = 'X';
            } else if ((72 > lat) && (lat >= 64)) {
                letterDesignator = 'W';
            } else if ((64 > lat) && (lat >= 56)) {
                letterDesignator = 'V';
            } else if ((56 > lat) && (lat >= 48)) {
                letterDesignator = 'U';
            } else if ((48 > lat) && (lat >= 40)) {
                letterDesignator = 'T';
            } else if ((40 > lat) && (lat >= 32)) {
                letterDesignator = 'S';
            } else if ((32 > lat) && (lat >= 24)) {
                letterDesignator = 'R';
            } else if ((24 > lat) && (lat >= 16)) {
                letterDesignator = 'Q';
            } else if ((16 > lat) && (lat >= 8)) {
                letterDesignator = 'P';
            } else if ((8 > lat) && (lat >= 0)) {
                letterDesignator = 'N';
            } else if ((0 > lat) && (lat >= -8)) {
                letterDesignator = 'M';
            } else if ((-8 > lat) && (lat >= -16)) {
                letterDesignator = 'L';
            } else if ((-16 > lat) && (lat >= -24)) {
                letterDesignator = 'K';
            } else if ((-24 > lat) && (lat >= -32)) {
                letterDesignator = 'J';
            } else if ((-32 > lat) && (lat >= -40)) {
                letterDesignator = 'H';
            } else if ((-40 > lat) && (lat >= -48)) {
                letterDesignator = 'G';
            } else if ((-48 > lat) && (lat >= -56)) {
                letterDesignator = 'F';
            } else if ((-56 > lat) && (lat >= -64)) {
                letterDesignator = 'E';
            } else if ((-64 > lat) && (lat >= -72)) {
                letterDesignator = 'D';
            } else if ((-72 > lat) && (lat >= -80)) {
                letterDesignator = 'C';
            }

            return letterDesignator;
        }
    },

    letterDesignatorForLatitudeWithDefault: {
        value: function (latitude, defaultLetter) {
            var letter = MGRSOverlay.letterDesignatorForLatitude(latitude);
            if (letter === INVALID_LETTER_DESIGNATOR) {
                letter = defaultLetter;
            }
            return letter;
        }
    },

    zoneLettersForBounds: {
        value: function (bounds) {
            var letters = [],
                min = MGRSOverlay.letterDesignatorForLatitudeWithDefault(bounds[0][1], 'C'),
                max = MGRSOverlay.letterDesignatorForLatitudeWithDefault(bounds[1][1], 'X'),
                latitudeBandsArray = LATITUDE_BANDS.split(""),
                c, stop;

            for (c = LATITUDE_BANDS.indexOf(min), stop = LATITUDE_BANDS.indexOf(max); c <= stop; c++) {
                letters.push(latitudeBandsArray[c]);
            }
            return letters;
        }
    },

    zoneNumbersForBounds: {
        value: function (bounds) {
            var zoneNumbers = [],
                minZoneNumber = MGRSOverlay.zoneNumberForLongitude(bounds[0][0]),
                maxZoneNumber = MGRSOverlay.zoneNumberForLongitude(bounds[1][0]),
                i;

            if (minZoneNumber <= maxZoneNumber) {
                for (i = minZoneNumber; i <= maxZoneNumber; i++) {
                    zoneNumbers.push(i);
                }
            } else {
                for (i = minZoneNumber; i <= 60; i++) {
                    zoneNumbers.push(i);
                }
                for (i = 1; i <= maxZoneNumber; i++) {
                    zoneNumbers.push(i);
                }
            }
            return zoneNumbers;
        }
    },

    zoneNumberForLongitude: {
        value: function (longitude) {
            return Math.floor((longitude + 180) / 6) + 1
        }
    }

});

//--------------------------  Supporting Functions // One day refactor? JLM  ----------------------- //

var MGRS = {};
MGRS.ONE_HUNDRED_K = 100000;
MGRS.HALF_PI = Math.PI / 2;
MGRS.QUARTER_PI = Math.PI / 4;

MGRS.Utils = {

    OUT_LEFT: 1,
    OUT_TOP: 2,
    OUT_RIGHT: 4,
    OUT_BOTTOM: 8,

    // was calcExtent
    calculateExtentFromPath: function (points, retExtent) {

        var xmin, ymin, xmax, ymax,
            i, length, point;

        if (retExtent) {
            xmin = retExtent.xmin;
            ymin = retExtent.ymin;
            xmax = retExtent.xmax;
            ymax = retExtent.ymax;
        } else {
            xmin = Number.MAX_VALUE;
            ymin = Number.MAX_VALUE;
            xmax = -Number.MAX_VALUE;
            ymax = -Number.MAX_VALUE;
        }

        for (i = 0, length = points.length; i < length; i++) {
            point = points[i];
            if (xmin > point.x) xmin = point.x;
            if (xmax < point.x) xmax = point.x;
            if (ymin > point.y) ymin = point.y;
            if (ymax < point.y) ymax = point.y;
        }

         //Does this block even make sense?
        if (retExtent) {
            retExtent.xmin = xmin;
            retExtent.ymin = ymin;
            retExtent.xmax = xmax;
            retExtent.ymax = ymax;
            return retExtent;
        }

        return new MGRS.Extent(xmin, ymin, xmax, ymax);
    },

    calculatePolygonExtent: function (polygon) {
        var extent = new MGRS.Extent(Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),
            i, length;
        for (i = 0, length = polygon.rings.length; i < length; i++) {
            MGRS.Utils.calculateExtentFromPath(polygon.rings[i], extent);
        }
        return extent;
    },

    ceil: function (number, interval) {

        var absolueValue = Math.abs(number),
            remainder = absolueValue % interval,
            answer;

        if (remainder === 0) {
            answer = number;
        } else if (number < 0) {
            answer = number + remainder;
        } else {
            answer = number - remainder + interval;
        }
        return answer;
    },

    clipPathByExtent: function (path, extent, paths) {

        var pathExtent = this.calculateExtentFromPath(path, null);
        if (MGRS.Utils.extentDisjointExtentRelative(pathExtent, extent)) {
            return;
        }
        if (MGRS.Utils.extentContainExtentRelative(extent, pathExtent)) {
            paths.push(MGRS.Utils.clonePoints(path));
        } else {

            var length = path.length - 1,
                outCode = MGRS.Utils.extentOutcode(extent, path[0]),
                startIndex = -1,
                startPointBuffer = new MGRS.Point(),
                endPointBuffer = new MGRS.Point(),
                currentIndex = 0,
                nextIndex = 1,
                previousOutcode, startPoint, endPoint, currentPoint, nextPoint, tmpPath;

            if (outCode == 0) {
                startIndex = 0;
            }

            while (currentIndex < length) {
                currentPoint = path[currentIndex];
                nextPoint = path[nextIndex];
                previousOutcode = outCode;
                outCode = MGRS.Utils.extentOutcode(extent, nextPoint);
                if ((outCode & previousOutcode) == 0) {
                    if (outCode == 0) {
                        if (startIndex == -1) {
                            startIndex = nextIndex;
                        }
                        if (previousOutcode != 0) {
                            if (MGRS.Utils.extentClipLine(extent, nextPoint, currentPoint, previousOutcode, startPointBuffer)) {
                                startPoint = startPointBuffer;
                            }
                        }
                    } else if (previousOutcode == 0) {
                        if (MGRS.Utils.extentClipLine(extent, currentPoint, nextPoint, outCode, endPointBuffer)) {
                            endPoint = endPointBuffer;
                        }
                        tmpPath = MGRS.Utils.makePath(startPoint, startIndex, currentIndex, endPoint, path);
                        if (tmpPath != null) {
                            paths.push(tmpPath);
                        }
                        startPoint = null;
                        endPoint = null;
                        startIndex = -1;
                    } else if (MGRS.Utils.extentClipLine(extent, currentPoint, nextPoint, outCode, endPointBuffer)) {
                        if (MGRS.Utils.extentClipLine(extent, nextPoint, currentPoint, previousOutcode, startPointBuffer)) {
                            paths.push([startPointBuffer.clone(), endPointBuffer.clone()]);
                        }
                    }
                }
                currentIndex++;
                nextIndex++;
            }
            if (startIndex != -1) {
                tmpPath = MGRS.Utils.makePath(startPoint, startIndex, (path.length - 1), endPoint, path);
                if (tmpPath != null) {
                    paths.push(tmpPath);
                }
            }
        }
    },
    // was MGRS.RingCollection.clipRingByExtent
    clipRingByExtent: function (extent, ring, mRings) {

        var relExtent = MGRS.Utils.calculateExtentFromPath(ring);
        if (MGRS.Utils.extentDisjointExtentRelative(extent, relExtent)) {
            return;
        }

        var len = mRings.length;

        if (MGRS.Utils.extentContainExtentRelative(extent, relExtent)) {
            mRings.push(MGRS.Utils.clonePoints(ring));
            return;
        }

        var _reverse = false;
        if (MGRS.Utils.getAreaPoints(ring) > 0) {
            ring.reverse();
            _reverse = true;
        }

        var rLen = ring.length - 1,
            outcode = MGRS.Utils.extentOutcode(extent, ring[0]),
            tmpOutcode = outcode,
            startIndex = -1,
            endIndex = 0,
            startPoint = new MGRS.Point(),
            endPoint = new MGRS.Point(),
            extOutcode,
            clipLineIndex,
            closedLen;

        if (outcode === 0) {
            startIndex = 0;
            extOutcode = outcode;
            clipLineIndex = 0;
            if (MGRS.Utils.isPathClosed(ring)) {
                closedLen = ring.length - 2;
            } else {
                closedLen = ring.length -1;
            }
            while (closedLen > 0) {
                outcode = extOutcode;
                extOutcode = MGRS.Utils.extentOutcode(extent, ring[closedLen]);
                if (extOutcode != 0) {
                    if (MGRS.Utils.extentClipLine(extent, ring[closedLen], ring[clipLineIndex], extOutcode, startPoint)) {
                        startIndex = clipLineIndex;
                        rLen = closedLen;
                        break;
                    }
                }
                clipLineIndex = closedLen;
                closedLen--;
            }
            if (clipLineIndex === 1) {
                mRings.push(ring);
                return;
            }
            outcode = tmpOutcode;
        }
        var ringCollection = new MGRS.RingCollection(ring, mRings, extent);
        clipLineIndex = 1;
        while (endIndex < rLen) {
            extOutcode = outcode;
            outcode = MGRS.Utils.extentOutcode(extent, ring[clipLineIndex]);
            if ((outcode & extOutcode) == 0) {
                if (outcode == 0) {
                    if (startIndex == -1) {
                        startIndex = clipLineIndex;
                    }
                    if (extOutcode !== 0) {
                        MGRS.Utils.extentClipLine(extent, ring[clipLineIndex], ring[endIndex], extOutcode, startPoint);
                    }
                } else if (extOutcode === 0) {
                    MGRS.Utils.extentClipLine(extent, ring[endIndex], ring[clipLineIndex], outcode, endPoint);
                    ringCollection.addStartEndRange(startPoint, startIndex, endIndex, endPoint);
                    startIndex = -1;
                } else if (MGRS.Utils.extentClipLine(extent, ring[endIndex], ring[clipLineIndex], outcode, endPoint)) {
                    if (MGRS.Utils.extentClipLine(extent, ring[clipLineIndex], ring[endIndex], extOutcode, startPoint)) {
                        ringCollection.addStartEnd(startPoint, endPoint);
                    }
                }
            }
            endIndex++;
            clipLineIndex++;
        }
        if (startIndex != -1) {
            if (tmpOutcode != 0) {
                MGRS.Utils.extentClipLine(extent, ring[0], ring[ring.length - 1], tmpOutcode, endPoint);
                ringCollection.addStartEndRange(startPoint, startIndex, (ring.length - 1), endPoint);
            }
        }
        ringCollection.generate(_reverse);
        ringCollection.dispose();
        ringCollection = null;

        if (mRings.length === len) {
            if (MGRS.Utils.relatePointsPoint(ring, extent.xmin + .5 * extent.width, extent.ymin + .5 * extent.height)) {
                mRings.push([
                    new MGRS.Point(extent.xmin, extent.ymin),
                    new MGRS.Point(extent.xmin, extent.ymax),
                    new MGRS.Point(extent.xmax, extent.ymax),
                    new MGRS.Point(extent.xmax, extent.ymin)
                ]);
            }
        }
    },

    clonePoints: function(points) {
        var clonedPoints = [],
            i, length;
        for (i = 0, length = points.length; i < length; i++) {
            clonedPoints.push(points[i].clone());
        }
        return clonedPoints;
    },

    convertExtentToPolygon: function (extent) {
        return new MGRS.Polygon([
            [
                new MGRS.Point(extent.xmin, extent.ymin),
                new MGRS.Point(extent.xmin, extent.ymax),
                new MGRS.Point(extent.xmax, extent.ymax),
                new MGRS.Point(extent.xmax, extent.ymin)
            ]
        ]);
    },

    extentClipExtent: function (extent1, extent2) {

        var xmin, xmax, ymin, ymax;

        if (extent2.xmax > extent2.xmin) {
            xmin = Math.max(extent1.xmin, extent2.xmin);
            xmax = Math.min(extent1.xmax, extent2.xmax);
        } else {
            if (extent1.xmin >= 0) {
                xmin = Math.max(extent1.xmin, extent2.xmin);
                xmax = Math.max(extent1.xmax, extent2.xmin);
            } else {
                xmin = Math.min(extent1.xmin, extent2.xmin);
                xmax = Math.min(extent1.xmax, extent2.xmax);
            }
        }

        ymin = Math.max(extent1.ymin, extent2.ymin);
        ymax = Math.min(extent1.ymax, extent2.ymax);
        return new MGRS.Extent(xmin, ymin, xmax, ymax);
    },

    extentClipLine: function (extent, p1, p2, code, pt) {
        return MGRS.Utils.extentClipLineXY(extent, p1.x, p1.y, p2.x, p2.y, code, pt);
    },

    extentClipLineXY: function (extent, x1, y1, x2, y2, code, pt) {

        var x, y,
            width = x2 - x1,
            height = y2 - y1;

        if (Math.abs(width) < 1e-012 && Math.abs(height) < 1e-012) {
            return false;
        }
        if ((code & MGRS.Utils.OUT_BOTTOM) != 0) {
            x = x1 + width * (extent.ymax - y1) / height;
            y = extent.ymax;
            if (x < extent.xmin) {
                return MGRS.Utils.extentClipLineXY(extent, x, y, x2, y2, code & 7, pt);
            }
        } else if ((code & MGRS.Utils.OUT_TOP) != 0) {
            x = x1 + width * (extent.ymin - y1) / height;
            y = extent.ymin;
            if (x < extent.xmin) {
                return MGRS.Utils.extentClipLineXY(extent, x, y, x2, y2, code & 13, pt);
            }
        } else if ((code & MGRS.Utils.OUT_RIGHT) != 0) {
            y = y1 + height * (extent.xmax - x1) / width;
            x = extent.xmax;
            if (y < extent.ymin) {
                return MGRS.Utils.extentClipLineXY(extent, x, y, x2, y2, code & 11, pt);
            }
        } else if ((code & MGRS.Utils.OUT_LEFT) != 0) {
            y = y1 + height * (extent.xmin - x1) / width;
            x = extent.xmin;
            if (y < extent.ymin) {
                return MGRS.Utils.extentClipLineXY(extent, x, y, x2, y2, code & 14, pt);
            }
        } else {
            return false;
        }
        pt.setTo(x, y);
        return true;
    },

    extentClipPolygon: function (extent, polygon) {
        var rings = [], i, length;
        for (i = 0, length = polygon.rings.length; i < length; i++) {
            MGRS.Utils.clipRingByExtent(extent, polygon.rings[i], rings);
        }
        if (rings.length === 0) {
            return null;
        }
        return new MGRS.Polygon(rings);
    },

    extentClipPolyline: function (extent, polyline) {
        var paths = [],
            i, length;
        for (i = 0, length = polyline.paths.length; i < length; i++) {
            MGRS.Utils.clipPathByExtent(polyline.paths[i], extent, paths);
        }
        if (paths.length === 0) {
            return null;
        }
        return new MGRS.Polyline(paths);
    },
    // was extentContainExtent_Relative
    extentContainExtentRelative: function (extent2, extent1) {
        return (extent1.xmax <= extent2.xmax) && (extent2.xmin <= extent1.xmin) && (extent1.ymax <= extent2.ymax) && (extent2.ymin <= extent1.ymin);
    },
    // was extentDisjointExtent_Relative
    extentDisjointExtentRelative: function (extent1, extent2) {
        return extent1.ymin > extent2.ymax;
    },
    extentOutcode: function (extent, point) {
        var outcode = 0;
        if (extent.xmax <= extent.xmin) {
            outcode = outcode | (MGRS.Utils.OUT_LEFT | MGRS.Utils.OUT_RIGHT);
        } else if (point.x < extent.xmin) {
            outcode = outcode | MGRS.Utils.OUT_LEFT;
        } else if (point.x > extent.xmax) {
            outcode = outcode | MGRS.Utils.OUT_RIGHT;
        }
        if (extent.ymax <= extent.ymin) {
            outcode = outcode | (MGRS.Utils.OUT_TOP | MGRS.Utils.OUT_BOTTOM);
        } else if (point.y < extent.ymin) {
            outcode = outcode | MGRS.Utils.OUT_TOP;
        } else if (point.y > extent.ymax) {
            outcode = outcode | MGRS.Utils.OUT_BOTTOM;
        }
        return outcode;
    },
    floor: function (number, interval) {

        var absoluteValue = Math.abs(number),
            remainder = absoluteValue % interval,
            answer;
        if (remainder === 0) {
            answer = number;
        } else if (number < 0) {
            answer = number + remainder - interval;
        } else {
            answer = number - remainder;
        }
        return answer;
    },
    getAreaPoints: function (points) {
        var i = 0,
            area = 0,
            len = points.length,
            pos = len - 1,
            p1, p2;
        while (i < len) {
            p1 = points[pos];
            p2 = points[i];
            area += p1.x * p2.y - p2.x * p1.y;
            pos = i;
            i++;
        }
        return .5 * area;
    },
    getCentroidAndAreaPoints: function (points, centroidAndArea) {
        var i = 0,
            len = points.length,
            last = len - 1,
            x = 0,
            y = 0,
            area = 0,
            square;
        while (i < len) {
            square = points[last].x * points[i].y - points[i].x * points[last].y;
            area = area + square;
            x += (points[last].x + points[i].x) * square;
            y += (points[last].y + points[i].y) * square;
            last = i;
            i++;
        }
        area /= 2;
        x /= (6 * area);
        y /= (6 * area);
        if (centroidAndArea == null) {
            centroidAndArea = new MGRS.CentroidAndArea();
        }
        centroidAndArea.centroid.setTo(x, y);
        centroidAndArea.area = area;
        return centroidAndArea;
    },
    getCentroidAndAreaPolygon: function (polygon) {
        var polyCentroid = new MGRS.CentroidAndArea(),
            pointCentroid = new MGRS.CentroidAndArea(),
            i, length;
        for (i = 0, length = polygon.rings.length; i < length; i++) {
            var ring = polygon.rings[i];
            MGRS.Utils.getCentroidAndAreaPoints(ring, pointCentroid);
            polyCentroid.centroid.x += pointCentroid.centroid.x * pointCentroid.area;
            polyCentroid.centroid.y += pointCentroid.centroid.y * pointCentroid.area;
            polyCentroid.area += pointCentroid.area;
        }
        polyCentroid.centroid.x /= polyCentroid.area;
        polyCentroid.centroid.y /= polyCentroid.area;
        return polyCentroid;
    },
    // was isClosed
    isPathClosed: function (path) {
        return path[0].equal(path[path.length - 1]);
    },
    // was Mgrs.Mgrs.Zone.latZone
    latitudeZone: function (index) {
        return LATITUDE_BANDS.charAt(index);
    },
    makePath: function (ptStart, start, end, ptEnd, pts) {
        var len = 0;
        if (ptStart != null) {
            len++;
        }
        if (ptEnd != null) {
            len++;
        }
        if (start != -1) {
            len += end - start + 1;
        }
        if (len == 1) {
            return null;
        }
        var path = [];
        if (ptStart != null) {
            path.push(ptStart.clone());
        }
        if (start != -1) {
            while (start <= end) {
                path.push(pts[start].clone());
                start++;
            }
        }
        if (ptEnd != null) {
            path.push(ptEnd.clone());
        }
        return path;
    },
    // was BN.MGRS.RingCollection.relatePointsPoint
    relatePointsPoint: function (mPoints, px, py) {

        var flag = 0,
            prev, last,
            diffY = mPoints[0].y - mPoints[(mPoints.length - 1)].y,
            curr = 0, next = 1,
            currX, currY,
            nextX, nextY,
            even = 0, shift;

        if (diffY < 0) {
            flag = 1;
        } else if (diffY > 0) {
            flag = 0;
        } else {
            prev = mPoints.length - 2;
            last = prev + 1;
            while (mPoints[prev].y == mPoints[last].y) {
                prev--;
                last--;
                if (prev == 0) {
                    return false;
                }
            }
            diffY = mPoints[last].y - mPoints[prev].y;
            if (diffY < 0) {
                flag = 1;
            } else if (diffY > 0) {
                flag = 0;
            }
        }

        while (curr < (mPoints.length - 1)) {
            currX = mPoints[curr].x;
            currY = mPoints[curr].y;
            nextX = mPoints[next].x;
            nextY = mPoints[next].y;
            if (py > currY) {
                if (py < nextY) {
                    shift = (py - currY) * (nextX - currX) / (nextY - currY) + currX;
                    if (px < shift) {
                        even++;
                    } else if (px == shift) {
                        return false;
                    }
                } else if (py == nextY) {
                    flag = 0;
                }
            } else if (py < currY) {
                if (py > nextY) {
                    shift = (py - currY) * (nextX - currX) / (nextY - currY) + currX;
                    if (px < shift) {
                        even++;
                    } else if (px == shift) {
                        return false;
                    }
                } else if (py == nextY) {
                    flag = 1;
                }
            } else {
                if (px == currX) {
                    return false;
                }
                if (py < nextY) {
                    if (flag !== 1 && px < currX) {
                        even++;
                    }
                } else if (py > nextY) {
                    if (flag > 0 && px < currX) {
                        even++;
                    }
                } else {
                    if (px > currX && px <= nextX) {
                        return false;
                    }
                    if (px < currX && px >= nextX) {
                        return false;
                    }
                }
            }
            curr++;
            next++;
        }
        return even % 2 != 0;
    }

};

MGRS.Point = function (x, y) {
    this.x = x || 0;
    this.y = y || 0;
};

MGRS.Point.prototype = {
    clone: function () {
        return new MGRS.Point(this.x, this.y);
    },
    copyFrom: function (point) {
        this.x = point.x;
        this.y = point.y;
    },
    copyFrom2: function (point) {
        this.x = point.x;
        this.y = point.y;
    },
    equal: function (point) {
        if (point) {
            return this.x.toFixed(12) == point.x.toFixed(12) && this.y.toFixed(12) == point.y.toFixed(12);
        } else {
            return false;
        }
    },
    multiply: function (factor) {
        this.x *= factor;
        this.y *= factor;
    },
    offset: function (xo, yo) {
        this.x += xo;
        this.y += yo;
    },

    setTo: function (xo, yo) {
        this.x = xo;
        this.y = yo;
    }
};

MGRS.Point.interpolate = function (p0, p1, round) {
    var interpolatedPoint;
    if (round == true) {
        interpolatedPoint = new MGRS.Point((.5 * (p0.x + p1.x)) | 0, (.5 * (p0.y + p1.y)) | 0);
    } else {
        interpolatedPoint = new MGRS.Point(.5 * (p0.x + p1.x), .5 * (p0.y + p1.y));
    }
    return interpolatedPoint;
};

MGRS.Polygon = function (rings) {

    var minX = Number.MAX_VALUE,
        minY = Number.MAX_VALUE,
        maxX = -Number.MAX_VALUE,
        maxY = -Number.MAX_VALUE,
        i, length, j, jLength,
        ring, point;

    for (i = 0, length = rings.length; i < length; i++) {
        ring = rings[i];
        for (j = 0, jLength = ring.length; j < jLength; j++) {
            point = ring[j];
            minX = Math.min(minX, point.x);
            minY = Math.min(minY, point.y);
            maxX = Math.max(maxX, point.x);
            maxY = Math.max(maxY, point.y);
        }
    }

    this.rings = rings;
    this.extent = new MGRS.Extent(minX, minY, maxX, maxY);
};
MGRS.Polygon.prototype.contains = function (point) {
    // TODO Compare to GeometryUtilities.isPointInPolygon function...
    var ptJ, j,
        ptI, i,
        doesContain = false;
    this.rings.forEach(function (ring) {
        i = 0;
        j = 0;
        while (j < ring.length) {
            i++;
            if (i === ring.length) {
                i = 0;
            }
            ptJ = ring[j];
            ptI = ring[i];

            if ((ptJ.y < point.y && ptI.y >= point.y || ptI.y < point.y && ptJ.y >= point.y) && ptJ.x + (point.y - ptJ.y) / (ptI.y - ptJ.y) * (ptI.x - ptJ.x) < point.x) {
                doesContain = !doesContain;
            }
            j++;
        }
    });
    return doesContain;
};
MGRS.NamedPolygon = function (name, polygon, zone) {
    this.name = name;
    this.polygon = polygon;
    this.zone = zone;
};
MGRS.Polyline = function (paths) {
    this.paths = paths;
};
MGRS.CentroidAndArea = function () {
    this.centroid = new MGRS.Point();
    this.area = 0;
};
MGRS.RingCollection = function (ring, rings, envelope) {
    this.points = ring;
    this.rings = rings;
    this.minx = envelope.xmin;
    this.miny = envelope.ymin;
    this.maxx = envelope.xmax;
    this.maxy = envelope.ymax;
    this.width = envelope.width;
    this.height = envelope.height;
    this.closed = MGRS.Utils.isPathClosed(ring);
    this.entryList = [];
};
MGRS.RingCollection.prototype = {
    dispose: function () {
        this.entryList.length = 0;
        this.entryList = null;
    },
    sortEntryList: function () {
        this.entryList.sort(function (el1, el2) {
            return el1.startStation > el2.startStation ? 1 : (el1.startStation < el2.startStation ? -1 : 0);
        });
    },
    generate: function (bReverse) {
        if (this.entryList.length === 0) {
            return;
        }
        this.sortEntryList();
        var doubleSize = this.height * 2 + this.width * 2,
            entry = this.entryList[0],
            entryStartStation = entry.startStation,
            i = 1, points, pointsNum, j, k, l, m,
            maxStation, loopEntry, loopEntry2;

        entry.startStation = 0;
        if (entry.endStation < entryStartStation) {
            entry.endStation += doubleSize - entryStartStation;
        } else {
            entry.endStation -= entryStartStation;
        }

        while (i < this.entryList.length) {
            entry = this.entryList[i];
            if (entry.endStation < entryStartStation) {
                entry.endStation += doubleSize - entryStartStation;
            } else {
                entry.endStation -= entryStartStation;
            }
            entry.startStation -= entryStartStation;
            i++;
        }
        i = 0;
        while (i < this.entryList.length) {
            entry = this.entryList[i];
            if (!entry.used) {
                entry.used = true;
                j = i;
                if (loopEntry != null) {
                    loopEntry.nextStart = i;
                }
                loopEntry = entry;
                if (entry.endStation < entry.startStation) {
                    entry.nextIndex = i;
                } else {
                    k = i;
                    while (k !== -1) {
                        maxStation = 999999999999999880000000000000;
                        l = -1;
                        m = k + 1;
                        while (m < this.entryList.length) {
                            loopEntry2 = this.entryList[m];
                            if (!loopEntry2.used) {
                                if (loopEntry2.startStation > entry.endStation && loopEntry2.startStation < maxStation) {
                                    if (loopEntry2.endStation <= loopEntry2.startStation && loopEntry2.endStation < entry.startStation) {
                                        l = m;
                                        maxStation = loopEntry2.startStation;
                                    }
                                }
                            }
                            m++;
                        }
                        if (l === -1) {
                            k = -1;
                            entry.nextIndex = j;
                            continue;
                        }
                        entry.nextIndex = l;
                        entry = this.entryList[l];
                        if (entry.endStation < entry.startStation) {
                            k = -1;
                            entry.nextIndex = j;
                        } else {
                            k = l;
                        }
                        entry.used = true;
                    }
                }
            }
            i++;
        }
        loopEntry.nextStart = 0;
        loopEntry = this.entryList[0];
        do {
            i = 0;
            entry = loopEntry;
            do {
                i += entry.getNumPoints() + entry.getNumPointsBetween(this.entryList[entry.nextIndex]);
                entry = this.entryList[entry.nextIndex];
            } while (entry != loopEntry);
            points = [];
            j = 0;
            while (j <= i) {
                points[j] = new MGRS.Point();
                j++;
            }
            entry = loopEntry;
            pointsNum = 0;
            do {
                pointsNum = entry.addPoints(points, pointsNum);
                pointsNum = entry.addPointsBetween(this.entryList[entry.nextIndex], points, pointsNum);
                entry = this.entryList[entry.nextIndex];
            } while (entry != loopEntry);
            points[i].copyFrom(points[0]);
            if (bReverse) {
                this.rings.push(points.reverse());
            } else {
                this.rings.push(points);
            }
            loopEntry = this.entryList[loopEntry.nextStart];
        } while (loopEntry != this.entryList[0]);
    },
    addStartEnd: function (startPoint, endPoint) {
        if (startPoint.equal(endPoint)) {
            return;
        }
        this.addStartEndRange(startPoint, -1, -2, endPoint);
    },
    addStartEndRange: function (startPoint, iStart, iEnd, endPoint) {
        this.entryList.push(new MGRS.Entry(startPoint, endPoint, iStart, iEnd, this));
    }
};
MGRS.Entry = function (startPoint, endPoint, startIndex, endIndex, ringCollection) {

    this.startEdge;
    this.startStation;
    this.endEdge;
    this.endStation;
    this.used;
    this.nextStart;
    this.nextIndex;
    this.ringCollection = ringCollection;
    this.startIndex = startIndex;
    this.endIndex = endIndex;

    var point;

    if (startPoint !== null) {
        this.startPoint = startPoint.clone();
        this.edge(this.startPoint.x, this.startPoint.y, true);
    } else {
        point = ringCollection.points[startIndex];
        this.edge(point.x, point.y, true);
    }

    if (endPoint !== null) {
        this.endPoint = endPoint.clone();
        this.edge(this.endPoint.x, this.endPoint.y, false);
    } else {
        point = ringCollection.points[endIndex];
        this.edge(point.x, point.y, false);
    }

};
MGRS.Entry.prototype = {

    addCorner: function (corner, mPoints, index) {
        var point = mPoints[index];
        switch (corner) {
            case 0:
                point.setTo(this.ringCollection.minx, this.ringCollection.maxy);
                break;
            case 1:
                point.setTo(this.ringCollection.maxx, this.ringCollection.maxy);
                break;
            case 2:
                point.setTo(this.ringCollection.maxx, this.ringCollection.miny);
                break;
            case 3:
                point.setTo(this.ringCollection.minx, this.ringCollection.miny);
                break;
        }
    },

    addPoints: function (mPoints, index) {
        var i = 0;
        if (this.startPoint !== null) {
            mPoints[index].copyFrom(this.startPoint);
            index++;
        }
        if (this.startIndex >= 0) {
            if (this.startIndex <= this.endIndex) {
                i = this.startIndex;
                while (i <= this.endIndex) {
                    mPoints[index].copyFrom(this.ringCollection.points[i]);
                    index++;
                    i++;
                }
            } else {
                var len = this.ringCollection.points.length;
                if (this.ringCollection.closed) {
                    len--;
                }
                i = this.startIndex;
                while (i < len) {
                    mPoints[index].copyFrom(this.ringCollection.points[i]);
                    index++;
                    i++;
                }
                i = 0;
                while (i <= this.endIndex) {
                    mPoints[index].copyFrom(this.ringCollection.points[i]);
                    index++;
                    i++;
                }
            }
        }

        if (this.endPoint !== null) {
            mPoints[index] = this.endPoint.clone();
            index++;
        }

        return index;
    },

    edge: function (x, y, atStart) {

        var edge = 0,
            station = 0;
        if (x === this.ringCollection.minx) {
            if (y == this.ringCollection.miny) {
                edge = 0;
                station = 0;
            } else if (y == this.ringCollection.maxy) {
                edge = 1;
                station = this.ringCollection.height;
            } else {
                edge = 0;
                station = y - this.ringCollection.miny;
            }
        } else if (x === this.ringCollection.maxx) {
            if (y == this.ringCollection.miny) {
                edge = 3;
                station = this.ringCollection.height * 2 + this.ringCollection.width;
            } else if (y == this.ringCollection.maxy) {
                edge = 2;
                station = this.ringCollection.height + this.ringCollection.width;
            } else {
                edge = 2;
                station = this.ringCollection.height + this.ringCollection.width + this.ringCollection.maxy - y;
            }
        } else if (y == this.ringCollection.miny) {
            station = this.ringCollection.height * 2 + this.ringCollection.width + this.ringCollection.maxx - x;
            edge = 3;
        } else if (y == this.ringCollection.maxy) {
            station = this.ringCollection.height + x - this.ringCollection.minx;
            edge = 1;
        }
        if (atStart) {
            this.startEdge = edge;
            this.startStation = station;
        } else {
            this.endEdge = edge;
            this.endStation = station;
        }
    },
    getNumPoints: function () {
        var count = 0;
        if (this.startIndex >= 0) {
            if (this.endIndex >= this.startIndex) {
                count = this.endIndex - this.startIndex + 1;
            } else {
                count = this.endIndex + this.ringCollection.points.length - this.startIndex + 1;
                if (this.ringCollection.closed) {
                    count--;
                }
            }
        }
        if (this.startPoint !== null) {
            count++;
        }
        if (this.endPoint !== null) {
            count++;
        }
        return count;
    },
    addPointsBetween: function (entry, mPoints, index) {
        var i = 0,
            limit = 0,
            corner;

        if (this.endEdge < entry.startEdge) {
            limit = entry.startEdge - this.endEdge;
        } else if (this.endEdge > entry.startEdge) {
            limit = entry.startEdge - this.endEdge + 4;
        } else {
            i = this.endStation - entry.startStation;
            if (i > 0 && i < this.ringCollection.height + this.ringCollection.width) {
                limit = 4;
            }
        }
        while (i < limit) {
            corner = this.endEdge + i;
            if (corner > 3) {
                corner -= 4;
            }
            this.addCorner(corner, mPoints, index);
            index++;
            i++;
        }

        return index;
    },
    getNumPointsBetween: function (entry) {
        var count = 0;
        if (this.endEdge < entry.startEdge) {
            count = entry.startEdge - this.endEdge;
        } else if (this.endEdge > entry.startEdge) {
            count = entry.startEdge - this.endEdge + 4;
        } else {
            if (this.endStation - entry.startStation < this.ringCollection.height + this.ringCollection.width) {
                count = 4;
            }
        }
        return count;
    }
};

MGRS.Extent = function (xmin, ymin, xmax, ymax) {

    this.xmin = xmin !== undefined ? xmin : 0;
    this.ymin = ymin !== undefined ? ymin : 0;
    this.xmax = xmax !== undefined ? xmax : 0;
    this.ymax = ymax !== undefined ? ymax : 0;
    this.height = this.ymax - this.ymin;
    if (this.xmax > this.xmin) {
        this.width = this.xmax - this.xmin;
    } else {
        this.width = (180 - Math.abs(this.xmax)) + (180 - Math.abs(this.xmin));
    }
};

MGRS.Extent.prototype.clipExtent = function (extent) {

    var xmin, xmax, ymin, ymax;
    if (extent.xmax > extent.xmin) {
        xmin = Math.max(this.xmin, extent.xmin);
        xmax = Math.min(this.xmax, extent.xmax);
    } else {
        if (this.xmin >= 0) {
            xmin = Math.max(this.xmin, extent.xmin);
            xmax = Math.max(this.xmax, extent.xmin);
        } else {
            xmin = Math.min(this.xmin, extent.xmin);
            xmax = Math.min(this.xmax, extent.xmax);
        }
    }
    ymin = Math.max(this.ymin, extent.ymin);
    ymax = Math.min(this.ymax, extent.ymax);
    return new MGRS.Extent(xmin, ymin, xmax, ymax);
};

MGRS.UtmZone = function () {

    this.zone = null;
    this.isNorth = false;
    this.isPolar = false;
    this.name = null;
    this.centralMeridian = null;
    this.projectedSpatialReference;
    this.geographicToProjected;
    this.projectedToOutputProjected;
};

MGRS.UtmZone.prototype.dispose = function () {};
MGRS.UtmZone.prototype.createCS = function () {
    return MGRS.ProjectedCS(MGRS.ProjectionsFactory.createTransverseMercator(MGRS.Ellipsoid.WGS84, this.centralMeridian, 0, 0.9996, 500000, this.isNorth ? 0 : 10000000));
};
// was containsZone
MGRS.UtmZone.prototype.inZones = function (zones) {

    var inZones = false,
        i, zone;
    for (i in zones) {
        zone = zones[i];
        if (zone.name === this.name) {
            inZones = true;
            break;
        }
    }
    return inZones;
};

MGRS.UtmZone.createPolarUtmZone = function (isNorth, isWest) {

    var utmZone = new MGRS.UtmZone(),
        zoneName,
        latc;

    utmZone.isNorth = isNorth;
    utmZone.isPolar = true;

    if (utmZone.isNorth) {
        latc = 90;
        zoneName = isWest ? "Y" : "Z";
    } else {
        latc = -90;
        zoneName = isWest ? "A" : "B";
    }

    utmZone.zoneName = zoneName;
    utmZone.projectedSpatialReference = MGRS.ProjectedCS(MGRS.ProjectionsFactory.createPolarStereographic(MGRS.Ellipsoid.WGS84, 0, latc, 1, 0, 0));
    utmZone.geographicToProjected = new MGRS.CoordinateTransformation(MGRS.GeographicCS.WGS84, utmZone.projectedSpatialReference);
    return utmZone;
};

MGRS.UtmZone.createNormalUtmZone = function (zone, isNorth) {
    var utmZone = new MGRS.UtmZone();
    utmZone.zone = zone;
    utmZone.isNorth = isNorth;
    utmZone.name = zone.toString() + (isNorth ? "N" : "S");
    utmZone.centralMeridian = zone * 6 - 183;
    utmZone.projectedSpatialReference = utmZone.createCS();
    utmZone.geographicToProjected = new MGRS.CoordinateTransformation(MGRS.GeographicCS.WGS84, utmZone.projectedSpatialReference);
    return utmZone;
};

MGRS.MgrsZone = function () {
    /*  attributes
        this.xyExtent;
        this.suffix;
        this.utmZone;
        this.latLonExtent;
        this.polylineX;
        this.polylineY;
    */
    this._bounds = null;
    this._center = null;

};

MGRS.MgrsZone.ACROSS1 = "ABCDEFGH";
MGRS.MgrsZone.ACROSS2 = "JKLMNPQR";
MGRS.MgrsZone.ACROSS3 = "STUVWXYZ";
MGRS.MgrsZone.UP1 = "ABCDEFGHJKLMNPQRSTUV";
MGRS.MgrsZone.UP2 = "FGHJKLMNPQRSTUVABCDE";
MGRS.MgrsZone.XNORTH_POLAR = "RSTUXYZABCFGHJ";
MGRS.MgrsZone.YNORTH_POLAR = "ABCDEFGHJKLMNP";
MGRS.MgrsZone.XSOUTH_POLAR = "JKLPQRSTUXYZABCFGHJKLPQR";
MGRS.MgrsZone.YSOUTH_POLAR = "ABCDEFGHJKLMNPQRSTUVWXYZ";
MGRS.MgrsZone.INFINITESIMAL = 1e-8;

MGRS.MgrsZone.prototype = {

    _bounds: function () {

        if (this._bounds === null) {
            this._bounds = [
                [this.latLonExtent.xmin, this.latLonExtent.ymin],
                [this.latLonExtent.xmax, this.latLonExtent.ymax]
            ];
        }
        return this._bounds;
    },

    center: function () {
        if (this._center === null) {
            var x;
            var y;
            if (this.utmZone.isPolar) {
                switch (this.utmZone.name) {
                    case "A":
                        x = -90;
                        y = -85.05112877980658 + Math.abs((-80 + 85.05112877980658) / 2);
                        break;
                    case "B":
                        x = 90;
                        y = -85.05112877980658 + Math.abs((-80 + 85.05112877980658) / 2);
                        break;
                    case "Y":
                        x = -90;
                        y = ((85.05112877980658 - 84) / 2) + 84;
                        break;
                    case "Z":
                        x = 90;
                        y = ((85.05112877980658 - 84) / 2) + 84;
                        break;
                }
            } else {
                if (this.latLonExtent.xmin >= 0) {
                    x = ((this.latLonExtent.xmax - this.latLonExtent.xmin) / 2) + this.latLonExtent.xmin
                } else {
                    x = this.utmZone.centralMeridian;
                }

                if (this.utmZone.isNorth) {
                    y = ((this.latLonExtent.ymax - this.latLonExtent.ymin) / 2) + this.latLonExtent.ymin;
                } else {
                    y = this.latLonExtent.ymin + Math.abs((this.latLonExtent.ymax - this.latLonExtent.ymin) / 2);
                }
            }

            this._center = new MGRS.Point(x, y);
        }
        return this._center;
    },

    dispose: function () {
        this.utmZone = null;
    },

    generateMgrsGrids: function (xyExtent, mgrsGrids, accuracy, extent, drawGrid, gridSize) {

        var useExtent = MGRS.Utils.extentClipExtent(xyExtent, this.xyExtent);
        if (useExtent === null) {
            return;
        }

        var polygon_1;
        var polygon_2;
        var polygon_3;
        var polyExtent;
        var coordTransform = this.utmZone.geographicToProjected;
        // reduce size of extent to only include the viewable area.
        var clipExtent = MGRS.Utils.extentClipExtent(this.latLonExtent, extent);
        var clipExtentPoints = coordTransform.projectPoints([
            new MGRS.Point(clipExtent.xmin, clipExtent.ymin),
            new MGRS.Point(clipExtent.xmin, clipExtent.ymax),
            new MGRS.Point(clipExtent.xmax, clipExtent.ymax),
            new MGRS.Point(clipExtent.xmax, clipExtent.ymin)], false);
        var cepPoint_0 = clipExtentPoints[0];
        var cepPoint_1 = clipExtentPoints[1];
        var cepPoint_2 = clipExtentPoints[2];
        var cepPoint_3 = clipExtentPoints[3];
        var cepExtent = MGRS.Utils.calculateExtentFromPath(clipExtentPoints);
        var ymax = cepExtent.ymax;
        var xmax = cepExtent.xmax;
        var xmin_100K = MGRS.Utils.floor(useExtent.xmin, MGRS.ONE_HUNDRED_K);
        var ymin_100K = MGRS.Utils.floor(useExtent.ymin, MGRS.ONE_HUNDRED_K);
        var xmin_grid = MGRS.Utils.ceil(cepExtent.xmin, gridSize);
        var ymin_grid = MGRS.Utils.ceil(cepExtent.ymin, gridSize);
        var poly_Y = [];
        var poly_X = [];
        var cepH_10 = cepPoint_1.y - cepPoint_0.y;
        var cepW_10 = cepPoint_1.x - cepPoint_0.x;
        var cepH_23 = cepPoint_2.y - cepPoint_3.y;
        var cepW_23 = cepPoint_2.x - cepPoint_3.x;
        var cepH_30 = cepPoint_3.y - cepPoint_0.y;
        var cepW_30 = cepPoint_3.x - cepPoint_0.x;
        var cepH_21 = cepPoint_2.y - cepPoint_1.y;
        var cepW_21 = cepPoint_2.x - cepPoint_1.x;
        var i, j;

        if (drawGrid) {
            for (i = ymin_grid; i < ymax; i+= gridSize) {
                poly_Y.push([
                    new MGRS.Point(cepPoint_0.x + (i - cepPoint_0.y) * cepW_10 / cepH_10, i),
                    new MGRS.Point(cepPoint_3.x + (i - cepPoint_3.y) * cepW_23 / cepH_23, i)
                ]);
            }
            j = xmin_grid;
            for (i = xmin_grid; i < xmax; i += gridSize) {
                poly_X.push([
                    new MGRS.Point(i, cepPoint_0.y + (i - cepPoint_0.x) * cepH_30 / cepW_30),
                    new MGRS.Point(i, cepPoint_1.y + (i - cepPoint_1.x) * cepH_21 / cepW_21)
                ]);
            }
            this.polylineY = new MGRS.Polyline(poly_Y);
            var polylineX = MGRS.Utils.extentClipPolyline(clipExtent, coordTransform.projectPolyline(new MGRS.Polyline(poly_X), true));
            if (polylineX === null) {
                this.polylineX = null;
            } else {
                this.polylineX = coordTransform.projectPolyline(polylineX, false);
            }
        }

        for(i = ymin_100K; i < ymax; i += MGRS.ONE_HUNDRED_K) {
            for (j = xmin_100K; j < xmax; j += MGRS.ONE_HUNDRED_K) {
                var polygonName = this.getMgrsNameX0Y0(j, i);
                if (Math.abs(j + MGRS.ONE_HUNDRED_K) < 0.0001) {
                    polygon_1 = new MGRS.Polygon([[
                        new MGRS.Point(j, i),
                        new MGRS.Point(j, i + MGRS.ONE_HUNDRED_K),
                        new MGRS.Point(-0.001, i + MGRS.ONE_HUNDRED_K),
                        new MGRS.Point(-0.001, i)
                    ]]);
                } else {
                    polygon_1 = new MGRS.Polygon([[
                        new MGRS.Point(j, i),
                        new MGRS.Point(j, i + MGRS.ONE_HUNDRED_K),
                        new MGRS.Point(j + MGRS.ONE_HUNDRED_K, i + MGRS.ONE_HUNDRED_K),
                        new MGRS.Point(j + MGRS.ONE_HUNDRED_K, i)
                    ]]);
                }
                polygon_2 = coordTransform.projectPolygon(polygon_1, true);
                polyExtent = MGRS.Utils.calculatePolygonExtent(polygon_2);
                if (MGRS.Utils.extentContainExtentRelative(clipExtent, polyExtent)) {
                    mgrsGrids.push(new MGRS.NamedPolygon(polygonName, polygon_1, this));
                } else {
                    if (! MGRS.Utils.extentContainExtentRelative(clipExtent, polyExtent)) {
                        polygon_3 = MGRS.Utils.extentClipPolygon(clipExtent, polygon_2);
                        if (polygon_3 != null) {
                            mgrsGrids.push(new MGRS.NamedPolygon(polygonName, coordTransform.projectPolygon(polygon_3, false), this));
                        }
                    }
                }
            }
        }
    },
    generateMgrsGrids2: function (mgrsGrids, accuracy, extent, bGrid, gridSize) {
        this.generateMgrsGrids(this.xyExtent, mgrsGrids, accuracy, extent, bGrid, gridSize);
    },
    getMgrsNameX0Y0: function (x, y) {
        var name;
        if (this.utmZone.isPolar) {
            var xIndex = Math.round(x / MGRS.ONE_HUNDRED_K),
                yIndex = Math.round(y / MGRS.ONE_HUNDRED_K);
            if (this.utmZone.isNorth) {
                name = MGRS.MgrsZone.XNORTH_POLAR.charAt(xIndex + 7) + MGRS.MgrsZone.YNORTH_POLAR.charAt(yIndex + 7);
            } else {
                name = MGRS.MgrsZone.XSOUTH_POLAR.charAt(xIndex + 12) + MGRS.MgrsZone.YSOUTH_POLAR.charAt(yIndex + 12);
            }
        } else {
            name = this.getWGS84_100KGridX(this.utmZone.zone, Math.round((x - MGRS.ONE_HUNDRED_K) / MGRS.ONE_HUNDRED_K)) + this.getWGS84_100KGridY(this.utmZone.zone, Math.round(y / MGRS.ONE_HUNDRED_K));
        }
        return name;
    },
    getWGS84_100KGridX: function (zone, xIndex) {
        var gridId = "";
        switch (zone % 3) {
            case 0:
                gridId = MGRS.MgrsZone.ACROSS3.charAt(xIndex);
                break;
            case 1:
                gridId = MGRS.MgrsZone.ACROSS1.charAt(xIndex);
                break;
            case 2:
                gridId = MGRS.MgrsZone.ACROSS2.charAt(xIndex);
                break;
        }
        return gridId;
    },
    getWGS84_100KGridY: function (zone, yIndex) {
        yIndex = yIndex % 20;
        if (zone % 2) {

            return MGRS.MgrsZone.UP1.charAt(yIndex);
        }
        return MGRS.MgrsZone.UP2.charAt(yIndex);
    },
    name: function () {
        var _name;
        if (this.suffix !== " ") {
            _name = this.utmZone.zone + this.suffix;
        } else {
            _name = this.utmZone.name;
        }
        return _name;
    },
};

MGRS.MgrsZone.createMgrsZone = function (utmZone, lat) {

    var SMALL_LON = 1e-9,
        center = utmZone.centralMeridian,
        left = center - 3,
        right = center + 3,
        minLatitude = MGRS.Utils.floor(lat + MGRS.MgrsZone.INFINITESIMAL, 8),
        zone = new MGRS.MgrsZone();

    zone.suffix = MGRS.Utils.latitudeZone((minLatitude + 80) / 8);
    zone.utmZone = utmZone;

    if (left < - 180 + SMALL_LON) {
        left = -180 + SMALL_LON;
    } else if (right > 180 - SMALL_LON) {
        right = 180 - SMALL_LON;
    }

    zone.latLonExtent = new MGRS.Extent(left, lat, right, lat + (minLatitude == 72 ? 12 : 8));
    zone.xyExtent = utmZone.geographicToProjected.projectExtent(zone.latLonExtent);
    return zone;
};

MGRS.MgrsZone.createMgrsZone2 = function (utmZone, lonMin, lonMax, latMin, latMax) {

    var minLatValue = 0,
        zone = new MGRS.MgrsZone();

    if (latMax <= 89 && latMin < -89) {
        zone.suffix = " ";
    } else {
        minLatValue = MGRS.Utils.floor(latMin + MGRS.MgrsZone.INFINITESIMAL, 8);
        zone.suffix = MGRS.Utils.latitudeZone((minLatValue + 80) / 8);
    }

    zone.utmZone = utmZone;
    zone.latLonExtent = new MGRS.Extent(lonMin, latMin, lonMax, latMax);
    zone.xyExtent = utmZone.geographicToProjected.projectExtent(zone.latLonExtent);

    return zone;
};

MGRS.Ellipsoid = function (semiMajor, inverseF, wktName) {

    var semiMinor, M1, M2, M3, M4, M5, P1, P2, P3, P4,
        eccentricity, eccentricitySquared, eccentricityPrimeSquared, isSphere, meridianDistanceToPole, F;

    if (inverseF == 0) {

        semiMinor = semiMajor;
        isSphere = true;
        eccentricitySquared = 0;
        eccentricity = 0;
        F = 0;

    } else {

        isSphere = false;
        F = 1 / inverseF;
        eccentricitySquared = F * 2 - F * F;
        eccentricity = Math.sqrt(eccentricitySquared);
        semiMinor = semiMajor * (1 - F);
        eccentricityPrimeSquared = eccentricitySquared / (1 - eccentricitySquared);
        var eccS2 = eccentricitySquared * eccentricitySquared,
            eccS3 = eccS2 * eccentricitySquared,
            eccS4 = eccS2 * eccS2,
            ecSqrt = Math.sqrt(1 - eccentricitySquared),
            ecSqrtLim = (1 - ecSqrt) / (1 + ecSqrt),
            ecSqrtLim2 = ecSqrtLim * ecSqrtLim,
            ecSqrtLim3 = ecSqrtLim2 * ecSqrtLim,
            ecSqrtLim4 = ecSqrtLim2 * ecSqrtLim2;
        M1 = 1 - eccentricitySquared / 4 - 3 * eccS2 / 64 - 5 * eccS3 / 256 - 175 * eccS4 / 16384;
        M2 = 3 * (eccentricitySquared + eccS2 / 4 + 15 * eccS3 / 128 - 455 * eccS4 / 4096) / 8;
        M3 = 15 * (eccS2 + 3 * eccS3 / 4 - 77 * eccS4 / 128) / 256;
        M4 = 35 * (eccS3 - 41 * eccS4 / 32) / 3072;
        M5 = -315 * eccS4 / 131072;
        P1 = 1.5 * ecSqrtLim - 0.84375 * ecSqrtLim3;
        P2 = 1.3125 * ecSqrtLim2 - 1.71875 * ecSqrtLim4;
        P3 = 151 * ecSqrtLim3 / 96;
        P4 = 1097 * ecSqrtLim4 / 512;
        meridianDistanceToPole = semiMajor * M1 * MGRS.HALF_PI;
    }
    var evenSineSeries = function (T, A, B, C, D) {
        var cos = Math.cos(2 * T);
        return Math.sin(2 * T) * (A - C + cos * (2 * B - 4 * D + cos * (4 * C + 8 * D * cos)));
    };
    var isEquivalent = function (ellipsoid) {
        return ellipsoid.semiMajor == semiMajor && ellipsoid.F == F;
    };
    var radiusOfCurvatureN = function (lat) {
        var sin = Math.sin(lat);
        return semiMajor / Math.sqrt(1 - eccentricitySquared * sin * sin);
    };
    var meridianDistance = function (lat) {
        return semiMajor * (M1 * lat + evenSineSeries(lat, -M2, M3, -M4, M5));
    };
    var rectifyingToLatitude = function (u) {
        return u + evenSineSeries(u, P1, P2, P3, P4);
    };
    var m = function (lat) {
        var eSin = eccentricity * Math.sin(lat);
        return Math.cos(lat) / Math.sqrt(1 - eSin * eSin);
    };
    var calcT = function (lat) {
        var eSin = eccentricity * Math.sin(lat);
        var latShift = MGRS.QUARTER_PI - .5 * lat;
        if (Math.abs(Math.abs(latShift) - MGRS.HALF_PI) < 1e-013) {
            return 0;
        }
        return Math.tan(latShift) / Math.pow((1 - eSin) / (1 + eSin), .5 * eccentricity);
    };
    return {
        semiMajor: semiMajor,
        eccentricity: eccentricity,
        eccentricitySquared: eccentricitySquared,
        eccentricityPrimeSquared: eccentricityPrimeSquared,
        isSphere: isSphere,
        meridianDistanceToPole: meridianDistanceToPole,
        F: F,
        isEquivalent: isEquivalent,
        radiusOfCurvatureN: radiusOfCurvatureN,
        meridianDistance: meridianDistance,
        rectifyingToLatitude: rectifyingToLatitude,
        m: m,
        calcT: calcT
    };
};
MGRS.Ellipsoid.WGS84 = MGRS.Ellipsoid(6378137, 298.257, "WGS84");
MGRS.Projection = function (ellipsoid, x, y) {
    this.ellipsoid = ellipsoid;
    this.x0 = x;
    this.y0 = y;
};
MGRS.Projection.prototype = {
    isGeographic: function () {
        return false;
    },
    fromGeographic: function () {},
    toGeographic: function () {},
    isEquivalent: function (projection) {
        return ellipsoid.isEquivalent(projection.ellipsoid);
    },
    toDegrees: function (point) {
        point.setTo(
            GeometryUtilities.toDegrees(point.x),
            GeometryUtilities.toDegrees(point.y)
        );
    },
    fromDegrees: function (point) {
        point.setTo(
            GeometryUtilities.toRadians(point.x),
            GeometryUtilities.toRadians(point.y)
        );
    },
    toMeters: function (point) {
        point.offset(-this.x0, -this.y0);
    },
    fromMeters: function (point) {
        point.offset(this.x0, this.y0);
    }
};
MGRS.MercatorSphere = function (ellipsoid, lonCM, lat1, falseEasting, falseNorthing) {
    MGRS.Projection.call(this, ellipsoid, falseEasting, falseNorthing);
    this.lon0 = GeometryUtilities.toRadians(lonCM);
    this.lat1 = GeometryUtilities.toRadians(lat1);
    this.latConstant = Math.cos(lat1);
};
MGRS.MercatorSphere.prototype = Object.create(MGRS.Projection.prototype);
MGRS.MercatorSphere.prototype.isEquivalent = function (projection) {
    return this.ellipsoid.isEquivalent(projection.ellipsoid) &&
        this.lon0 == projection.lon0 &&
        this.lat1 == projection.lat1 &&
        this.x0 == projection.x0 &&
        this.y0 == projection.y0;
};
MGRS.MercatorSphere.prototype.toGeographic = function (point) {
    this.toMeters(point);
    point.multiply(1 / this.latConstant);
    point.setTo(this.lon0 + point.x / this.ellipsoid.semiMajor, MGRS.HALF_PI - 2 * Math.atan(Math.exp(-point.y / this.ellipsoid.semiMajor)));
    this.toDegrees(point);
};
MGRS.MercatorSphere.prototype.fromGeographic = function (point) {
    this.fromDegrees(point);
    if (Math.abs(point.y) + 1e-013 >= MGRS.HALF_PI) {
        point.y = point.y > 0 ? 1000000000000000000000000000000 : -1000000000000000000000000000000;
    } else {
        point.y = this.latConstant * this.ellipsoid.semiMajor * Math.log(Math.tan(MGRS.QUARTER_PI + .5 * point.y));
    }
    point.x = this.ellipsoid.semiMajor * (point.x - this.lon0) * this.latConstant;
    this.fromMeters(point);
};
MGRS.MercatorSphere.prototype.constructor = MGRS.MercatorSphere;
MGRS.PolarStereographicNonSphere = function (ellipsoid, lon0, latc, k0, x0, y0) {
    MGRS.Projection.call(this, ellipsoid, x0, y0);
    this.lon0 = GeometryUtilities.toRadians(lon0);
    this.latc = GeometryUtilities.toRadians(latc);
    this.k0 = k0;
    if (latc < 0) {
        this.bSouthern = true;
        this.latc = -latc;
        this.lon0 = -lon0;
    } else {
        this.bSouthern = false;
    }
    var e = this.ellipsoid.eccentricity;
    if (Math.abs(Math.abs(this.latc) - MGRS.HALF_PI) < 1e-013) {
        this.eFactor = 2 * this.ellipsoid.semiMajor * this.k0 / Math.sqrt(Math.pow(1 + e, 1 + e) * Math.pow(1 - e, 1 - e));
    } else {
        var t = this.ellipsoid.calcT(this.latc);
        if (t === 0) {
            this.eFactor = 0;
        } else {
            this.eFactor = this.ellipsoid.semiMajor * this.ellipsoid.m(latc) / t;
        }
    }
};
MGRS.PolarStereographicNonSphere.prototype = Object.create(MGRS.Projection.prototype);
MGRS.PolarStereographicNonSphere.prototype.toGeographic = function (point) {
    this.toMeters(point);
    var radius = Math.sqrt(point.x * point.x + point.y * point.y);

    if (this.bSouthern) {
        point.multiply(-1);
    }

    if (Math.abs(radius) < 1e-013) {
        point.x = this.lon0;
    } else {
        point.x = this.lon0 + Math.atan2(point.x, -point.y);
    }

    if (point.x < -Math.PI) {
        point.x = point.x + Math.PI * 2;
    } else if (point.x > Math.PI) {
        point.x = point.x - Math.PI * 2;
    }

    var rad = radius / this.eFactor,
        angle = MGRS.HALF_PI - 2 * Math.atan(rad),
        i = 0,
        eSin,
        loopAngle;

    do {
        loopAngle = angle;
        eSin = this.ellipsoid.eccentricity * Math.sin(angle);
        angle = MGRS.HALF_PI - 2 * Math.atan(rad * Math.pow((1 - eSin) / (1 + eSin), .5 * this.ellipsoid.eccentricity));
        i++;
    } while (Math.abs(angle - loopAngle) > 1e-012 && i < 100);

    point.y = angle;
    if (this.bSouthern) {
        point.multiply(-1);
    }
    this.toDegrees(point);
};
MGRS.PolarStereographicNonSphere.prototype.fromGeographic = function (point) {
    this.fromDegrees(point);
    if (this.bSouthern) {
        if (point.y > 0) {
            point.y = 0;
        }
        point.multiply(-1);
    } else if (point.y < 0) {
        point.y = 0;
    }
    var _x = point.x - this.lon0;
    var eT = this.eFactor * this.ellipsoid.calcT(point.y);
    point.setTo(eT * Math.sin(_x), -eT * Math.cos(_x));
    if (this.bSouthern) {
        point.multiply(-1);
    }
    this.fromMeters(point);
};
MGRS.PolarStereographicNonSphere.prototype.constructor = MGRS.PolarStereographicNonSphere;
MGRS.TransverseMercatorNonSphere = function (ellipsoid, lonCM, lat0, k0, falseEasting, falseNorthing) {
    MGRS.Projection.call(this, ellipsoid, falseEasting, falseNorthing);
    this.lonCM = GeometryUtilities.toRadians(lonCM);
    this.lat0 = GeometryUtilities.toRadians(lat0);
    this.k0 = k0;
    this.M0 = this.ellipsoid.meridianDistance(lat0);
};
MGRS.TransverseMercatorNonSphere.prototype = Object.create(MGRS.Projection.prototype);
MGRS.TransverseMercatorNonSphere.prototype.isEquivalent = function (projection) {
    return this.ellipsoid.isEquivalent(projection.ellipsoid) &&
        (this.lonCM == projection.lonCM) &&
        (this.lat0 == projection.lat0) &&
        (this.k0 == projection.k0) &&
        (this.x0 == projection.x0) &&
        (this.y0 == projection.y0);
};
MGRS.TransverseMercatorNonSphere.prototype.toGeographic = function (point) {
    this.toMeters(point);
    var ees = this.ellipsoid.eccentricitySquared,
        rectToLat = this.ellipsoid.rectifyingToLatitude(MGRS.HALF_PI * (this.M0 + point.y / this.k0) / this.ellipsoid.meridianDistanceToPole),
        eep = this.ellipsoid.eccentricityPrimeSquared,
        cos = Math.cos(rectToLat),
        sin = Math.sin(rectToLat),
        tg = cos > 1e-014 ? (sin / cos) : (0),
        eCos2 = eep * cos * cos,
        tg2 = tg * tg,
        aeSin2 = 1 - ees * sin * sin,
        aeSin2Sqrt = Math.sqrt(aeSin2),
        esm1 = this.ellipsoid.semiMajor / aeSin2Sqrt,
        esm2 = this.ellipsoid.semiMajor * (1 - ees) / (aeSin2 * aeSin2Sqrt),
        xesm = point.x / (esm1 * this.k0),
        xesm2 = xesm * xesm,
        eCos4 = eCos2 * eCos2,
        xesm4 = xesm2 * xesm2,
        tg4 = tg2 * tg2;
    point.setTo(
        this.lonCM + (xesm - (1 + 2 * tg2 + eCos2) * xesm * xesm2 / 6 + (5 - 2 * eCos2 + 28 * tg2 - 3 * eCos4 + 8 * eep + 24 * tg4) * xesm4 * xesm / 120) / cos,
        rectToLat - esm1 * tg / esm2 * (xesm2 * 0.5 - (5 + 3 * tg2 + 10 * eCos2 - 4 * eCos4 - 9 * eep) * xesm4 / 24 + (61 + 90 * tg2 + 298 * eCos2 + 45 * tg4 - 252 * eep - 3 * eCos4) * xesm4 * xesm2 / 720)
    );
    this.toDegrees(point);
};
MGRS.TransverseMercatorNonSphere.prototype.fromGeographic = function (point) {
    this.fromDegrees(point);
    var epsq = this.ellipsoid.eccentricityPrimeSquared,
        m = this.ellipsoid.meridianDistance(point.y),
        v = this.ellipsoid.radiusOfCurvatureN(point.y),
        cos = Math.cos(point.y),
        sin = Math.sin(point.y),
        tg;
    if (Math.abs(cos) < 1e-010) {
        tg = (cos > 0 ? sin : -sin) / 1e-010;
    } else {
        tg = sin / cos;
    }
    var tg2 = tg * tg,
        tg4 = tg2 * tg2,
        epsqCos = epsq * cos * cos,
        aCos = (point.x - this.lonCM) * cos,
        aCos2 = aCos * aCos,
        aCos3 = aCos2 * aCos;
    point.setTo(
        this.k0 * v * (aCos + (1 - tg2 + epsqCos) * aCos3 / 6 + (5 - 18 * tg2 + tg4 + 72 * epsqCos - 58 * epsq) * aCos3 * aCos2 / 120),
        this.k0 * (m - this.M0 + v * tg * (aCos2 * 0.5 + (5 - tg2 + 9 * epsqCos + 4 * epsqCos * epsqCos) * aCos2 * aCos2 / 24 + (61 - 58 * tg2 + tg4 + 600 * epsqCos - 330 * epsq) * aCos3 * aCos3 / 720))
    );
    this.fromMeters(point);
};
MGRS.TransverseMercatorNonSphere.prototype.constructor = MGRS.TransverseMercatorNonSphere;
MGRS.ProjectionsFactory = {
    WEB_MERCATOR: new MGRS.MercatorSphere(MGRS.Ellipsoid(6378137, 0, "Sphere R=WGS84 constatnt"), 0, 0, 0, 0),
    createTransverseMercator: function (ellipsoid, lonCM, lat0, k0, falseEasting, falseNorthing) {
        return new MGRS.TransverseMercatorNonSphere(ellipsoid, lonCM, lat0, k0, falseEasting, falseNorthing);
    },
    createPolarStereographic: function (ellipsoid, lon0, latc, k0, x0, y0) {
        return new MGRS.PolarStereographicNonSphere(ellipsoid, lon0, latc, k0, x0, y0);
    }
};
MGRS.Meridian = function (degrees) {
    this.meridian = degrees;
};
MGRS.Meridian.prototype.isEquivalent = function (meridian) {
    return Math.abs(this.meridian - meridian.meridian) < 1e-012;
};
MGRS.Meridian.GREENWICH = new MGRS.Meridian(0);
MGRS.GeographicCS = function (name, meridian, ellipsoid) {
    return {
        name: name,
        meridian: meridian,
        ellipsoid: ellipsoid,
        isGeographic: function () {
            return true;
        },
        isEquivalent: function (geographicCS) {
            return this.meridian.isEquivalent(geographicCS.meridian);
        },
        toGeographic: function (point) {},
        fromGeographic: function (point) {}
    };
};
MGRS.GeographicCS.WGS84 = MGRS.GeographicCS("WGS84", MGRS.Meridian.GREENWICH, MGRS.Ellipsoid.WGS84);
MGRS.ProjectedCS = function (projection) {
    return {
        geographicCS: MGRS.GeographicCS.WGS84,
        isGeographic: function () {
            return false;
        },
        toGeographic: function (point) {
            return projection.toGeographic(point);
        },
        fromGeographic: function (point) {
            return projection.fromGeographic(point);
        },
        isEquivalent: function (projectedCS) {
            return this.geographicCS.isEquivalent(projectedCS.geographicCS);
        }
    };
};
MGRS.ProjectedCS.WEB_MERCATOR = MGRS.ProjectedCS(MGRS.ProjectionsFactory.WEB_MERCATOR);
MGRS.CoordinateTransformation = function (p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.bufferPoint = new MGRS.Point();
};
MGRS.CoordinateTransformation.prototype = {
    project: function (point) {
        this.p1.toGeographic(point);
        this.p2.fromGeographic(point);
    },
    projectInverse: function (point) {
        this.p1.fromGeographic(point);
        this.p2.toGeographic(point);
    },
    pointUnionExtent: function (point, extent) {
        if (point.x < extent.xmin) {
            extent.xmin = point.x;
        } else if (point.x > extent.xmax) {
            extent.xmax = point.x;
        }
        if (point.y < extent.ymin) {
            extent.ymin = point.y;
        } else if (point.y > extent.ymax) {
            extent.ymax = point.y;
        }
    },
    _projectExtent: function (point, extent) {
        this.project(point);
        this.pointUnionExtent(point, extent);
    },
    projectExtent: function (ext) {

        var xmid = .5 * (ext.xmin + ext.xmax);
        var ymid = .5 * (ext.ymin + ext.ymax);

        this.bufferPoint.setTo(xmid, ymid);
        this.project(this.bufferPoint);
        var extent = new MGRS.Extent(this.bufferPoint.x, this.bufferPoint.y, this.bufferPoint.x, this.bufferPoint.y);
        //// @TODO - check if copyFrom is faster
        this.bufferPoint.y = ext.ymin;
        this.bufferPoint.x = xmid;
        this._projectExtent(this.bufferPoint, extent);

        this.bufferPoint.y = ext.ymax;
        this.bufferPoint.x = xmid;
        this._projectExtent(this.bufferPoint, extent);

        this.bufferPoint.x = ext.xmax;
        this.bufferPoint.y = ext.ymax;
        this._projectExtent(this.bufferPoint, extent);

        this.bufferPoint.y = ext.ymin;
        this.bufferPoint.x = ext.xmax;
        this._projectExtent(this.bufferPoint, extent);

        this.bufferPoint.y = ymid;
        this.bufferPoint.x = ext.xmax;
        this._projectExtent(this.bufferPoint, extent);

        this.bufferPoint.y = ymid;
        this.bufferPoint.x = ext.xmin;
        this._projectExtent(this.bufferPoint, extent);

        this.bufferPoint.x = ext.xmin;
        this.bufferPoint.y = ext.ymin;
        this._projectExtent(this.bufferPoint, extent);

        this.bufferPoint.x = ext.xmin;
        this.bufferPoint.y = ext.ymax;
        this._projectExtent(this.bufferPoint, extent);
        return extent;
    },
    projectPoints: function (points, inverse) {
        var results = [],
            point,
            i, length;
        for (i = 0, length = points.length; i < length; i++) {
            point = points[i];
            this.bufferPoint.copyFrom(point);
            if (inverse) {
                this.projectInverse(this.bufferPoint);
            } else {
                this.project(this.bufferPoint);
            }
            results.push(this.bufferPoint.clone());
        }
        return results;
    },
    projectPolygon: function (polygon, inverse) {
        var rings = [],
            i, length;
        for (i = 0, length = polygon.rings.length; i < length; i++) {
            rings.push(this.projectPoints(polygon.rings[i], inverse));
        }
        return new MGRS.Polygon(rings);
    },
    projectPolyline: function (polyline, inverse) {
        var paths = [],
            i, length;
        for (i = 0, length = polyline.paths.length; i < length; i++) {
            paths.push(this.projectPoints(polyline.paths[i], inverse));
        }
        return new MGRS.Polyline(paths);
    }
};
MGRS.PointTransformer = function () {};
MGRS.PointTransformer.prototype = {
    init: function (accuracy, transformation) {
        this.accuracy = accuracy;
        this.transformation = transformation;
        this.accuracy5 = accuracy * 5;
        this.count = 0;
        this.count2 = -1;
    },
    prepareForDraw: function () {
        this.accuracy = 0;
        this.accuracy5 = 0;
        this.count = 0;
        this.count2 = -1;
        this.limit = 256;
        this.maxPointNum = 128;
        this.points = [];
        this.pointsProj = [];
        this.transformation = null;
        this.xy = [];

        var i = 0;
        while (i <= this.maxPointNum) {
            this.points[i] = new MGRS.Point();
            this.pointsProj[i] = new MGRS.Point();
            i++;
        }
        i = 0;
        while (i < this.limit) {
            this.xy.push(new MGRS.Point());
            i++;
        }
    },
    add: function (point) {
        if (this.count === this.limit) {
            var i, tmpLimit;
            i = tmpLimit = this.limit;
            this.limit *= 2;
            while (i < this.limit) {
                this.xy[i] = new MGRS.Point();
                i++;
            }
        }
        this.xy[this.count].copyFrom(point);
        this.count++;
        this.count2++;
    },
    apply: function (point) {
        var tmpPoint = point.clone();
        this.transformation.project(tmpPoint);
        point.copyFrom(tmpPoint);
    },
    dispose: function () {
        this.points = null;
        this.pointsProj = null;
        this.xy = null;
    },
    transformLine: function (from, to, addLast) {
        var center = (from + to) / 2;
        this.points[center] = MGRS.Point.interpolate(this.points[from], this.points[to]);
        this.pointsProj[center].copyFrom(this.points[center]);
        this.apply(this.pointsProj[center]);
        if (center % 2) {
            this.add(this.pointsProj[center]);
        } else {
            if (Math.abs(this.pointsProj[center].y - MGRS.Point.interpolate(this.pointsProj[from], this.pointsProj[to]).y) > this.accuracy) {
                this.transformLine(from, center, true);
                this.transformLine(center, to, false);
            }
        }
        if (addLast) {
            this.add(this.pointsProj[to]);
        }
    },
    warp: function (pts) {
        if (pts.length === 0) {
            return null;
        }
        this.count = 0;
        this.count2 = -1;
        this.points[0].copyFrom(pts[0]);
        this.pointsProj[0].copyFrom(pts[0]);
        this.apply(this.pointsProj[0]);
        this.add(this.pointsProj[0]);
        var i = 1, currPoint, prevPoint;
        while (i < pts.length) {
            currPoint = pts[i];
            //var coord = currPoint.clone();
            //MGRS.ProjectedCS.WEB_MERCATOR.toGeographic(coord);
            //console.log(currPoint, coord);
            this.points[this.maxPointNum].copyFrom(currPoint);
            this.pointsProj[this.maxPointNum].copyFrom(currPoint);
            this.apply(this.pointsProj[this.maxPointNum]);
            if (Math.abs(this.xy[this.count2].x - this.pointsProj[this.maxPointNum].x) <= this.accuracy5 && Math.abs(this.xy[this.count2].y - this.pointsProj[this.maxPointNum].y) > this.accuracy5) {
                this.transformLine(0, this.maxPointNum, true);
            } else {
                prevPoint = pts[i - 1];
                if (Math.abs(currPoint.x - prevPoint.x) <= 180 && Math.abs(currPoint.y - prevPoint.y) > 90) {
                    this.transformLine(0, this.maxPointNum, true);
                }
                this.add(this.pointsProj[this.maxPointNum]);
            }
            this.points[0].copyFrom(this.points[this.maxPointNum]);
            this.pointsProj[0].copyFrom(this.pointsProj[this.maxPointNum]);
            i++;
        }
        if (this.count <= 1) {
            return null;
        }
        var results = [];
        i = 0;
        while (i < this.count) {
            results.push(this.xy[i].clone());
            i++;
        }
        return results;
    }
};
