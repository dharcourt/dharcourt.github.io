/**
 * @module ui/scale-overlay.reel
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    METRIC_SYSTEM_SET = [0.25, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000],
    IMPERIAL_SET = [0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5280, 10560, 26400, 52800, 105600, 264000, 528000, 1056000, 2640000, 5280000, 10560000],
    FEET_PER_MILE = 5280,
    METERS_PER_KILOMETER = 1000,
    CENTIMETERS_PER_INCH = 2.54;

/**
 * @class ScaleOverlay
 * @extends Component
 */
exports.ScaleOverlay = Component.specialize(/** @lends ScaleOverlay# */ {

    constructor: {
        value: function ScaleOverlay() {
            this.super();
        }
    },

    __pixelsPerInch: {
        enumerable: false,
        value: null
    },

    _groupNumbers: {
        value: function (value) {

            var groupLength = 3,
                stringValue = value.toString(),
                result = "";

            while (stringValue.length >= groupLength) {
                var length = stringValue.length - groupLength,
                    chain = stringValue.substr(length);
                stringValue = stringValue.substr(0, length);
                result = chain + " " + result;
            }

            result = result.substr(0, result.length - 1);
            if (stringValue.length) {
                result = stringValue + " " + result;
            }

            return result;
        }
    },

    _latitudeLabel: {
        value: 0
    },

    _longitudeLabel: {
        value: 0
    },

    _metersPerPixel: {
        enumerable: false,
        writeable: false,
        get: function () {

            var latitude = this.center[1],
                zoom = this.zoom;

            return 156543.03392 * Math.cos(GeometryUtilities.toRadians(latitude)) / Math.pow(2, zoom);

        }
    },

    _pixelsPerInch: {
        enumerable: false,
        writeable: false,
        get: function () {
            if (this.__pixelsPerInch === null) {
                var element = document.createElement("DIV");
                element.style.width = "1in";
                element.style.padding = "0";
                this.element.appendChild(element);
                this.__pixelsPerInch = element.offsetWidth;
                this.element.removeChild(element);
            }
            return this.__pixelsPerInch;
        }
    },

    _position: {
        value: null
    },

    _scaleForValueInSet: {
        value: function (size, scaleSet) {
            for (var i = (scaleSet.length - 1); i >= 0; i--) {
                if (scaleSet[i] <= size) {
                    return scaleSet[i];
                }
            }
        }
    },

    _type: {
        value: OverlayType["Scale"]
    },

    _center: {
        value: [0, 0]
    },

    center: {
        get: function () {
            return this._center;
        },
        set: function (value) {
            if (value !== undefined && value !== this._center) {
                this._center = value;
                this.needsDraw = true;
            }
        }
    },

    draw: {
        value: function () {
            if (this.center && this.zoom) {

                var metersPerInch = this._metersPerPixel * this._pixelsPerInch,
                    feetPerInch = metersPerInch / 0.3048,
                    metricScale = this._scaleForValueInSet(metersPerInch, METRIC_SYSTEM_SET),
                    metricScaleLengthInPixels = Math.floor(((metricScale / metersPerInch) * this._pixelsPerInch)),
                    imperialScale = this._scaleForValueInSet(feetPerInch, IMPERIAL_SET),
                    imperialScaleLengthInPixels = Math.floor(((imperialScale / feetPerInch) * this._pixelsPerInch)),
                    scaleWidth = Math.max(metricScaleLengthInPixels, imperialScaleLengthInPixels) + 2;

                this.metricLabel = metricScale >= METERS_PER_KILOMETER ? Math.floor((metricScale / METERS_PER_KILOMETER)) + " km" : metricScale + " m";
                this.imperialLabel = imperialScale >= FEET_PER_MILE ? Math.floor((imperialScale / FEET_PER_MILE)) + " mi" : imperialScale + " ft";
                this.scaleLabel = "1 : " + this._groupNumbers(Math.floor((100 * metricScale / (metricScaleLengthInPixels * CENTIMETERS_PER_INCH / this._pixelsPerInch))));

                this.line.style.width = scaleWidth + "px";
                this.scale.style.width = scaleWidth + "px";
                this.metricTab.style.left = metricScaleLengthInPixels + "px";
                this.imperialTab.style.left = imperialScaleLengthInPixels + "px";
                this.latitudeLabel = this.center[1];
                this.longitudeLabel =this.center[0];
                this.element.style.marginLeft = -(this.element.offsetWidth / 2) + "px";
            }
        }
    },

    imperialLabel: {
        value: ""
    },

    imperialTab: {
        value: ""
    },

    line: {
        value: null
    },

    latitudeLabel: {
        get: function () {
            return this._latitudeLabel;
        },
        set: function (value) {
            this._latitudeLabel = Math.round(value * 1000) / 1000;
        }
    },

    longitudeLabel: {
        get: function () {
            return this._longitudeLabel;
        },
        set: function (value) {
            while (value > 180) {
                value -= 360;
            }
            while (value < -180) {
                value += 360;
            }
            this._longitudeLabel = Math.round(value * 1000) / 1000;
        }
    },

    metricLabel: {
        value: ""
    },

    metricTab: {
        value: ""
    },

    scale: {
        value: null
    },

    scaleLabel: {
        value: ""
    },

    _zoom: {
        value: 7
    },

    exportToJpeg: {
        value: function (context, exceptions) {
            var size = this.engine.size,
                width = size.width,
                height = size.height,
                startingPoint = { x: width / 2, y:height - 22 },
                metersPerPixel = this._metersPerPixel,
                metersPerInch = metersPerPixel * this._pixelsPerInch,
                metricScale = this._scaleForValueInSet(metersPerInch, METRIC_SYSTEM_SET),
                metricScaleLengthInPixels = Math.floor(((metricScale / metersPerInch) * this._pixelsPerInch)),
                metricText = this.metricLabel,
                scaleValue = "1 : " + this._groupNumbers(Math.floor((100 * metricScale / (metricScaleLengthInPixels * CENTIMETERS_PER_INCH / this._pixelsPerInch)))),
                feetPerInch = metersPerInch / 0.3048,
                imperialScale = this._scaleForValueInSet(feetPerInch, IMPERIAL_SET),
                imperialScaleLengthInPixels = Math.floor(((imperialScale / feetPerInch) * this._pixelsPerInch)),
                imperialText = imperialScale >= FEET_PER_MILE ? Math.floor((imperialScale / FEET_PER_MILE)) + " mi" : imperialScale + " ft",
                maxLength = 14;

            context.save();
            context.strokeStyle = "rgba(0, 0, 0, 1.0)";
            context.lineWidth = 1;
            context.fillStyle = "rgba(255, 255, 255, 1.0)";
            context.moveTo(startingPoint.x, startingPoint.y); // 1
            context.lineTo(startingPoint.x, startingPoint.y - 26); // 2
            context.lineTo(startingPoint.x + 2, startingPoint.y - 26); // 3
            context.lineTo(startingPoint.x + 2, startingPoint.y - 14); // 4
            context.lineTo(startingPoint.x + imperialScaleLengthInPixels, startingPoint.y - 14); // 5
            context.lineTo(startingPoint.x + imperialScaleLengthInPixels, startingPoint.y - 26); // 6
            context.lineTo(startingPoint.x + 2 + imperialScaleLengthInPixels, startingPoint.y - 26); // 7

            if (imperialScaleLengthInPixels > metricScaleLengthInPixels) {
                maxLength += startingPoint.x + 2 + imperialScaleLengthInPixels;
                context.lineTo(startingPoint.x + 2 + imperialScaleLengthInPixels, startingPoint.y - 14); // 8
                context.lineTo(startingPoint.x + 2 + imperialScaleLengthInPixels, startingPoint.y - 12);// 9
                context.lineTo(startingPoint.x + 2 + metricScaleLengthInPixels, startingPoint.y - 12); // 10
                context.lineTo(startingPoint.x + 2 + metricScaleLengthInPixels, startingPoint.y); // 11
            } else if (metricScaleLengthInPixels === imperialScaleLengthInPixels) {
                maxLength += startingPoint.x + 2 + imperialScaleLengthInPixels;
                context.lineTo(startingPoint.x + 2 + imperialScaleLengthInPixels, startingPoint.y);// 8
            } else {
                maxLength += startingPoint.x + metricScaleLengthInPixels + 2;
                context.lineTo(startingPoint.x + 2 + imperialScaleLengthInPixels, startingPoint.y - 14);// 8
                context.lineTo(startingPoint.x + metricScaleLengthInPixels + 2, startingPoint.y - 14); // 9
                context.lineTo(startingPoint.x + metricScaleLengthInPixels + 2, startingPoint.y); // 10
            }

            context.lineTo(startingPoint.x + metricScaleLengthInPixels, startingPoint.y);
            context.lineTo(startingPoint.x + metricScaleLengthInPixels, startingPoint.y - 12);
            context.lineTo(startingPoint.x + 2, startingPoint.y - 12);
            context.lineTo(startingPoint.x + 2, startingPoint.y);

            context.closePath();
            context.stroke();
            context.fill();
            context.restore();

            context.save();
            context.strokeStyle = "rgba(0, 0, 0, 1.0)";
            context.lineWidth = 1;
            context.fillStyle = "rgba(255, 255, 255, 1.0)";
            context.font = "9px sans-serif";
            context.fillText(imperialText, startingPoint.x + 8, startingPoint.y - 18);
            context.fillText(metricText, startingPoint.x + 8, startingPoint.y);
            context.fillText("SCALE", maxLength, startingPoint.y - 18);
            context.fillText(scaleValue, maxLength, startingPoint.y);
            context.fill();
            context.restore();
            return null;
        }
    },

    zoom: {
        get: function () {
            return this._zoom;
        },
        set: function (value) {
            if (value !== undefined && this._zoom !== value) {
                this._zoom = value;
                this.needsDraw = true;
            }
        }
    },

    position: {
        get: function () {
            return this._position;
        },
        set: function (value) {
            if (value && value !== this._position) {
                this._position = value;
                this.needsDraw = true;
            }
        }
    }
});
