/**
 * @module ui/map/mock-feature-overlay.reel
 * @requires montage/ui/component
 */
var LayerOverlayComponent = require("ui/map/layer-overlay-component").LayerOverlayComponent,
    FeatureClusterer = require("logic/map/feature-clusterer").FeatureClusterer,
    FeatureSelector = require("logic/mock-service/feature-selector").FeatureSelector,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    HazardSelector = require("logic/mock-service/hazard-selector").HazardSelector,
    Layer = require("logic/mock-model/layer").Layer,
    MapEngine = require("ui/map/map-engine").MapEngine,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    TrafficCameraSelector = require("logic/mock-service/traffic-camera-selector").TrafficCameraSelector;

/**
 * @class MockFeatureOverlay
 * Just to be used with old feature layers until the new service is ready.
 * @extends LayerOverlayComponent
 */
var MockFeatureOverlay = exports.MockFeatureOverlay = LayerOverlayComponent.specialize(/** @lends MockFeatureOverlay# */ {

    constructor: {
        value: function MockFeatureOverlay() {
            this.super();
        }
    },

    _processingBounds: {
        value: false
    },

    _cancelProcessing: {
        value: false
    },

    _clusterSymbols: {
        value: null
    },

    _clusterSymbolsToRemove: {
        value: null
    },

    _clustered: {
        value: null
    },

    _clusteredFeatures: {
        value: null
    },

    _clusterManager: {
        value: null
    },

    _currentBounds: {
        value: null
    },

    _deregister: {
        value: function () {
            this.super();
            this.clearSymbols();
            this._isRegistered = false;
            this._clusterManager = null;
            this.clusteredFeatures.length = 0;
            this.cancelBinding("engine");
            this.cancelBinding("currentZoom");
            this.cancelBinding("currentBounds");
        }
    },

    _drawClusters: {
        value: function () {
        }
    },

    _extentsStack: {
        value: null
    },

    _globalFeaturesRequested: {
        value: false
    },

    _layer: {
        value: null
    },

    _processBounds: {
        value: function (extent) {

            var selector = this._selector(extent);

            if (selector) {
                var self = this,
                    stream = this.application.mockService.query(selector);

                stream.then(function (features) {
                    self.processFeatures(features, function() {
                        self.processBounds();
                    });
                });
            }
        }
    },

    _queuedFeatures: {
        value: null
    },

    _isRegistered: {
        value: false
    },

    _register: {
        value: function () {
            this.super();
            console.log("Register...");
            if (this.mapComponent) {
                this.defineBinding("engine", {"<-": "mapEngine", "source": this._mapComponent});
                this.defineBinding("currentZoom", {"<-": "currentZoom", "source": this._mapComponent});
                this.defineBinding("currentBounds", {"<-": "bounds", "source": this._mapComponent});
            }
            this._isRegistered = true;
            this.redrawFeatures();
        }
    },

    _removeOldClusterSymbols: {
        value: false
    },

    _selector: {
        value: function (extent) {
            var selector;
            switch (this.layer.protocol) {
                case Layer.Protocol.AGS:
                    selector = new FeatureSelector(this.layer, extent, this.layer.projection, this.layer.units);
                    break;
                case Layer.Protocol.PDCHP:
                    selector = new HazardSelector(this.layer);
                    break;
                case Layer.Protocol.Camera:
                    selector = new TrafficCameraSelector(this.layer, extent);
                    break;
            }
            return selector;
        }
    },

    __shouldHideFeatures: {
        value: null
    },

    _shouldHideFeatures: {
        get: function () {
            if (this.__shouldHideFeatures === null) {
                this.__shouldHideFeatures = false;
            }
            return this.__shouldHideFeatures;
        },
        set: function (value) {
            this.__shouldHideFeatures = value;
        }
    },

    _shouldRecalculateClusters: {
        value: null
    },

    _symbols: {
        value: null
    },

    _symbolsToRemove: {
        value: null
    },

    _type: {
        value: OverlayType["Feature"]
    },

    clearSymbols: {
        value: function () {
            var features = this.symbols[this.engine.uuid],
                clusterSymbols = this.clusterSymbols[this.engine.uuid];
            for (var key in features) {
                this.engine.removeSymbol(features[key]);
                delete this.symbols[this.engine.uuid][key];
            }
            while(clusterSymbols.length > 0) {
                var clusterSymbol = clusterSymbols.pop();
                this.engine.removeSymbol(clusterSymbol);
            }
        }
    },

    clusterSymbolsToRemove: {
        enumerable: false,
        get: function () {
            if (this._clusterSymbolsToRemove === null) {
                this._clusterSymbolsToRemove = [];
            }
            return this._clusterSymbolsToRemove;
        }
    },

    clustered: {
        get: function () {
            if (this._clustered === null) {
                this._clustered = false;
            }
            return this._clustered;
        },
        set: function (value) {
            if (value !== null && value !== undefined && value !== this._clustered) {
                this._clustered = value;
                if (this.engine && this.engine.bounds) {
                    if (this.clustered) {
                        var symbolsToRemove = this.symbols[this.engine.uuid],
                            key;
                        for (key in symbolsToRemove) {
                            this.symbolsToRemove.push(symbolsToRemove[key]);
                        }
                        this.shouldRecalculateClusters = true;
                    } else {
                        var clusterSymbols = this.clusterSymbols[this.engine.uuid],
                            tempArray = clusterSymbols.splice(0, clusterSymbols.length);
                        this.clusterSymbolsToRemove.push.apply(this.clusterSymbolsToRemove, tempArray);
                        this.symbols[this.engine.uuid] = {};
                    }
                    this.redrawFeatures();
                }
            }
        }
    },

    clusteredFeatures: {
        get: function () {
            if (this._clusteredFeatures === null) {
                this._clusteredFeatures = [];
            }
            return this._clusteredFeatures;
        }
    },

    clusterManager: {
        writeable: false,
        enumerable: false,
        get: function () {
            if (this._clusterManager === null) {
                this._clusterManager = new FeatureClusterer(this, {
                    gridSize: this.layer.protocol === Layer.Protocol.PDCHP ? 160 : 60,
                    protocol: this.layer.protocol
                });
            }
            return this._clusterManager;
        }
    },

    clusterSymbols: {
        get: function () {
            if (this._clusterSymbols === null) {
                this._clusterSymbols = {};
            }
            return this._clusterSymbols;
        }
    },

    currentBounds: {

        get: function () {
            return this._currentBounds;
        },

        set: function (value) {
            if (value && value !== this._currentBounds) {
                this._currentBounds = value;
                if (this.layer && this.isVisible) {
                    if (this.layer.requestGlobalFeatures) {
                        if (this._globalFeaturesRequested === false) {
                            switch (this.layer.protocol) {
                                case Layer.Protocol.AGS:

                                    this.extentsStack.push({
                                        xmin: -180.0,
                                        ymin: -85.05112878,
                                        xmax: 180.0,
                                        ymax: 85.05112878
                                    });

                                    this.processBounds();
                                    break;

                                case Layer.Protocol.PDCHP:

                                    var selector = this._selector(),
                                        self = this,
                                        stream = this.application.mockService.query(selector);

                                    stream.then(function (hazards) {
                                        self.processFeatures(hazards);
                                    });

                                    break;
                            }
                            this._globalFeaturesRequested = true;
                        }
                    } else if (value !== null) {
                        this.extentsStack.push({
                            xmin: value.west,
                            ymin: value.south,
                            xmax: value.east,
                            ymax: value.north
                        });
                        if (this.extentsStack.length > 1) {
                            this.extentsStack.splice(0, 1);
                        }
                        if (this._processingBounds === false) {
                            this.processBounds();
                        }
                    }
                }
            }
        }
    },

    didZoom: {
        value: function () {
            if (this.layer && this.isVisible) {
                this.redrawFeatures();
            }
        }
    },

    draw: {
        value: function () {

            if (this._isRegistered && this.engine && this.engine.isInitialized) {

                var symbols, symbol, queuedFeature,
                    clusterSymbols = this.clusterSymbols[this.engine.uuid],
                    clusters, cluster, feature, i, length;

                while (this.symbolsToRemove.length > 0) {
                    symbol = this.symbolsToRemove.pop();
                    this.engine.removeSymbol(symbol);
                }

                while (this.queuedFeatures.length > 0) {
                    queuedFeature = this.queuedFeatures.pop();
                    if (this.symbols[this.engine.uuid] === undefined ||
                        this.symbols[this.engine.uuid][queuedFeature.id] === undefined) {
                        symbol = this.engine.drawFeature(queuedFeature);
                        this.symbols[this.engine.uuid][queuedFeature.id] = symbol;
                    }
                }

                if (this._shouldHideFeatures) {
                    this.clearSymbols();
                    this._shouldHideFeatures = false;
                }

                if (this.clustered === true) {
                    clusters = this.clusterManager.clusters;
                    for (i = 0, length = clusters.length; i < length; i++) {
                        cluster = clusters[i];
                        cluster.componentId = this.uuid;
                        if (cluster.features.length === 1) {
                            feature = cluster.features[0];
                            delete feature.properties.clusterCoordinate;
                            symbol = this.symbols[this.engine.uuid][feature.id];
                            if (symbol !== undefined) {
                                this.clusterSymbolsToRemove.push(symbol);
                                delete this.symbols[this.engine.uuid][feature.id];
                            }
                            feature.properties.componentId = this.uuid;
                            symbol = this.engine.drawFeature(feature);
                            this.symbols[this.engine.uuid][feature.id] = symbol;
                            if (feature.mapTip) {
                                feature.mapTip.position = feature.geometry.coordinates;
                            }
                        } else {
                            symbols = this.engine.drawCluster(this.layer.protocol, cluster);
                            while (symbols.length > 0) {
                                clusterSymbols.push(symbols.pop());
                            }
                        }
                    }
                }

                // Extra step to keep the cluster icons from blinking.
                if (this._removeOldClusterSymbols === true) {
                    while (this.clusterSymbolsToRemove.length > 0) {
                        symbol = this.clusterSymbolsToRemove.pop();
                        this.engine.removeSymbol(symbol);
                    }
                    this._removeOldClusterSymbols = false;
                } else if (this.clusterSymbolsToRemove.length > 0) {
                    this._removeOldClusterSymbols = true;
                    this.needsDraw = true;
                }

            } else {
                var self = this;
                setTimeout(function () {
                    self.needsDraw;
                }, 100);
            }
        }
    },

    engine: {
        get: function () {
            return this._engine;
        },
        set: function (value) {
            if (value && value !== this._engine) {
                if (this._globalFeaturesRequested === true) {
                    this._globalFeaturesRequested = false;
                    this.currentBounds = this._engine.bounds;
                }
                if (this._engine !== null) {
                    this.clearSymbols();
                    this._engine.removeOverlayComponent(this);
                }
                this._engine = value;
                if (this.layer) {
                    this.symbols[this._engine.uuid] = {};
                }
                this.clusterSymbols[this._engine.uuid] = [];
                this._engine.addOverlayComponent(this);
            }
        }
    },

    extentsStack: {
        get: function () {
            if (this._extentsStack === null) {
                this._extentsStack = [];
            }
            return this._extentsStack;
        }
    },

    hasTemplate: {
        value: true
    },

    isVisible: {
        get: function () {
            return this.layer.isVisibleAtZoom(this.engine.position.zoom);
        }
    },

    layer: {
        get: function () {
            return this._layer;
        },
        set: function (value) {
            if (value && value !== this._layer) {
                this._layer = value;
                if (this.getBinding("clustered")) {
                    this.cancelBinding("clustered");
                }
                if (this.getBinding("enabled")) {
                    this.cancelBinding("enabled");
                }
                this.defineBinding("clustered", {"<-": "clustered", "source": this._layer});
                this.defineBinding("enabled", {"<-": "enabled", "source": this._layer});
                // to make sure it initializes the current bounds.
                if (this.engine.bounds) {
                    var bounds = this.mapComponent.bounds;
                    this.extentsStack.push({
                        xmin: bounds.west,
                        ymin: bounds.south,
                        xmax: bounds.east,
                        ymax: bounds.north
                    });
                    this.processBounds();
                }
                this.symbols[this.engine.uuid] = {};
            }
        }
    },

    processBounds: {
        value: function () {
            if (this.extentsStack.length > 0 && this.layer) {
                this._processingBounds = true;
                var extent = this.extentsStack.pop();
                // Crossing anti-meridian so creating two requests...
                if (extent.xmin > extent.xmax) {
                    var westExtent = {
                        xmin: extent.xmin,
                        xmax: 179.99999,
                        ymin: extent.ymin,
                        ymax: extent.ymax
                    };
                    extent.xmin = -179.99999;
                    this._processBounds(westExtent);
                    this._processBounds(extent);
                } else {
                    this._processBounds(extent);
                }
            } else {
                this._processingBounds = false;
            }
        }
    },

    processFeatures: {
        value: function (features, callback) {
            var i, length;
            for (i = 0, length = features.length; i < length; i++) {
                var feature = features[i];
                feature.properties.componentId = this.uuid;
                if (this.clustered && (feature.geometry.type === "Point" || feature.geometry.type === "MultiPoint")) {
                    this.clusterManager.addFeature(feature);
                } else {
                    this.queuedFeatures.push(feature);
                }
            }

            if (length > 0) {
                if (this.clustered) {
                    this.shouldRecalculateClusters = true;
                }
                this.needsDraw = true;
            }
            if (callback) {
                callback();
            }
        }
    },

    queuedFeatures: {
        writeable: false,
        enumerable: false,
        get: function () {
            if (this._queuedFeatures === null) {
                this._queuedFeatures = [];
            }
            return this._queuedFeatures;
        }
    },

    redrawFeatures: {
        value: function () {
            var features = this.layer.features;
            if (Object.keys(features).length > 0) {
                var feature, key,
                    bounds = this.engine.bounds,
                    bbox = [bounds.west, bounds.south, bounds.east, bounds.north];
                for (key in features) {
                    feature = features[key];
                    if (this.clustered && (feature.geometry.type === "Point" || feature.geometry.type === "MultiPoint")) {
                        this.clusterManager.addFeature(feature);
                    } else {
                        if (this.layer.requestGlobalFeatures || GeometryUtilities.boundingBoxContainsFeature(bbox, feature)) {
                            this.queuedFeatures.push(feature);
                        }
                    }
                }
                this.shouldRecalculateClusters = this.clustered;
                this.needsDraw = true;
            }
        }
    },

    shouldRecalculateClusters: {
        enumerable: false,
        get: function () {
            if (this._shouldRecalculateClusters === null) {
                this._shouldRecalculateClusters = false;
            }
            return this._shouldRecalculateClusters;
        },
        set: function (value) {
            this._shouldRecalculateClusters = value;
        }
    },

    symbols: {
        enumerable: true,
        writeable: false,
        get: function () {
            //if (this._symbols === null) {
            //    this._symbols = {};
            //}
            //return this._symbols;
            return this.layer.symbols;
        }
    },

    symbolsToRemove: {
        writeable: false,
        get: function () {
            if (this._symbolsToRemove === null) {
                this._symbolsToRemove = [];
            }
            return this._symbolsToRemove;
        }
    },

    willDraw: {
        value: function () {
            if (this.clustered && this.shouldRecalculateClusters) {
                var clusterSymbols = this.clusterSymbols[this.engine.uuid],
                    symbols = clusterSymbols.splice(0, clusterSymbols.length);
                this._removeOldClusterSymbols = false;
                this.clusterSymbolsToRemove.push.apply(this.clusterSymbolsToRemove, symbols);
                this.clusterManager.recalculateClusters();
                this.shouldRecalculateClusters = false;
            }
        }
    },

    willZoom: {
        value: function () {
            this.clearSymbols();
        }
    }

}, {});
