/**
 * @module ui/map/tile-overlay.reel
 * @requires ui/map/overlay-component
 */
var LayerOverlayComponent = require("ui/map/layer-overlay-component").LayerOverlayComponent,
    MapEngine = require("ui/map/map-engine").MapEngine,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    Tile = require("logic/model/tile").Tile,
    TileService = require("logic/service/tile-service").TileService;

/**
 * @class TileOverlay
 * @extends LayerOverlayComponent
 */
var TileOverlay = exports.TileOverlay = LayerOverlayComponent.specialize(/** @lends TileOverlay# */ {

    constructor: {
        value: function TileOverlay() {
            this.super();
        }
    },

    _addElementsToTileOverlay: {

        value: function (count) {
            var i, fragment, image, imageContainer;

            if (count === undefined) {
                count = Math.ceil(this._size.width / 256) * Math.ceil(this._size.height / 256);
            }

            fragment = document.createDocumentFragment();

            for (i = 0; i <= count; i++) {

                image = new Image();
                image.src = this._defaultImage;
                image.setAttribute("draggable", "false");
                image.setAttribute("class", "contour-TileOverlay-imageElement");
                fragment.appendChild(image);
                this._imagePool.push(image);
            }

            this.element.appendChild(fragment);
        }
    },

    _animateTile: {
        value: function (tile) {
            tile.element.style.opacity = tile.enable ? 1 : this.availableTimes.length === 0 ? 0 : 1;
        }
    },

    _animationDisabled: {
        value: false
    },

    _availableTimes: {
        value: null
    },

    _cancelAvailableTimesRangeChangeListener: {
        value: null
    },

    _compareTiles: {
        value: function (a, b) {
            var y = b.y - a.y;
            return y == 0 ? a.positions[0].x - b.positions[0].x : y;
        }
    },

    _compareTilesRequiringAnimation: {
        value: function (a, b) {
            return (a.enable === b.enable) ? 0 : a ? -1 : 1;
        }
    },

    _currentMoment: {
        value: null
    },

    _currentTime: {
        value: null
    },

    /**
     * A transaprent image.  Used to hide tiles
     */
    _defaultImage: {
        value: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAHCGzyUAAAAC0lEQVQI12P4zwAAAgEBAKrChTYAAAAASUVORK5CYII="
    },

    _deregister: {
        value: function () {
            if (this._layer && this._engine) {
                this._engine.removeOverlayComponent(this);
                if (this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
                if (this.layer.availableTimes) {
                    this.animationController.removeAvailableTimes(this.layer.availableTimes);
                    this._availableTimes = null;
                }
                if (this._cancelAvailableTimesRangeChangeListener) {
                    this._cancelAvailableTimesRangeChangeListener();
                    this._cancelAvailableTimesRangeChangeListener = null;
                }
                if (this.getBinding("availableTimes")) {
                    this.cancelBinding("availableTimes");
                }
                this._isRegistered = false;
            }
        }
    },

    _drawTimer: {
        value: null
    },

    _getOrCreateTile: {
        value: function (x, y, zoom, moment) {

            var tile, tileRange = Math.pow(2, zoom), identifier;

            if (y < 0 || y >= tileRange) {
                return false;
            }

            if (x < 0 || x >= tileRange) {
                x = (x % tileRange + tileRange) % tileRange;
            }

            if (moment) {
                identifier = x + ':' + y + ':' + zoom + ":" + moment.unix();
            } else {
                identifier = x + ':' + y + ':' + zoom;
            }
            if (this._tileRegistry[identifier] === undefined) {
                tile = Tile.create(x, y, zoom, moment);
                this._tileRegistry[tile.id] = tile;
                this.requestTile(tile);
            } else {
                tile = this._tileRegistry[identifier];
            }

            return tile;
        }
    },

    __imagePool: {
        value: null
    },

    _imagePool: {
        enumerable: false,
        writeable: false,
        get: function () {
            if (this.__imagePool === null) {
                this.__imagePool = [];
            }
            return this.__imagePool;
        }
    },

    _incrementNextTimeTileCounter: {
        value: function () {
            this._nextTimeTileCountsReceived++;
            if (this._nextTimeTileCountsReceived >= this._nextTileCount) {
                this.animationController.release(this);
            }
        }
    },

    _isRegistered: {
        value: false
    },

    __needsTilePruning: {
        value: null
    },

    _needsTilePruning: {
        enumerable: false,
        get: function () {
            if (this.__needsTilePruning === null) {
                this.__needsTilePruning = false;
            }
            return this.__needsTilePruning;
        },
        set: function (value) {
            this.__needsTilePruning = value;
        }
    },

    _nextMoment: {
        value: null
    },

    _nextTime: {
        value: null
    },

    _nextTimeTileCountsReceived: {
        value: 0
    },

    __queuedTiles: {
        value: null
    },

    _queuedTiles: {
        enumerable: false,
        get: function () {
            if (this.__queuedTiles === null) {
                this.__queuedTiles = [];
            }
            return this.__queuedTiles;
        },
        set: function (values) {
            if (values && values !== this.__queuedTiles) {
                this.__queuedTiles = values;
            }
        }
    },

    _placeTile: {
        value: function (value) {

            var tile = this._tileRegistry[value.id],
                position, i, n, imageElement;

            if (tile === undefined) {
                return;
            }

            tile.src = value.src;

            for (i = 0, n = tile.positions.length; i < n; i++) {
                position = tile.positions[i];
                if (position.element === undefined) {
                    if (this._imagePool.length === 0) {
                        this._addElementsToTileOverlay(1);
                    }

                    imageElement = this._imagePool.pop();
                    imageElement.src = tile.src;
                    position.element = imageElement;

                    this._tilesRequiringAnimation.push({element: imageElement, enable: true});
                }
            }
        }
    },

    _placeTileInDrawQueue: {
        value: function (tile) {
            if (this._tileRegistry[tile.id] !== undefined) {
                this._queuedTiles.push(tile);
                this._startDrawingTimer();
            }
        }
    },

    _positionImage: {
        value: function (tile, position, image) {
            var position = this.engine.tilePosition(tile, position, this._tileBounds.origin,
                this._tileBounds.minX, this._tileBounds.minY);
            image.style.left = position.left;
            image.style.top = position.top;
        }
    },

    _positionTiles: {
        value: function () {

            var tile, tiles, position, i, length, self = this;

            tiles = Object.keys(this._tileRegistry).map(function (key) {
                return self._tileRegistry[key];
            });

            tiles.sort(this._compareTiles);

            while (tiles.length > 0) {
                tile = tiles.pop();
                for (i = 0, length = tile.positions.length; i < length; i++) {
                    position = tile.positions[i];
                    if (position.element) {
                        this._positionImage(tile, position, position.element);
                    }
                }
            }
        }
    },

    _pruneTiles: {
        value: function () {
            var i, length = this.element.childNodes.length - this._tileCount;
            for (i = 0; i < length; i++) {
                if (this._imagePool.length > 0) {
                    var image = this._imagePool.pop();
                    if (image) {
                        this.element.removeChild(image);
                    }
                } else {
                    break;
                }
            }
        }
    },

    _reclaimImages: {
        value: function (forceRemoval) {
            var key, tile, position, i, element, positionIndex;
            for (key in this._tileRegistry) {
                tile = this._tileRegistry[key];
                for (i = tile.positions.length; i > 0; i--) {
                    positionIndex = i - 1;
                    position = tile.positions[positionIndex];
                    if ((forceRemoval || position.retain === false) && position.element) {
                        element = position.element;
                        element.src = this._defaultImage;
                        this._tilesRequiringAnimation.push({element: element, enable: false});
                        this._imagePool.push(element);
                        tile.positions.splice(positionIndex, 1);
                    }
                }

                // if a tile has no positions on the screen
                // remove it from registry.
                if (tile.positions.length === 0) {
                    delete this._tileRegistry[tile.id];
                }
            }
        }
    },

    /**
     Overloaded because the component's element
     can get added to the map's overlay and then it gets
     moved to be the child of the parent slot.  Which causes
     chaos to occur!
     */
    _register: {
        value: function () {
            this.__tileRegistry = {};
            this._shouldRegister = true;
            this.needsDraw = true;
        }
    },

    __requiresInitialization: {
        value: false
    },

    _requiresInitialization: {
        enumerable: false,
        get: function () {
            if (this.__requiresInitialization === null) {
                this.__requiresInitialization = false;
            }
            return this.__requiresInitialization;
        },
        set: function (value) {
            this.__requiresInitialization = value;
        }
    },

    _shouldRegister: {
        value: false
    },

    _size: {
        get: function () {
            return this.engine.size;
        }
    },

    _startDrawingTimer: {
        value: function () {
            if (this._drawTimer === null) {
                var self = this;
                setTimeout(function () {
                    self.needsDraw = true;
                    self._drawTimer = null;
                }, 200);
            }

        }
    },

    __tileBounds: {
        value: null
    },

    _tileBounds: {
        get: function () {
            return this.__tileBounds;
        },
        set: function (value) {
            if (value && value !== this.__tileBounds) {
                this.__tileBounds = value;
                this._updateRegistry(
                    value.minX,
                    value.minY,
                    value.maxX,
                    value.maxY,
                    value.zoom
                );
            }
        }
    },

    __tileCount: {
        value: null
    },

    _tileCount: {
        get: function () {
            if (this.__tileCount === null) {
                this.__tileCount = 0;
            }
            return this.__tileCount;
        },
        set: function (value) {
            this.__tileCount = value;
        }
    },

    _timestamps: {
        value: null
    },

    __tileRegistry: {
        value: null
    },

    _tileRegistry: {
        enumerable: false,
        writeable: false,
        get: function () {
            if (this.__tileRegistry === null) {
                this.__tileRegistry = {};
            }
            return this.__tileRegistry;
        }
    },

    __tilesRequiringAnimation: {
        value: null
    },

    _tilesRequiringAnimation: {
        enumerable: false,
        writeable: false,
        get: function () {
            if (this.__tilesRequiringAnimation === null) {
                this.__tilesRequiringAnimation = [];
            }
            return this.__tilesRequiringAnimation;
        }
    },

    _opacity: {
        value: 1.0
    },

    _type: {
        value: OverlayType["Tile"]
    },

    _updateAvailableTimes: {
        value: function () {
            this.availableTimes.sort(function (a, b) {
                return a.unix() - b.unix();
            });
            this.timestamps.length = 0;
            for (var i = 0, n = this.availableTimes.length; i < n; ++i) {
                this.timestamps.push(this.availableTimes[n].unix());
            }
            this.currentTime = this.animationController.currentTime;
            this.nextTime = this.animationController.nextTime;
        }
    },

    // update the registry fo tiles.
    // a tile may have more than one position.
    // mark each position for removal and then
    // determine which ones to keep.
    _updateRegistry: {
        value: function (minX, minY, maxX, maxY, zoom) {

            var i, j, length, length2, key, tile;

            this._tileCount = 0;
            this._nextTileCount = 0;
            this._nextTimeTileCountsReceived = 0;
            // set all tile positions retain property to false.
            for (key in this._tileRegistry) {
                tile = this._tileRegistry[key];
                tile.count = 0;
                for (i = 0, length = tile.positions.length; i < length; i++) {
                    tile.positions[i].retain = false;
                }
            }

            // identify tiles in bounds (as new or pre-existing)
            for (j = minY, length = maxY; j <= length; j++) {
                for (i = minX, length2 = maxX; i <= length2; i++) {
                    if (this.availableTimes.length > 0 && this.currentTime !== undefined) {
                        tile = this._getOrCreateTile(i, j, zoom, this._currentMoment);
                        if (tile) {
                            this._updateTilePositions(tile, i);
                            this._tileCount++;
                        }
                    } else {
                        tile = this._getOrCreateTile(i, j, zoom);
                        if (tile) {
                            this._updateTilePositions(tile, i);
                            this._tileCount++;
                        }
                    }
                }
            }
            // loop twice to given current time tiles priority over the next time.
            if (this.availableTimes.length > 0 && this.nextTime !== undefined) {
                for (j = minY, length = maxY; j <= length; j++) {
                    for (i = minX, length2 = maxX; i <= length2; i++) {
                        tile = this._getOrCreateTile(i, j, zoom, this._nextMoment);
                        if (tile) {
                            this._updateTilePositions(tile, i);
                            this._nextTileCount++;
                            if (tile.src) {
                                this._incrementNextTimeTileCounter();
                            }
                        }
                    }
                }
            }

            this._reclaimImages(false);
            this._needsTilePruning = true;
            this.needsDraw = true;

        }
    },

    _updateTilePositions: {
        value: function (tile, position) {
            var count = tile.count;
            if (tile.positions[count] === undefined) {
                tile.positions[count] = {
                    element: undefined,
                    retain: true,
                    x: position
                };
            } else {
                tile.positions[count].x = position;
                tile.positions[count].retain = true;
            }
            tile.count++;
        }
    },

    __wasInitialized: {
        value: false
    },

    _wasInitialized: {
        enumerable: false,
        writeable: true,
        get: function () {
            if (this.__wasInitialized === null) {
                this.__wasInitialized = false;
            }
            return this.__wasInitialized;
        },
        set: function (value) {
            this.__wasInitialized = value;
        }
    },

    animationStatus: {
        value: null
    },

    availableTimes: {
        get: function () {
            if (this._availableTimes === null) {
                this._availableTimes = [];
            }
            return this._availableTimes;
        },
        set: function (values) {
            if (values && values !== this._availableTimes) {
                this._availableTimes = values;
                var self = this;
                    animationController = this.animationController;
                animationController.addAvailableTimes(this._availableTimes);
                this._cancelAvailableTimesRangeChangeListener =
                    this._availableTimes.addRangeChangeListener(function (plus, minus, index) {
                        animationController.removeAvailableTimes(minus);
                        animationController.addAvailableTimes(plus);
                        while (minus.length > 0) {
                            var moment = minus.pop(),
                                index = self.availableTimes.indexOf(moment);
                            if (index > -1) {
                                self.availableTimes.splice(index, 1);
                            }
                        }
                        if (plus.length > 0) {
                            self.availableTimes = self.availableTimes.concat(plus);
                        }
                        self._updateAvailableTimes();
                    });
                for (var i = 0, n = this._availableTimes.length; i < n; i++) {
                    this.timestamps.push(this._availableTimes[i].unix());
                }
                this.animationController.addAvailableTimes(values);
            }
        }
    },

    currentTime: {
        get: function () {
            return this._currentTime;
        },
        set: function (value) {
            var timeChanged = false;
            if (value && value !== this._currentTime) {
                if (this.timestamps.indexOf(value) > -1) {
                    this._currentTime = value;
                    timeChanged = true;
                } else {
                    var i, currentTime;
                    for (i = this.timestamps.length - 1; i >= 0; i--) {
                        if (this.timestamps[i] < value) {
                            currentTime = this.timestamps[i];
                            break;
                        }
                    }
                    if (currentTime && currentTime !== this._currentTime) {
                        this._currentTime = currentTime;
                        timeChanged = true;
                    } else if (! currentTime) {
                        this._currentTime = undefined;
                        this._currentMoment = undefined;
                        this._reclaimImages(true);
                    }
                }
                // TODO add logic of placing next tiles.
                if (timeChanged) {
                    this._currentMoment = this.availableTimes[this.timestamps.indexOf(this._currentTime)];
                    // do something...
                }
            }
        }
    },

    draw: {

        value: function () {

            var nextTimeTileQueue = [];

            if (this._shouldRegister) {
                if (this.layer && this.engine) {
                    this.engine.addOverlayComponent(this);
                    this._shouldRegister = false;
                    if (this.layer.availableTimes) {
                        this.availableTimes = this.layer.availableTimes;
                    }
                }
            }

            if (this._requiresInitialization) {
                this._addElementsToTileOverlay();
                this._requiresInitialization = false;
                this._wasInitialized = true;
                this.element.style.zIndex = this.layer.depth;
            }

            if (this._wasInitialized && this._isRegistered) {

                this._tilesRequiringAnimation.sort(this._compareTilesRequiringAnimation);

                while (this._tilesRequiringAnimation.length > 0) {
                    this._animateTile(this._tilesRequiringAnimation.shift());
                }

                while (this._queuedTiles.length > 0) {
                    if (this.availableTimes.length > 0) {

                        var queuedObject = this._queuedTiles.pop(),
                            tile = this._tileRegistry[queuedObject.id];

                        if (tile) {
                            if (this._currentMoment && tile.time === this._currentMoment.unix()) {
                                this._placeTile(queuedObject);
                            } else {
                                nextTimeTileQueue.push(queuedObject);
                            }
                        }
                    } else {
                        this._placeTile(this._queuedTiles.pop());
                    }
                }

                if (this.engine.isInitialized) {
                    this._positionTiles();
                }

                if (this._needsTilePruning) {
                    this._pruneTiles();
                }
            }

            if (this._queuedTiles.length > 0 || this._tilesRequiringAnimation.length > 0) {
                this._startDrawingTimer();
            }

            this._queuedTiles = nextTimeTileQueue;
            this.element.style.opacity = this.opacity;

        }
    },

    engine: {
        get: function () {
            return this._engine;
        },
        set: function (value) {
            if (value && value !== this._engine) {
                if (this._engine) {
                    this._engine.removeOverlayComponent(this);
                    this.cancelBinding("_tileBounds");
                }
                this._engine = value;
                this._register();
                this.defineBinding("_tileBounds", {"<-": "tileBounds", "source": this._engine});
            }
        }
    },

    hasTemplate: {
        value: true
    },

    initialize: {
        value: function () {
            this.engine.appendElementToOverlayPaneWithId(this.element, "TileLayer");
            if (this._wasInitialized === false) {
                this._requiresInitialization = true;
            }
            this._tileBounds = this.engine.tileBounds;
            this._isRegistered = true;
            this.needsDraw = true;
        }
    },

    layer: {
        get: function () {
            return this._layer;
        },
        // In current implementation a new overlay is created
        // every time a layer is added to the list of enabled
        // layers.  So it's not really necessary to add the tear
        // down of a layer changing.  But placing it here just
        // in case we start pooling the layer overlays.
        // ^^ Actually - I reverse myself.  Somehow it is magically
        // caching the components...
        set: function (value) {
            if (value && value !== this._layer) {
                if (this._cancelAvailableTimesRangeChangeListener) {
                    this._cancelAvailableTimesRangeChangeListener();
                    this._cancelAvailableTimesRangeChangeListener = null;
                    this.animationController.removeAvailableTimes(this._layer.availableTimes);
                    this.timestamps.length = 0;
                }
                this._layer = value;
                if (this._layer.canAnimate) {
                    this.defineBinding("availableTimes", {"<-": "availableTimes", "source": this._layer});
                    if (this.getBinding("currentTime")) {
                        this.cancelBinding("currentTime");
                        this.cancelBinding("nextTime");
                        this.cancelBinding("animationStatus");
                    }
                    this.defineBinding("currentTime", {"<-": "currentTime", "source": this.animationController});
                    this.defineBinding("nextTime", {"<-": "nextTime", "source": this.animationController});
                    this.defineBinding("animationStatus", {"<-": "status", "source": this.animationController});
                }
                if (this.element) {
                    this.element.style.zIndex = this._layer.depth;
                }
                if (this.getBinding("opacity")) {
                    this.cancelBinding("opacity");
                }
                if (this.getBinding("enabled")) {
                    this.cancelBinding("enabled");
                }
                this.defineBinding("opacity", {"<-": "opacity", "source": this._layer});
                this.defineBinding("enabled", {"<-": "isEnabled", "source": this._layer});
            }
        }
    },

    nextTime: {
        get: function () {
            return this._nextTime;
        },
        set: function (value) {
            if (value && value !== this._nextTime) {
                var valueChanged = false;
                if (this.timestamps.indexOf(value) > -1) {
                    this.animationController.lock(this);
                    this._nextTime = value;
                    valueChanged = true;
                } else if (this.currentTime === undefined) {
                    this._nextTime === undefined;
                    valueChanged = true;
                } else {
                    var index = this.timestamps.indexOf(this.currentTime),
                        nextTime;
                    if (index + 1 < this.timestamps.length) {
                        nextTime = this.timestamps[index + 1];
                    }
                    if (nextTime && nextTime !== this._nextTime) {
                        this._nextTime = nextTime;
                        valueChanged = true;
                    }
                }

                if (valueChanged) {
                    // TODO add logic of request next set of tiles.
                    this._nextMoment = this.availableTimes[this.timestamps.indexOf(this._nextTime)];
                    this._animationDisabled = true;
                    if (this._tileBounds) {
                        this._updateRegistry(
                            this._tileBounds.minX,
                            this._tileBounds.minY,
                            this._tileBounds.maxX,
                            this._tileBounds.maxY,
                            this._tileBounds.zoom
                        );
                    }
                }
            }
        }
    },

    mapComponent: {
        get: function () {
            return this._mapComponent;
        },
        set: function (value) {
            if (value) {
                this._mapComponent = value;
                this.defineBinding("engine", {"<-": "mapEngine", "source": this._mapComponent});
            }
        }
    },

    requestTile: {
        value: function (tile) {
            if (this.layer) {
                var self = this;
                TileService.fetchTileImage(tile, this.layer).then(function () {
                    self._placeTileInDrawQueue(tile);
                    if (self.layer.availableTimes) {
                        if (tile.moment === self._nextMoment) {
                            self._incrementNextTimeTileCounter();
                        }
                    }
                });
            }
        }
    },

    timestamps: {
        get: function () {
            if (this._timestamps === null) {
                this._timestamps = [];
            }
            return this._timestamps;
        }
    },

    opacity: {
        get: function () {
            return this._opacity;
        },
        set: function (value) {
            if (this._opacity !== value) {
                this._opacity = value;
                this.needsDraw = true;
            }
        }
    },

    willZoom: {
        value: function () {
            this._reclaimImages(true);
            for (var key in this._tileRegistry) {
                delete this._tileRegistry[key];
            }
        }
    }

});
