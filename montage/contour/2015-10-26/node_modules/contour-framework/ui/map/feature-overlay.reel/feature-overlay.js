var LayerOverlayComponent = require("ui/map/layer-overlay-component").LayerOverlayComponent,
    FeatureClusterer = require("logic/map/feature-clusterer").FeatureClusterer,
    FeatureSelector = require("logic/mock-service/feature-selector").FeatureSelector,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    HazardSelector = require("logic/mock-service/hazard-selector").HazardSelector,
    MapEngine = require("ui/map/map-engine").MapEngine,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    Protocol = require("logic/model/protocol").Protocol,
    Set = require("collections/set"),
    TrafficCameraSelector = require("logic/mock-service/traffic-camera-selector").TrafficCameraSelector;

/**
 * @class FeatureOverlay
 * @extends LayerOverlayComponent
 */
var FeatureOverlay = exports.FeatureOverlay = LayerOverlayComponent.specialize(/** @lends FeatureOverlay# */ {

    constructor: {
        value: function FeatureOverlay() {
        }
    },

    _addFeatures: {
        value: function (features) {
            if (this.isClustering) {
                this.clusterManager.addFeature.apply(this.clusterManager, features);
            } else {
                this.queuedFeatures.push.apply(this.queuedFeatures, features);
            }
            if (features.length > 0) {
                if (this.isClustering) {
                    this.shouldRecalculateClusters = true;
                }
                this.needsDraw = true;
            }

        }
    },

    _clusterSymbols: {
        value: null
    },

    _clusterSymbolsToRemove: {
        value: null
    },

    _clusteredFeatures: {
        value: null
    },

    _clusterManager: {
        value: null
    },

    _deregister: {
        value: function () {
            this.super();
            this.clearSymbols();
            if (this._rangeChangeListenerCanceller) {
                this._rangeChangeListenerCanceller();
                this._rangeChangeListenerCanceller = null;
            }
        }
    },

    _isClustering: {
        value: null
    },

    _layer: {
        value: null
    },

    _opacity: {
        value: 1.0
    },

    _queuedFeatures: {
        value: null
    },

    _rangeChangeListenerCanceller: {
        value: undefined
    },

    _register: {
        value: function () {
            var self = this;
            LayerOverlayComponent.prototype._register.call(this);
            if (this._layer.areFeaturesGlobal) {
                this._rangeChangeListenerCanceller = this._layer.features.all.addRangeChangeListener(function (plus, minus) {
                    self._addFeatures(plus);
                    self._removeFeatures(minus, plus, false);
                });
            } else {
                this._rangeChangeListenerCanceller = this._layer.features.visible.addRangeChangeListener(function (plus, minus) {
                    self._addFeatures(plus);
                    self._removeFeatures(minus, plus, true);
                });
            }
            this._addFeatures(this._layer.areFeaturesGlobal ? this._layer.features.all : this._layer.features.visible);
        }
    },

    _removeFeatures: {
        value: function (featuresToRemove, featuresAdded, shouldDeregisterFeatures) {
            var ignoredIds, feature, symbol, i, n;
            ignoredIds = new Set();
            for (i = 0, n = featuresAdded.length; i < n; ++i) {
                ignoredIds.add(featuresAdded[i].id);
            }
            for (i = 0, n = featuresToRemove.length; i < n; ++i) {
                feature = featuresToRemove[i];
                symbol = !ignoredIds.has(feature.id) && this.symbols[this.engine.uuid][feature.id];
                if (symbol) {
                    this.symbolsToRemove.push(symbol);
                    this.needsDraw = true;
                    shouldDeregisterFeatures && (delete this.symbols[this.engine.uuid][feature.id]);
                }
            }
        }
    },

    _removeOldClusterSymbols: {
        value: false
    },

    _shouldRecalculateClusters: {
        value: null
    },

    _symbols: {
        value: null
    },

    _symbolsToRemove: {
        value: null
    },

    _type: {
        value: OverlayType["Feature"]
    },

    _shouldUpdateSymbolsOpacity: {
        value: false
    },

    clearSymbols: {
        value: function () {
            var features = this.symbols[this.engine.uuid],
                clusterSymbols = this.clusterSymbols[this.engine.uuid];
            for (var key in features) {
                this.engine.removeSymbol(features[key]);
                delete this.symbols[this.engine.uuid][key];
            }
            while(clusterSymbols.length > 0) {
                var clusterSymbol = clusterSymbols.pop();
                this.engine.removeSymbol(clusterSymbol);
            }
        }
    },

    clusterSymbolsToRemove: {
        enumerable: false,
        get: function () {
            if (this._clusterSymbolsToRemove === null) {
                this._clusterSymbolsToRemove = [];
            }
            return this._clusterSymbolsToRemove;
        }
    },

    isClustering: {
        get: function () {
            if (this._isClustering === null) {
                this._isClustering = false;
            }
            return this._isClustering;
        },
        set: function (value) {
            if (value !== null && value !== undefined && value !== this._isClustering) {
                this._isClustering = value;
                if (this.engine) {
                    if (this._isClustering) {
                        var symbolsToRemove = this.symbols[this.engine.uuid],
                            key;
                        for (key in symbolsToRemove) {
                            this.symbolsToRemove.push(symbolsToRemove[key]);
                        }
                        this.shouldRecalculateClusters = true;
                    } else {
                        var clusterSymbols = this.clusterSymbols[this.engine.uuid],
                            tempArray = clusterSymbols.splice(0, clusterSymbols.length);
                        this.clusterSymbolsToRemove.push.apply(this.clusterSymbolsToRemove, tempArray);
                        this.symbols[this.engine.uuid] = {};
                    }
                    this.redrawFeatures();
                }
            }
        }
    },

    clusteredFeatures: {
        get: function () {
            if (this._clusteredFeatures === null) {
                this._clusteredFeatures = [];
            }
            return this._clusteredFeatures;
        }
    },

    clusterManager: {
        writeable: false,
        enumerable: false,
        get: function () {
            if (this._clusterManager === null) {
                this._clusterManager = new FeatureClusterer(this, {
                    gridSize: this.layer.mapService.protocol === Protocol.HAZARD ? 160 : 60,
                    protocol: this.layer.mapService.protocol
                });
            }
            return this._clusterManager;
        }
    },

    clusterSymbols: {
        get: function () {
            if (this._clusterSymbols === null) {
                this._clusterSymbols = {};
            }
            return this._clusterSymbols;
        }
    },

    didZoom: {
        value: function () {
            if (this.layer && this.isVisible) {
                this.redrawFeatures();
            }
        }
    },

    draw: {
        value: function () {
            if (this.engine && this.engine.isInitialized) {

                var symbols, symbol, queuedFeature,
                    clusterSymbols = this.clusterSymbols[this.engine.uuid],
                    clusters, cluster, feature, i, length, key;

                while (this.symbolsToRemove.length > 0) {
                    symbol = this.symbolsToRemove.pop();
                    this.engine.removeSymbol(symbol);
                }

                while (this.queuedFeatures.length > 0) {
                    queuedFeature = this.queuedFeatures.pop();
                    queuedFeature.properties.componentId = this.uuid;
                    if (this.symbols[this.engine.uuid] === undefined ||
                        this.symbols[this.engine.uuid][queuedFeature.id] === undefined) {
                        symbol = this.engine.drawFeature(queuedFeature);
                        this.symbols[this.engine.uuid][queuedFeature.id] = symbol;
                    }
                }
                if (this._shouldUpdateSymbolsOpacity) {
                    for (key in this.symbols[this.engine.uuid]) {
                        this.engine.updateSymbolLayerOpacity(this.symbols[this.engine.uuid][key], this.opacity);
                    }
                }

                if (this.isClustering === true) {
                    clusters = this.clusterManager.clusters;
                    for (i = 0, length = clusters.length; i < length; i++) {
                        cluster = clusters[i];
                        cluster.componentId = this.uuid;
                        if (cluster.features.length === 1) {
                            feature = cluster.features[0];
                            delete feature.properties.clusterCoordinate;
                            symbol = this.symbols[this.engine.uuid][feature.id];
                            if (symbol !== undefined) {
                                this.clusterSymbolsToRemove.push(symbol);
                                delete this.symbols[this.engine.uuid][feature.id];
                            }
                            symbol = this.engine.drawFeature(feature);
                            this.symbols[this.engine.uuid][feature.id] = symbol;
                            if (feature.mapTip) {
                                feature.mapTip.position = feature.geometry.coordinates;
                            }
                        } else {
                            symbols = this.engine.drawCluster(this.layer.mapService.protocol, cluster);
                            while (symbols.length > 0) {
                                clusterSymbols.push(symbols.pop());
                            }
                        }
                    }
                }

                // Extra step to keep the cluster icons from blinking.
                if (this._removeOldClusterSymbols === true) {
                    while (this.clusterSymbolsToRemove.length > 0) {
                        symbol = this.clusterSymbolsToRemove.pop();
                        this.engine.removeSymbol(symbol);
                    }
                    this._removeOldClusterSymbols = false;
                } else if (this.clusterSymbolsToRemove.length > 0) {
                    this._removeOldClusterSymbols = true;
                    this.needsDraw = true;
                }

            } else {
                var self = this;
                setTimeout(function () {
                    self.needsDraw = true;
                }, 0);
            }
        }
    },

    engine: {
        get: function () {
            return this._engine;
        },
        set: function (value) {
            if (value && value !== this._engine) {
                if (this._engine !== null) {
                    this.clearSymbols();
                    this._engine.removeOverlayComponent(this);
                }
                this._engine = value;
                if (this.layer) {
                    this.symbols[this._engine.uuid] = {};
                }
                this.clusterSymbols[this._engine.uuid] = [];
                this._engine.addOverlayComponent(this);
            }
        }
    },

    hasTemplate: {
        value: true
    },

    isVisible: {
        get: function () {
            return this.layer.isVisibleAtZoom(this.engine.position.zoom);
        }
    },

    layer: {
        get: function () {
            return this._layer;
        },
        set: function (value) {
            if (value && value !== this._layer) {
                this._layer = value;
                this.symbols[this.engine.uuid] = {};
                if (this.getBinding("enabled")) {
                    this.cancelBinding("enabled");
                }
                if (this.getBinding("isClustering")) {
                    this.cancelBinding("isClustering");
                }
                if (this.getBinding("opacity")) {
                    this.cancelBinding("opacity");
                }
                this.defineBinding("opacity", {"<-": "opacity", "source": this._layer});
                this.defineBinding("isClustering", {"<-": "isClustering", "source": this._layer});
                this.defineBinding("enabled", {"<-": "isEnabled", "source": this._layer});
            }
        }
    },

    mapComponent: {
        get: function () {
            return this._mapComponent;
        },
        set: function (value) {
            if (value) {
                this._mapComponent = value;
                this.defineBinding("engine", {"<-": "mapEngine", "source": this._mapComponent});
                this.defineBinding("currentZoom", {"<-": "currentZoom", "source": this._mapComponent});
                this.defineBinding("currentBounds", {"<-": "bounds", "source": this._mapComponent});
            }
        }
    },

    opacity: {
        get: function () {
            return this._opacity;
        },
        set: function (value) {
            if (this._opacity !== value) {
                this._opacity = value;
                this._shouldUpdateSymbolsOpacity = true;
                this.needsDraw = true;
            }
        }
    },

    queuedFeatures: {
        writeable: false,
        enumerable: false,
        get: function () {
            if (this._queuedFeatures === null) {
                this._queuedFeatures = [];
            }
            return this._queuedFeatures;
        }
    },

    redrawFeatures: {
        value: function () {
            var features, feature, i, n,
                bounds = this.engine.bounds,
                bbox = bounds && [bounds.west, bounds.south, bounds.east, bounds.north];
            if (this.layer.areFeaturesGlobal) {
                features = this.layer.features.all;
            } else {
                features = this.layer.features.visible;
            }
            for (i = 0, n = features.length; i < n; ++i) {
                feature = features[i];
                if (this.isClustering) {
                    this.clusterManager.addFeature(feature);
                } else if (this.layer.areFeaturesGlobal || !bbox || GeometryUtilities.boundingBoxContainsFeature(bbox, feature)) {
                    this.queuedFeatures.push(feature);
                }
                this.shouldRecalculateClusters = this.isClustering;
                this.needsDraw = true;
            }
        }
    },



    shouldRecalculateClusters: {
        enumerable: false,
        get: function () {
            if (this._shouldRecalculateClusters === null) {
                this._shouldRecalculateClusters = false;
            }
            return this._shouldRecalculateClusters;
        },
        set: function (value) {
            this._shouldRecalculateClusters = value;
        }
    },

    symbols: {
        enumerable: true,
        writeable: false,
        get: function () {
            return this.layer.symbols;
        }
    },

    symbolsToRemove: {
        writeable: false,
        get: function () {
            if (this._symbolsToRemove === null) {
                this._symbolsToRemove = [];
            }
            return this._symbolsToRemove;
        }
    },

    willDraw: {
        value: function () {
            if (this.isClustering && this.shouldRecalculateClusters) {
                var clusterSymbols = this.clusterSymbols[this.engine.uuid],
                    symbols = clusterSymbols.splice(0, clusterSymbols.length);
                this._removeOldClusterSymbols = false;
                this.clusterSymbolsToRemove.push.apply(this.clusterSymbolsToRemove, symbols);
                this.clusterManager.recalculateClusters();
                this.shouldRecalculateClusters = false;
            }
        }
    },

    willZoom: {
        value: function () {
            this.clearSymbols();
        }
    }

}, {});
