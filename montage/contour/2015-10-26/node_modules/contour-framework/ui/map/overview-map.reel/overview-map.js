/**
 * @module ui/overview-map.reel
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    DataSelector = require("montage-data/logic/service/data-selector").DataSelector,
    DataService = require("montage-data/logic/service/data-service").DataService,
    Layer = require("logic/mock-model/layer").Layer,
    Protocol = require("logic/model/protocol").Protocol,
    Tile = require("logic/model/tile").Tile,
    OVERVIEW_MAP_WIDTH = 256,
    OVERVIEW_MAP_HALF_WIDTH = OVERVIEW_MAP_WIDTH / 2;

var GOOGLE_MAP_TYPES = {
    "Google Basemap": "satellite",
    "Google Street": "roadmap",
    "Google Hybrid": "hybrid",
    "Google Terrain": "terrain"
};


/**
 * @class OverviewMap
 * @extends Component
 */
exports.OverviewMap = Component.specialize(/** @lends OverviewMap.prototype */{

    _calculateTiles: {
        value: function () {

            if (this.isExpanded && this._isVisible && this.engine && this.center && this.layer) {

                var numberTiles = Math.pow(2, this.zoom),
                    centerPoint = this.engine.coordinateToMercatorPoint(this.center),
                    centerPointX = centerPoint.x * numberTiles,
                    centerPointY = centerPoint.y * numberTiles,
                    leftPixelEdge = centerPointX - OVERVIEW_MAP_HALF_WIDTH,
                    rightPixelEdge = centerPointX + OVERVIEW_MAP_HALF_WIDTH,
                    topPixelEdge = centerPointY - OVERVIEW_MAP_HALF_WIDTH,
                    bottomPixelEdge = centerPointY + OVERVIEW_MAP_HALF_WIDTH,
                    centerTile = Tile.create(
                        Math.floor(centerPointX / 256),
                        Math.floor(centerPointY / 256),
                        this.zoom
                    ),
                    centerTileBounds = this.engine.getLatLngBoundsForTile(centerTile),
                    originPoint = this.engine.coordinateToMercatorPoint([
                        centerTileBounds[0][0], centerTileBounds[1][1]
                    ]),
                    originPointX = originPoint.x * numberTiles,
                    originPointY = originPoint.y * numberTiles,
                    minX, maxX, minY, maxY,
                    x = originPointX,
                    y = originPointY,
                    tile, i, n;

                minX = maxX = centerTile.x;
                minY = maxY = centerTile.y;

                while (x > leftPixelEdge) {
                    x -= 256;
                    minX -= 1;
                }

                while (y > topPixelEdge) {
                    y -= 256;
                    minY -= 1;
                }

                x = originPointX;
                y = originPointY;

                do {
                    x += 256;
                    maxX += 1;
                } while (x < rightPixelEdge);

                do {
                    y += 256;
                    maxY += 1;
                } while (y < bottomPixelEdge);

                for (var key in this._tileRegistry) delete this._tileRegistry[key];

                for (; minX < maxX; minX++) {
                    for (i = minY, n = maxY; i < n; i++) {
                        if (i >=0 && i < numberTiles) {
                            var xCoord = minX,
                                identifier,
                                position;

                            if (xCoord < 0 || x >= numberTiles) {
                                xCoord = (xCoord % numberTiles + numberTiles) % numberTiles;
                            }
                            identifier = xCoord + ':' + i + ':' + this.zoom;
                            tile = this._tileRegistry[identifier];
                            if (! tile) {
                                tile = Tile.create(xCoord, i, this.zoom);
                                this._tileRegistry[identifier] = tile;
                            }
                            position = tile.count;
                            if (tile.positions[position] === undefined) {
                                tile.positions[position] = {
                                    x: minX
                                };
                            } else {
                                tile.positions[position].x = i;
                            }
                            tile.count++;
                            this._requestTile(tile);
                        }
                    }
                }
            }
        }
    },

    _center: {
        value: null
    },

    _drawTimer: {
        value: null
    },

    _isVisible: {
        value: false
    },

    _layer: {
        value: undefined
    },

    _requestTile: {
        value: function (tile) {
            var self = this,
                selector;
            if (this.layer) {
                selector = DataSelector.withTypeAndCriteria(Tile.TYPE, {
                    tile: tile,
                    layer: this.layer
                });

                DataService.mainService.fetchData(selector).then(function () {
                    if (self._tileRegistry[tile.id] !== undefined) {
                        if (self._drawTimer) clearTimeout(self._drawTimer);
                        self._drawTimer = setTimeout(function () {
                            self.needsDraw = true;
                        }, 50);
                    }
                });
            }
        }
    },

    _requestGoogleTile: {
        value: function () {

            if (this.isVisible && this.isExpanded && this.center) {
                var self = this, url,
                    center = [this.center[0].toFixed(6), this.center[1].toFixed(6)],
                    mapType = GOOGLE_MAP_TYPES[this.layer.name] || "terrain",
                    tileId = mapType + ":" + center[0] + ":" + center[1] + ":" + this.zoom,
                    image = this._tileRegistry[tileId];

                if (image) {
                    this.needsDraw = true;
                } else {
                    url = "https://maps.googleapis.com/maps/api/staticmap?center="
                    url += String(this.center[1]);
                    url += ",";
                    url += String(this.center[0]);
                    url += "&zoom=";
                    url += this.zoom;
                    url += "&size=256x256";
                    url += "&maptype=";
                    url += mapType;

                    image = new Image();
                    image.onload = function () {
                        self._tileRegistry[tileId] = image;
                        self.needsDraw = true;
                    };
                    image.setAttribute('crossOrigin', 'anonymous');
                    image.src = url;
                }
            }
        }
    },

    _tileRegistry: {
        value: {}
    },

    _update: {
        value: function () {
            var self;
            if (this.layer && this.layer.mapService.protocol === Protocol.GOOGLE) {
                self = this;
                if (this._drawTimer) {
                    clearTimeout(this._drawTimer);
                }
                this._drawTimer = setTimeout(function () {
                    self._requestGoogleTile();
                }, 100);
            } else if (this.layer) {
                this._calculateTiles();
            }
        }
    },

    _zoom: {
        value: 0
    },

    canvasOverlay: {
        value: null
    },

    center: {
        get: function () {
            return this._center;
        },
        set: function (value) {
            if (value && value !== this._center) {
                this._center = value;
                this._update();
            }

        }
    },

    content: {
        value: null
    },

    draw: {
        value: function () {

            if (this.isExpanded && this._isVisible && this.center) {

                var numberTiles = Math.pow(2, this.zoom),
                    pixelCenter = this.engine.coordinateToMercatorPoint(this.center),
                    leftEdge = pixelCenter.x * numberTiles - OVERVIEW_MAP_HALF_WIDTH,
                    topEdge = pixelCenter.y * numberTiles - OVERVIEW_MAP_HALF_WIDTH,
                    hiddenCanvasContext = this.hiddenCanvasOverlay.getContext("2d"),
                    visibleCanvasContext = this.canvasOverlay.getContext("2d");

                hiddenCanvasContext.clearRect(0, 0, OVERVIEW_MAP_WIDTH, OVERVIEW_MAP_WIDTH);

                if (this.layer.mapService.protocol === Protocol.GOOGLE) {

                    var center = [this.center[0].toFixed(6), this.center[1].toFixed(6)],
                        mapType = GOOGLE_MAP_TYPES[this.layer.name] || "terrain",
                        tileId = mapType + ":" + center[0] + ":" + center[1] + ":" + this.zoom,
                        googleTile = this._tileRegistry[tileId];

                    if (googleTile) {
                        hiddenCanvasContext.drawImage(googleTile, 0, 0);
                    }

                } else {

                    var key, tile, tileBounds, origin, xOffset, yOffset, i, n, position;

                    for (key in this._tileRegistry) {

                        tile = this._tileRegistry[key];
                        if (tile.image) {
                            tileBounds = this.engine.getLatLngBoundsForTile(tile);
                            origin = this.engine.coordinateToMercatorPoint([tileBounds[0][0], tileBounds[1][1]]);
                            for (i = 0, n = tile.positions.length; i < n; i++) {
                                position = tile.positions[i];
                                xOffset = origin.x * numberTiles - leftEdge + ((position.x - tile.x) * 256);
                                yOffset = origin.y * numberTiles - topEdge;
                                hiddenCanvasContext.drawImage(tile.image, xOffset, yOffset);
                            }
                        }
                    }
                }

                if (this.zoom <= 1) {
                    this.extentBox.style.display = "none";
                } else {
                    var extentBoxWidth = this.engine.size.width / 32,
                        extentBoxHeight = this.engine.size.height / 32;
                    this.extentBox.style.width = extentBoxWidth + "px";
                    this.extentBox.style.height = extentBoxHeight + "px";
                    this.extentBox.style.left = ((128 - extentBoxWidth) / 2) + "px";
                    this.extentBox.style.top = ((128 - extentBoxHeight) / 2) + "px";
                    this.extentBox.style.display = "block";
                }

                visibleCanvasContext.clearRect(0, 0, 128, 128);
                visibleCanvasContext.drawImage(this.hiddenCanvasOverlay, 0, 0, 128, 128);
            }
        }
    },

    engine: {
        value: null
    },

    enterDocument: {
        value: function (firstTime) {
            var desktopMediaQuery;
            if (firstTime) {
                desktopMediaQuery = window.matchMedia("(min-height: 700px) and (min-width: 700px)");
                desktopMediaQuery.addListener(this.isVisible.bind(this));
                this.isVisible(desktopMediaQuery);
            }
        }
    },

    exportToJpeg: {
        value: function (context, exceptions) {
            var self = this;
            return new Promise(function (resolve, reject) {
                if (self.isVisible && self.isExpanded) {
                    var mapSize = self.application.delegate.map.size,
                        x = mapSize.width - 138,
                        y = mapSize.height - 150;
                    context.save();
                    context.fillStyle = "#FFFFFF";
                    context.globalAlpha = 1.0;
                    context.rect(x, y, 130, 130);
                    context.fill();
                    context.drawImage(self.canvasOverlay, x + 1, y + 1, 128, 128);
                    context.restore();
                }
                resolve(null);
            });
        }
    },

    extentBox: {
        value: null
    },

    handleToggleVisibilityButtonAction: {
        value: function () {
            this.isExpanded = ! this.isExpanded;
            if (this.isExpanded) this._update();
        }
    },

    hiddenCanvasOverlay: {
        value: null
    },

    isExpanded: {
        value: true
    },

    isVisible: {
        value: function (desktopMediaQuery) {
            this._isVisible = desktopMediaQuery.matches;
            if (this._isVisible) {
                this._update();
            }
        }
    },

    layer: {
        get: function () {
            return this._layer;
        },
        set: function (value) {
            var key;
            if (value && value !== this._layer) {
                this._layer = value;
                for (key in this._tileRegistry) {
                    delete this._tileRegistry[key];
                }
                this._update();
            }
        }
    },

    zoom: {
        get: function () {
            return this._zoom;
        },
        set: function (value) {
            if ((value !== undefined || value !== null) && (value - 4) !== this._zoom) {
                this._zoom = value - 4;
                if (this._zoom < 1) this._zoom = 1;
                this._update();
            }
        }
    }

});
