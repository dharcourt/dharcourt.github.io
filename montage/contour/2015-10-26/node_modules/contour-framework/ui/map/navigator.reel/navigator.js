/**
 * @module "ui/navigator.reel"
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    Figure = require("logic/model/figure").Figure,
    FigureType = require("logic/model/figure").FigureType,
    Mode = require("ui/map/map.reel").Mode,
    PressComposer = require("montage/composer/press-composer").PressComposer;

/**
 * @class Navigator
 * @extends Component
 */
exports.Navigator = Component.specialize(/** @lends Navigator.prototype */{

    _availableMapModes: {value: null},

    _contextualModes: {value: null},

    _currentMode: {value: 0},

    currentMode: {
        get: function () {
            return this._currentMode;
        },
        set: function (value) {
            if (this._currentMode !== value) {
                this._currentMode = value;
                if (this._currentMode !== Mode["Pan"] && this._currentMode !== Mode["Zoom"]) {
                    this._setSelectedMode();
                }
            }
        }
    },

    currentZoom: {value: 0},

    _goHome: {
        value: function () {
            this.mapComponent.goHome();
        }
    },

    _handleAvailableMapModesChange: {
        value: function () {
            this._setSelectedMode();
            this._isModeDrawerOpen = false;
            this.needsDraw = true;
        }
    },

    _imageInput: {value: null},

    _imageInputLabel: {value: null},

    _isImageInputOpen: {value: null},

    _isModeDrawerOpen: {value: false},

    _maxScale: {value: 0},

    _minScale: {value: 0},

    _optionForMode: {
        value: function (mapMode) {
            var option = {
                mode: mapMode
            };
            switch (mapMode) {
                case Mode["Identify"]:
                    option.icon = "\ue68d";
                    break;
                case Mode["AreaBriefRectangle"]:
                    option.icon = "\ue68d";
                    break;
                case Mode["AreaBriefCircle"]:
                    option.icon = "\ue68e";
                    break;
                case Mode["AnnotationTool"]:
                    option.icon = "\ue63f";
                    break;
                case Mode["Circle"]:
                    option.icon = "\ue631";
                    break;
                case Mode["FreeLineTool"]:
                    option.icon = "\ue64c";
                    break;
                case Mode["FreePolygonTool"]:
                    option.icon = "\ue64e";
                    break;
                case Mode["PlacemarkTool"]:
                    option.icon = "\ue65a";
                    break;
                case Mode["ImageTool"]:
                    option.icon = "\ue64f";
                    break;
                case Mode["LineTool"]:
                    option.icon = "\ue64b";
                    break;
                case Mode["PolygonTool"]:
                    option.icon = "\ue64d";
                    break;
                case Mode["Rectangle"]:
                    option.icon = "\ue64a";
                    break;
                case Mode["Point"]:
                    option.icon = "\ue631";
                    break;

            }
            return option;
        }
    },

    _modePressComposer: {value: null},

    _panMode: {
        value: function () {
            if (this.currentMode !== Mode["Pan"]) {
                this.mapComponent.enterPanMode();
            }
        }
    },

    _position: {value: null},

    _preparedForAction: {value: false},

    _pressComposer: {value: null},

    _selectedMode: {value: null},

    _redoPositionChange: {
        value: function () {
            this.mapComponent.redoPositionChange();
        }
    },

    _setSelectedMode: {
        value: function () {
            var i, modes = this._availableMapModes, newSelectedMode = modes[0], length = modes.length;
            for (i = 0; i < length; i++) {
                if (this.currentMode === modes[i].mode) {
                    newSelectedMode = modes[i];
                    break;
                }
            }
            this._selectedMode = newSelectedMode;
        }
    },

    _undoPositionChange: {
        value: function () {
            this.mapComponent.undoPositionChange();
        }
    },

    _zoomIn: {
        value: function () {
            var nextZoomLevel = this.currentZoom + 1;
            if (nextZoomLevel <= this.maxScale) {
                this.mapComponent.setZoom(nextZoomLevel);
            }
        }
    },

    _zoomMode: {
        value: function () {
            if (this.currentMode !== Mode["Zoom"]) {
                this.mapComponent.enterZoomMode();
            }
        }
    },

    _zoomOut: {
        value: function () {
            var nextZoomLevel = this.currentZoom - 1;
            if (nextZoomLevel >= this.minScale) {
                this.mapComponent.setZoom(nextZoomLevel);
            }
        }
    },

    draw: {
        value: function () {
            var width;
            if (this._isModeDrawerOpen && this._availableMapModes && this._availableMapModes.length > 0) {
                width = (this._availableMapModes.length * 26);
                this._modeControls.style.width = width + "px";
                this._modeControls.style.transform = "translateX(-" + (width - 26) + "px)";
                this._modeControls.style.overflow = "hidden";
            } else {
                this._modeControls.style.width = "26px";
                this._modeControls.style.transform = "none";
                this._modeControls.style.overflow = "visible";
            }
        }
    },

    enterDocument: {
        value: function (firstTime) {
            if (firstTime) {
                this.addRangeAtPathChangeListener("_availableMapModes", this, "_handleAvailableMapModesChange");
            }
        }
    },

    handleChange: {
        value: function (event) {
            event.stopPropagation();
            this._imageInput.removeEventListener("change", this);
            var dataUrl, file = this._imageInput.files[0], figure, reader, self = this;
            this._isModeDrawerOpen = false;
            if (file && Figure.isSupportedImageMimeType(file.type)) {
                reader = new FileReader();
                reader.onloadend = function () {
                    dataUrl = reader.result;
                    figure = Figure.initializeFigureWithType(FigureType["Image"], [0, 0], {
                        dataURL: dataUrl
                    });
                    self.application.map._oldMode = Mode["ImageTool"];
                    self.application.map.currentMode = Mode["ImageTool"];
                    self.application.map.figures.add(figure);
                    self._imageInput.value = "";
                };
                reader.readAsDataURL(file);
            } else if (file) {
                this._hasError = true;
                this.needsDraw = true;
                this._imageInput.value = "";
                this.errorBar.addEventListener("closeAction", this, false);
            }
        }
    },

    handleLongPress: {
        value: function (e) {
            e.stopPropagation();
            if (!this._isModeDrawerOpen && this._availableMapModes && this._availableMapModes.length > 1) {
                this._justOpenedDrawer = true;
                this._isModeDrawerOpen = true;
                this.needsDraw = true;
            }
        }
    },

    handlePress: {
        value: function (e) {
            e.stopPropagation();
            var component = e.targetElement.component;
            if (component && component.identifier) {
                switch (component.identifier) {
                    case "home":
                        this._goHome();
                        break;
                    case "redoPositionChange":
                        this._redoPositionChange();
                        break;
                    case "undoPositionChange":
                        this._undoPositionChange();
                        break;
                    case "zoomIn":
                        this._zoomIn();
                        break;
                    case "zoomOut":
                        this._zoomOut();
                        break;
                    case "panMode":
                        this._panMode();
                        break;
                    case "zoomMode":
                        this._zoomMode();
                        break;
                    case "selectedMode":
                        if (!this._isModeDrawerOpen || !this._justOpenedDrawer) {
                            this._isModeDrawerOpen = false;
                            if (component.mode === Mode["ImageTool"]) {
                                this._imageInput.click();
                                this._imageInput.addEventListener("change", this, false);
                                this._imageInput.addEventListener("focus", this, false);
                            } else if (component.mode === Mode["Point"]) {
                                this.application.delegate.map.enterPointSelectionMode();
                            } else {
                                this.mapComponent.currentMode = component.mode;
                                this._setSelectedMode();
                            }
                        } else {
                            this._justOpenedDrawer = false;
                        }
                        break;
                    case "modeOption":
                        this._isModeDrawerOpen = false;
                        if (component.mode === Mode["ImageTool"]) {
                            this._imageInput.click();
                            this._imageInput.addEventListener("change", this, false);
                            this._imageInput.addEventListener("focus", this, false);
                        } else {
                            this.mapComponent.currentMode = component.mode;
                            this._setSelectedMode();
                        }
                        break;
                }
            }
        }
    },

    mapComponent: {value: null},

    maxScale: {
        get: function () {
            return this._maxScale;
        },
        set: function (value) {
            if (value && this._maxScale !== value) {
                this._maxScale = value;
                this.needsDraw = true;
            }
        }
    },

    minScale: {
        get: function () {
            return this._minScale;
        },
        set: function (value) {
            if (value && this._minScale !== value) {
                this._minScale = value;
                this.needsDraw = true;
            }
        }
    },

    prepareForActivationEvents: {
        value: function () {
            if (!this._preparedForAction) {
                this._preparedForAction = true;
                if (!this._pressComposer) {
                    this._pressComposer = new PressComposer();
                    this.addComposer(this._pressComposer);
                }
                this._pressComposer.addEventListener("press", this, false);
                this._pressComposer.addEventListener("longPress", this, false);
            }
        }
    }

});
