/**
 * @module ui/map/feature-overlay.reel
 * @requires montage/ui/component
 */
var FeatureOverlay = require("ui/map/feature-overlay.reel/feature-overlay").FeatureOverlay,
    application = require("montage/core/application").application,
    MapDataConverter = require("logic/map/converters/map-data-converter").MapDataConverter,
    MapEngine = require("ui/map/map-engine").MapEngine,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    Projections = require("logic/map/projection-utilities").Projections,
    Promise = require("montage/core/promise").Promise;

var PRODUCT_TYPES = {
    FILE: "FILE_PRODUCT",
    FOLDER: "FOLDER_PRODUCT",
    URL: "URL_PRODUCT",
    TEXT: "TEXT_PRODUCT"
};

/**
 * @class ProductOverlay
 * @extends LayerOverlayComponent
 */
var ProductOverlay = exports.ProductOverlay = FeatureOverlay.specialize(/** @lends ProductOverlay */ {
    isInitialized: {
        value: false
    },

    _type: {
        value: OverlayType["Product"]
    },

    constructor: {
        value: function ProductOverlay() {
            this.super();
            this.enable = true;
            this.clustered = true;
        }
    },

    initialize: {
        value: function () {
            var self = this;
            var layer = this.layer;
            var promise = this._parseProducts(layer.data);

            layer.features = [];

            promise.then(function (features) {
                self.addFeatures(features);
            });

            this.isInitialized = true;
        }
    },

    _productsMap: {
        value: {}
    },

    _parseProducts: {
        value: function (productsTree) {
            var promises = [];
            var features = [];
            var len = productsTree.length;
            var product, promise;

            for (var i = 0; i < len; i++) {
                product = productsTree[i];
                if (product.type === PRODUCT_TYPES.FOLDER) {
                    if (!product.parentId) {
                        promises.push(this._getTrack(product));
                    }

                    promise = application.delegate.service.getObjectData(product, "children").then(function () {
                        return []; // product.children;
                    });

                    promises.push(promise.then(this._parseProducts.bind(this)));
                }

                if (product.geoLocations) {
                    promises.push(this._getPoint(product));
                }
            }

            return Promise.all(promises).then(function (data) {
                if (data) {
                    for (i = 0; i < data.length; i++) {
                        if (Array.isArray(data[i])) {
                            [].push.apply(features, data[i]);
                        } else {
                            features.push(data[i]);
                        }
                    }
                }

                return features;
            });
        }
    },

    _normalizeCoords: {
        value: function (coords) {
            return ProjectionUtilities.inverse(Projections["102100"], coords);
        }
    },

    _getPoint: {
        value: function (product) {
            var feature = MapDataConverter.wktToGeojson(product.geoLocations);

            product._feature = feature;

            feature.properties = {
                type: product.type,
                data: product
            };

            feature.type = "Product";

            feature.geometry.coordinates = this._normalizeCoords(feature.geometry.coordinates);

            return Promise.when(feature);
        }
    },

    _getTrack: {
        value: function (folderProduct) {
            var self = this;
            return application.delegate.service.getObjectData(folderProduct, "children").then(function () {
                    var len = folderProduct.children.length,
                        coordinates = [],
                        feature, product;

                    for (var i = 0; i < len; i++) {
                        product = folderProduct.children[i];

                        if (product.geoLocations) {
                            feature = MapDataConverter.wktToGeojson(product.geoLocations);
                            if (feature) {
                                coordinates.push(self._normalizeCoords(feature.geometry.coordinates));
                            }
                        }
                    }

                    return {
                        type: "Feature",
                        geometry: {
                            type: "LineString",
                            coordinates: coordinates
                        },
                        properties: {
                            type: PRODUCT_TYPES.FOLDER,
                            data: folderProduct
                        }
                    };
                });
        }
    },

    remove: {
        value: function () {
            this.isInitialized = false;

            this.clearSymbols();
        }
    },

    prepareFeature: {
        value: function (feature) {
            var type = feature.geometry.type;

            if (!feature.properties) {
                feature.properties = {};
            }

            feature.id = this.layer.features.length;

            feature.properties.type = type;
            feature.properties.componentId = this.uuid;

            if (type === "Point") {
                feature.properties.point = feature.geometry.coordinates;
            }

            feature.layer = this.layer;

            this.layer.features.push(feature);

            this.needsDraw = true;
        }
    },

    addFeatures: {
        value: function (features) {
            var len = features.length;

            if (Array.isArray(features)) {
                for (var i = 0; i < len; i++) {
                    this.prepareFeature(features[i]);
                }
                this.redrawFeatures();
            }
        }
    }

});
