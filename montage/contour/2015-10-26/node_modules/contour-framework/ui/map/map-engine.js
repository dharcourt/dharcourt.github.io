/**
 * @module ui/map/map-engine.js
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    FeatureClusterer = require("logic/map/feature-clusterer").FeatureClusterer,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    Layer = require("logic/model/layer").Layer,
    MockLayer = require("logic/mock-model/layer").Layer,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    Promise = require("bluebird"),
    Protocol = require("logic/model/protocol").Protocol,
    Renderer = require("logic/map/renderer").Renderer,
    Tile = require("logic/model/tile").Tile;

/**
 * @class MapEngine
 * @extends Component
 *
 * All coordinates below should be in EPSG:3857.
 */
var MapEngine = exports.MapEngine = Component.specialize(/** @lends MapEngine.prototype */ {

    // override this method if you want the engine to do custom animation
    // after the tile has been loaded onto the overlay
    _animateTile: {
        value: function (tile) {}
    },

    _baseMap: {
        value: undefined
    },

    _calculateMinimumZoomLevel: {
        value: function (width, height) {

            var minimumZoomLevel = -1,
                numberOfTiles;

            do {
                minimumZoomLevel++;
                numberOfTiles = Math.pow(2, minimumZoomLevel);
            } while (numberOfTiles * 256 < width || numberOfTiles * 256 < height);

            this.minScale = minimumZoomLevel;
            return minimumZoomLevel;
        }
    },

    _createOverlay: {
        value: function (overlay) {
            switch (overlay.component.type) {
                case OverlayType["Tile"]:
                    this._initializeTileOverlay(overlay);
                    break;
                case OverlayType["Figure"]:
                    this._initializeFigureOverlay(overlay);
                    break;
                case OverlayType["Heatmap"]:
                    this._initializeHeatMapOverlay(overlay);
                    break;
                case OverlayType["Mgrs"]:
                    this._initializeMgrsOverlay(overlay);
                    break;
                case OverlayType["Import"]:
                    this._initializeImportOverlay(overlay);
                    break;
                case OverlayType["Product"]:
                    this._initializeProductOverlay(overlay);
                    break;
                case OverlayType["Maptip"]:
                    this._initializeMaptipOverlay(overlay);
                    break;
            }
        }
    },

    /**
     * A transaprent image.  Used to hide tiles
     */
    _defaultImage: {
        value: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAHCGzyUAAAAC0lEQVQI12P4zwAAAgEBAKrChTYAAAAASUVORK5CYII="
    },

    _distanceBetweenPoints: {
        value: function (point1, point2) {
            var distanceX = point1[0] - point2[0],
                distanceY = point1[1] - point2[1];

            return Math.sqrt((distanceX * distanceX) + (distanceY * distanceY));
        }
    },

    _draggable: {
        value: true
    },

    _drawFeatureCluster: {
        value: function (cluster) {}
    },

    _drawHazardCluster: {
        value: function (cluster) {}
    },

    _drawPointFeature: {
        value: function (feature, overlay) {}
    },

    _drawPointSymbol: {
        value: function (symbol) { console.warn("This method is not yet implemented"); }
    },

    _drawMultiPointFeature: {
        value: function (feature, overlay) {}
    },

    _drawLineFeature: {
        value: function (feature, overlay) {}
    },

    _drawMultiLineFeature: {
        value: function (feature, overlay) {}
    },

    _drawPolygonFeature: {
        value: function (feature, overlay) {}
    },

    _drawGroundOverlayFeature:{
        value: function (feature, overlay) {}
    },

    _drawHazardClusterSymbolsToJpeg: {
        value: function (context, cluster, origin) {
            var centerPoint = this.coordinateToPoint(cluster.center), self = this;
            centerPoint.x -= origin.x;
            centerPoint.y -= origin.y;
            context.save();
            context.fillStyle = "rgba(255, 0, 0, 1)";
            context.beginPath();
            context.arc(centerPoint.x, centerPoint.y, 4, 0, 2 * Math.PI, false);
            context.fill();
            context.restore();
            cluster.features.forEach(function (feature) {
                var symbolPosition = self.coordinateToPoint(feature.properties.clusterCoordinate || feature.geometry.coordinates);
                symbolPosition.x -= origin.x;
                symbolPosition.y -= origin.y;
                context.save();
                context.strokeStyle = "rgba(255, 0, 0, 1)";
                context.lineWidth = 2;
                context.beginPath();
                context.moveTo(centerPoint.x, centerPoint.y);
                context.lineTo(symbolPosition.x, symbolPosition.y);
                context.stroke();
                context.restore();
            });
        }
    },

    _drawTimer: {
        value: null
    },

    _exportFeatureLayerToJpeg: {
        value: function (layer, context, exceptions) {
            var self = this, i, n;
            return new Promise(function (resolve, reject) {
                var features = layer.areFeaturesGlobal ? layer.features.all.filter(function(feature) {
                        return GeometryUtilities.boundingBoxContainsFeature(self.bbox, feature);
                    }) : layer.features.visible,
                    imagesToLoad = [],
                    offset = self.coordinateToPoint([self.bounds.west, self.bounds.north]),
                    symbol;

                for (i = 0, n = features.length; i < n; ++i) {
                    symbol = self._exportFeatureToJpeg(layer, features[i], context, offset);
                    if (symbol) {
                        if (Array.isArray(symbol)) {
                            imagesToLoad.push.apply(imagesToLoad, symbol);
                        } else {
                            imagesToLoad.push(symbol);
                        }
                    }
                }
                if (imagesToLoad.length > 0) {
                    self._loadFeatureImages(imagesToLoad, exceptions, function (loadedImages) {
                        for (i = 0, n = loadedImages.length; i < n; ++i) {
                            symbol = loadedImages[i];
                            context.save();
                            context.globalAlpha = layer.opacity;
                            context.drawImage(symbol.image,
                                symbol.point.x - symbol.anchor.x - offset.x,
                                symbol.point.y - symbol.anchor.y - offset.y);
                            context.restore();
                        }
                        resolve(null);
                    });
                } else {
                    resolve(null);
                }
            });
        }
    },

    _exportFeatureToJpeg: {
        value: function (layer, feature, context, offset) {
            switch (feature.geometry.type) {
                case "Point":
                    return this._exportPointFeatureToJpeg(layer, feature, context);
                case "MultiPoint":
                    return this._exportMultiPointFeatureToJpeg(layer, feature, context);
                case "LineString":
                    return this._exportLineStringFeatureToJpeg(layer, feature, context, offset);
                case "MultiLineString":
                    return this._exportMultiLineStringFeatureToJpeg(layer, feature, context, offset);
                case "Polygon":
                case "MultiPolygon":
                    return this._exportPolygonFeatureToJpeg(layer, feature, context, offset);
                case "GroundOverlay":
                    return this._exportGroundOverlayFeatureToJpeg(layer, feature, context, offset);
                case "GeometryCollection":
                    return this._exportGeometryCollectionToJpeg(layer, feature, context, offset);
            }
        }
    },

    _exportGeometryCollectionToJpeg: {
        value: function (layer, style, feature, context, offset) {
            console.log(feature.geometry.coordinates);
            return false;
        }
    },

    _exportGroundOverlayFeatureToJpeg: {
        value: function (layer, style, feature, context, offset) {
            console.log(feature.geometry.coordinates);
            return false;
        }
    },

    _exportHazardLayerToJpeg: {
        value: function (layer, context, exceptions) {
            var self = this;
            return new Promise(function (resolve, reject) {
                var key, component, clusterManager, clustersInBounds = [], origin, imagesToLoad = [];
                for (key in self.overlayRegistry) {
                    component = self.overlayRegistry[key].component
                    if (component.layer === layer) {
                        clusterManager = component.clusterManager;
                        break;
                    }
                }
                if (clusterManager) {
                    origin = self.coordinateToPoint([self.bounds.west, self.bounds.north]);
                    clustersInBounds = clusterManager.clustersInBounds(self.bbox);
                    clustersInBounds.forEach(function (cluster) {
                        if (cluster.features.length > 1) {
                            self._drawHazardClusterSymbolsToJpeg(context, cluster, origin);
                        }
                        cluster.features.forEach(function (feature) {
                            imagesToLoad.push({
                                dimensions: feature.properties.iconDimensions,
                                point: self.coordinateToPoint(feature.properties.clusterCoordinate || feature.geometry.coordinates),
                                url: feature.properties.icon
                            });
                        });
                    });
                    if (imagesToLoad.length > 0) {
                        self._loadFeatureImages(imagesToLoad, exceptions, function (loadedImages) {
                            var i, n, symbol;
                            for (i = 0, n = loadedImages.length; i < n; ++i) {
                                symbol = loadedImages[i];
                                context.save();
                                context.globalAlpha = layer.opacity;
                                context.drawImage(
                                    symbol.image,
                                    symbol.point.x - symbol.dimensions.width / 2 - origin.x,
                                    symbol.point.y - symbol.dimensions.height / 2 - origin.y,
                                    symbol.dimensions.width,
                                    symbol.dimensions.height
                                );
                                context.restore();
                            }
                            resolve(null);
                        });
                    } else {
                        resolve(null);
                    }
                }
            });
        }
    },

    _exportLineStringFeatureToJpeg: {
        value: function (layer, feature, context, offset) {
            var i, n, coordinate, point,
                style = layer.renderer.render(feature.properties);
            context.save();
            context.globalAlpha = layer.opacity * style.opacity;
            context.strokeStyle = style.strokeColor;
            context.lineWidth = style.strokeWeight;
            for (i = 0, n = feature.geometry.coordinates.length; i < n; ++i) {
                coordinate = feature.geometry.coordinates[i];
                point = this.coordinateToPoint(coordinate);
                point.x -= offset.x;
                point.y -= offset.y;
                if (i === 0) {
                    context.moveTo(point.x, point.y);
                } else {
                    context.lineTo(point.x, point.y);
                }
            }
            context.stroke();
            context.restore();
            return false;
        }
    },

    _exportMultiLineStringFeatureToJpeg: {
        value: function (layer, feature, context, offset) {
            var i, n, j, jLength, coordinate, coordinateSet, point,
                style = layer.renderer.render(feature.properties);
            context.save();
            context.globalAlpha = layer.opacity * style.opacity;
            context.strokeStyle = style.strokeColor;
            context.lineWidth = style.strokeWeight;
            context.beginPath();
            for (i = 0, n = feature.geometry.coordinates.length; i < n; ++i) {
                coordinateSet = feature.geometry.coordinates[i];
                for (j = 0, jLength = coordinateSet.length; j < jLength; ++j) {
                    coordinate = coordinateSet[j];
                    point = this.coordinateToPoint(coordinate);
                    point.x -= offset.x;
                    point.y -= offset.y;
                    if (j === 0) {
                        context.moveTo(point.x, point.y);
                    } else {
                        context.lineTo(point.x, point.y);
                    }
                }
            }
            context.stroke();
            context.restore();
            return false;
        }
    },

    _exportMultiPointFeatureToJpeg: {
        value: function (layer, feature, context) {
            var symbol = JSON.parse(JSON.stringify(layer.renderer.render(feature.properties))),
                self = this;
            if (symbol.url) {
                return feature.geometry.coordinates.map(function (coordinate) {
                    symbol.point = self.coordinateToPoint(coordinate);
                    return symbol;
                });
            }
            // TODO draw features that do not have an image url
        }
    },

    _exportPointFeatureToJpeg: {
        value: function (layer, feature, context) {
            var symbol = JSON.parse(JSON.stringify(layer.renderer.render(feature.properties)));
            if (symbol.url) {
                symbol.point = this.coordinateToPoint(feature.geometry.coordinates);
                return symbol;
            }
            // TODO draw features that do not have an image url
        }
    },

    _exportPolygonFeatureToJpeg: {
        value: function (layer, feature, context, offset) {
            var i, n, j, n2, path, coordinate, point,
                style = layer.renderer.render(feature.properties);
            context.save();
            context.globalAlpha = layer.opacity;
            context.strokeStyle = Renderer.toRgba(style.strokeColor, style.strokeOpacity);
            context.lineWidth = style.strokeWeight;
            context.fillStyle = Renderer.toRgba(style.fillColor, style.fillOpacity);
            context.beginPath();

            for (i = 0, n = feature.geometry.coordinates.length; i < n; ++i) {
                path = feature.geometry.coordinates[i];
                for (j = 0, n2 = path.length; j < n2; ++j) {
                    coordinate = path[j];
                    point = this.coordinateToPoint(coordinate);
                    point.x -= offset.x;
                    point.y -= offset.y;
                    if (j === 0) {
                        context.moveTo(point.x, point.y);
                    } else {
                        context.lineTo(point.x, point.y);
                    }
                }
            }
            context.closePath();
            context.stroke();
            context.fill();
            context.restore();
            return false;
        }
    },

    _exportRasterLayerToJpeg: {
        value: function (layer, context, exceptions) {
            var self = this;
            return new Promise(function (resolve, reject) {

                var width = self.size.width,
                    height = self.size.height,
                    horizontalTileCount,
                    verticalTileCount,
                    tileBounds, tile,
                    i, j, tiles = [];

                if (layer && layer.mapService.protocol === Protocol.GOOGLE) {
                    horizontalTileCount = Math.ceil(width / 640);
                    verticalTileCount = Math.ceil(height / 640);
                    for (i = 0; i < horizontalTileCount; ++i) {
                        for (j = 0; j < verticalTileCount; ++j) {
                            tiles.push(self._googleBaseMapImage(self.map.getMapTypeId(), i, j));
                        }
                    }
                } else {
                    tileBounds = self.tileBounds;
                    for (i = tileBounds.minX; i <= tileBounds.maxX; ++i) {
                        for (j = tileBounds.minY; j <= tileBounds.maxY; ++j) {
                            tile = Tile.create(i, j, self.position.zoom);
                            tile.url = layer.mapService.protocol.makeUrlWithTileAndLayer(tile, layer);
                            tiles.push(tile);
                        }
                    }
                }
                self._loadTiles(tiles, exceptions, function (returnedTiles) {
                    var aTile, tilePosition,
                        origin = self.coordinateToPoint([self.bounds.west, self.bounds.north]);
                    for (i = 0; i < returnedTiles.length; i++) {
                        aTile = returnedTiles[i];
                        if (aTile.image) {
                            if (layer.mapService.protocol === Protocol.GOOGLE) {
                                context.save();
                                context.drawImage(aTile.image, aTile.x * 640, aTile.y * 640);
                                context.restore();
                            } else {
                                tilePosition = self.coordinateToPoint([aTile.bounds.xMin, aTile.bounds.yMax]);
                                context.save();
                                context.globalAlpha = layer.opacity;
                                context.drawImage(aTile.image, tilePosition.x - origin.x, tilePosition.y - origin.y);
                                context.restore();
                            }
                        }
                    }
                    resolve(null);
                });
            });
        }
    },

    _geojsonLayers: {
        value: []
    },

    // Start export to JPEG
    _googleBaseMapImage: {
        value: function (baseMapId, x, y) {
            var swPoint = {x: x * 640, y: (y + 1) * 640 + 320},
                nePoint = {x: (x + 1) * 640, y: y * 640 + 320},
                swCoord = this.pointToContainerCoordinate(swPoint),
                neCoord = this.pointToContainerCoordinate(nePoint),
                longitude,
                distance = GeometryUtilities.distanceBetweenGeographicPoints(swCoord, [swCoord[0], neCoord[1]]) * 1000,
                latitude = GeometryUtilities.destinationPoint(swCoord, distance, 0)[1],
                url = "https://maps.googleapis.com/maps/api/staticmap?";

            if (swCoord[0] <= neCoord[0]) {
                longitude = (swCoord[0] + neCoord[0]) / 2;
            } else {
                longitude = ((swCoord[0] + neCoord[0] + 360) / 2) - 360;
            }

            url += "center=";
            url += latitude;
            url += ",";
            url += longitude;
            url += "&zoom=";
            url += this.position.zoom;
            url += "&size=";
            url += 640;
            url += "x";
            url += 640;
            url += "&scale=1";
            url += "&maptype=";
            url += baseMapId;
            url += "&format=jpg";

            return {
                x: x,
                y: y,
                url: url
            };
        }
    },

    _initializeFigureOverlay: {
        value: function (overlay) {}
    },

    _initializeHeatMapOverlay: {
        value: function (overlay) {}
    },

    _initializeImportOverlay: {
        value: function (overlay) {
            var component = overlay.component;

            if (!component.layer) { return; }

            if (!component.isInitialized) {
                component.initialize();
            }

            component.needsDraw = true;
        }
    },

    // This method needs to be overridden to handle
    // the initialization of the map.
    _initializeMap: {
        value: function () {}
    },

    _initializeMaptipOverlay: {
        value: function (overlay) {}
    },

    _initializeMgrsOverlay: {
        value: function (overlay) {
            var component = overlay.component;
            this.appendElementToOverlayPaneWithId(component.element, "TileLayer");
            component.needsDraw = true;
        }
    },

    _initializeProductOverlay: {
        value: function (overlay) {
            var component = overlay.component;

            if (!component.layer) { return; }

            if (!component.isInitialized) {
                component.initialize();
            }

            component.needsDraw = true;
        }
    },

    _initializeTileOverlay: {
        value: function (overlay) {
            this.updateTileBounds();
            overlay.component.initialize();
        }
    },

    _loadFeatureImage: {
        value: function (imageToLoad, context) {
            var image = new Image(),
                timer,
                clearTimer = function () {
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                    }
                },
                handleFail = function () {

                    clearTimer();

                    this.onerror = this.onload = this.onabort = function () {
                        // intentionally blank.
                    };

                    var failObject = {title: "Google Base Map"};
                    if (context.exceptions.loadingFailures.indexOf(failObject) === -1) {
                        context.exceptions.loadingFailures.push(failObject);
                    }

                    if (++context.loadedImageCount >= context.images.length) {
                        context.callback(context.images);
                    }
                };
            timer = setTimeout(function (theImg) {
                return function () {
                    handleFail.call(theImg);
                }
            }(image), 3000);

            image.onload = function () {
                clearTimer();
                imageToLoad.image = image;
                if (++context.loadedImageCount >= context.images.length) {
                    context.callback(context.images);
                }
            };
            image.crossOrigin = "Anonymous";
            image.src = imageToLoad.url;
        }
    },

    _loadFeatureImages: {
        value: function (imagesToLoad, exceptions, callback) {
            var context = {
                images: imagesToLoad,
                loadedImageCount: 0,
                exceptions: exceptions,
                callback: callback
            }, i, n;
            for (i = 0, n = imagesToLoad.length; i < n; ++i) {
                this._loadFeatureImage(imagesToLoad[i], context);
            }
        }
    },

    _loadTile: {
        value: function (index, context) {
            var image = new Image(),
                tile = context.tiles[index],
                timer,
                clearTimer = function () {
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                    }
                },
                handleFail = function () {

                    clearTimer();

                    this.onerror = this.onload = this.onabort = function () {
                        // intentionally blank.
                    };

                    var failObject = {title: "Google Base Map"};
                    if (context.exceptions.loadingFailures.indexOf(failObject) === -1) {
                        context.exceptions.loadingFailures.push(failObject);
                    }

                    if (++context.loadedTileCount >= context.tiles.length) {
                        context.callback(context.tiles);
                    }
                };

            timer = setTimeout(function (theImg) {
                return function () {
                    handleFail.call(theImg);
                }
            }(image), 3000);

            image.onload = function () {
                clearTimer();
                tile.image = image;
                if (++context.loadedTileCount >= context.tiles.length) {
                    context.callback(context.tiles);
                }
            };
            image.crossOrigin = "Anonymous";
            image.src = tile.url;
        }
    },

    _loadTiles: {
        value: function (tiles, exceptions, callback) {
            var context = {
                    tiles: tiles,
                    loadedTileCount: 0,
                    exceptions: exceptions,
                    callback: callback
                },
                i, n;
            for (i = 0, n = tiles.length; i < n; ++i) {
                this._loadTile(i, context);
            }
        }
    },

    _mapEventListeners: {
        value: {}
    },

    _mapTips: {
        value: null
    },

    _needsPrune: {
        value: false
    },

    _normalizeLongitude: {
        value: function (longitude) {
            if (longitude > 180 || longitude < -180) {
                var incrementer = longitude < -180 ? 360 : -360;
                do {
                    longitude += incrementer;
                } while (longitude > 180 || longitude < -180);
            }
            return longitude;
        }
    },

    _overlayRegistry: {
        value: null
    },

    _queuedObjects: {
        value: []
    },

    _queuedOverlays: {
        value: []
    },

    _registerOverlayComponent: {
        value: function (component) {
            var overlayId = component.uuid;
            if (this.overlayRegistry[overlayId]) {
                console.warn("Cannot initialize overlay with id", overlayId, "it already exists.");
                return;
            }
            this.overlayRegistry[overlayId] = {
                component: component
            };
            return this.overlayRegistry[overlayId];
        }
    },

    _removeImportOverlay: {
        value: function (overlay) {
            overlay.component.remove();
        }
    },

    _removeMaptipComponent: {
        value: function (component) {}
    },

    _removeOverlay: {
        value: function (overlay) {
            switch (overlay.component.type) {
                case OverlayType["Maptip"]:
                    this.removeElementFromOverlayPaneWithId(overlay.component.element, "PopUp");
                    break;
                case OverlayType["Tile"]:
                    this.removeElementFromOverlayPaneWithId(overlay.component.element, "TileLayer");
                    break;
                case OverlayType["Mgrs"]:
                    this.removeElementFromOverlayPaneWithId(overlay.component.element, "OverlayLayer");
                    break;
                case OverlayType["Figure"]:
                    this.clearOverlayEvents(overlay.component);
                    break;
                case OverlayType["Heatmap"]:
                    this.clearOverlayEvents(overlay.component);
                    this.removeElementFromOverlayPaneWithId(overlay.component.element, "OverlayLayer");
                    break;
                case OverlayType["Import"]:
                    this._removeImportOverlay(overlay);
                    break;
                case OverlayType["Product"]:
                    this._removeProductOverlay(overlay);
                    break;
            }
        }
    },

    _removeProductOverlay: {
        value: function (overlay) {
            var component = overlay.component;

            component.remove();
        }
    },

    _setPositionAndBounds: {
        value: function (centerLat, centerLng, zoom, south, west, north, east) {

            // deprecated lat and lng properties.
            this.position = {
                center: [centerLng, centerLat],
                zoom: zoom
            };

            east = this._normalizeLongitude(east);
            west = this._normalizeLongitude(west);

            //this.bounds = [
            //    [west, south],
            //    [east, north]
            //];
            this.bounds = {
                east: east,
                north: north,
                northEast: {
                    lat: north,
                    lng: east
                },
                south: south,
                southWest: {
                    lat: south,
                    lng: west
                },
                west: west
            };

            this.bbox = [west, south, east, north];

            if (
                (this.bounds.northEast.lat && this.bounds.southWest.lat) &&
                (this.bounds.northEast.lat > 85 || this.bounds.southWest.lat < -85)
            ) {
                this._setToRestrictedBounds();
            }

            this._setTileBoundsCalculatorTimer();
        }
    },

    // TODO add implementation of maximum bounds;
    _setToRestrictedBounds: {
        value: function () {
            var delta;
            if (this.bounds.north > 85) {
                delta = 85 - (this.bounds.north - this.position.center[1]) * 1.1;
                this.setCenter([this.position.center[0], delta]);
            } else if (this.bounds.southWest.lat < -85) {
                delta = -(85 - (Math.abs(this.bounds.south) - Math.abs(this.position.center[1])) * 1.1);
                this.setCenter([this.position.center[0], delta]);
            }
        }
    },

    _setTileBoundsCalculatorTimer: {
        value: function () {

            if (this._tileBoundsCalculatorTimer) {
                window.clearTimeout(this._tileBoundsCalculatorTimer);
                this._tileBoundsCalculatorTimer = null
            }

            var self = this;
            this._tileBoundsCalculatorTimer = window.setTimeout(function() {
                for (var key in self.overlayRegistry) {
                    if (self.overlayRegistry[key].component.type === OverlayType["Tile"]) {
                        self.updateTileBounds();
                        break;
                    }
                }
            }, 250);
        }
    },

    _tileBounds: {
        value: null
    },

    _tileBoundsCalculatorTimer: {
        value: null
    },

    _tileCount: {
        value: 0
    },

    _tileRegistry: {
        value: null
    },

    _tilesRequiringAnimation: {
        value: []
    },

    _updateBaseMap: {
        value: function () {}
    },

    addOverlayComponent: {
        value: function (component) {
            if (this.overlayRegistry[component.uuid]) {
                return;
            }
            var overlay = this._registerOverlayComponent(component);
            if (overlay) {
                this._queuedOverlays.push({
                    overlay: overlay,
                    action: "add"
                });
                this.needsDraw = true;
            }
        }
    },

    addTileToOverlay: {
        value: function (tile, overlayId) {
            this._queuedObjects.push({
                overlayId: overlayId,
                tile: tile,
                type: "tile"
            });
            this.drawQueuedObjects();
        }
    },

    appendElementToOverlayPaneWithId: {
        value: function (element, paneId) {
            var pane = this.overlayPaneWithId(paneId);
            if (pane) {
                pane.appendChild(element);
            }
        }
    },

    baseMap: {
        get: function () {
            return this._baseMap;
        },
        set: function (value) {
            if (value && value !== this._baseMap) {
                this._baseMap = value;
                this._updateBaseMap();
            }
        }
    },

    bbox: {
        value: [0, 0, 0, 0]
    },

    bounds: {
        value: null
    },

    centerOnFeature: {
        value: function (feature) {}
    },

    clearOverlayEvents: {
        value: function (component) {}
    },

    coordinateToMercatorPoint: {
        value: function (coordinate) {
            var siny = Math.min(Math.max(Math.sin(coordinate[1] * (Math.PI / 180)), -.9999), .9999);
            return {
                x: 128 + coordinate[0] * (256/360),
                y: 128 + 0.5 * Math.log((1 + siny) / (1 - siny)) * -(256 / (2 * Math.PI))
            };
        }
    },

    coordinateToPoint: {
        value: function (coordinate) {}
    },

    coordinateToPixels: {
        value: function (coordinate) {
            var point = this.coordinateToMercatorPoint(coordinate),
                x = point.x * Math.pow(2, this.position.zoom),
                y = point.y * Math.pow(2, this.position.zoom);
            return {x: x, y: y};
        }
    },

    createBounds: {
        value: function (minPoint, maxPoint) {}
    },

    currentBounds: {
        value: function () {}
    },

    didZoom: {
        value: function () {
            for (var key in this.overlayRegistry) {
                var overlay = this.overlayRegistry[key];
                if (overlay && overlay.component) {
                    overlay.component.didZoom();
                }
            }
        }
    },

    draggable: {
        get: function () {
            return this._draggable;
        },
        set: function (value) {
            if (this._draggable !== value) {
                this._draggable = value;
                if (value === true) {
                    this._enablePan();
                } else {
                    this._disablePan();
                }
            }
        }
    },

    draw: {

        enumerable: false,
        value: function () {

            if (this._mapLoaded) {

                if (this.map === null) {
                    this._initializeMap();
                }

                if (this.map && this.isInitialized) {
                    while (this._queuedOverlays.length > 0) {

                        var overlayObject = this._queuedOverlays.shift(),
                            overlay = overlayObject.overlay,
                            action = overlayObject.action;

                        if (action === "add") {
                            this._createOverlay(overlay);
                        } else {
                            this._removeOverlay(overlay);
                        }
                    }
                } else {
                    var self = this;
                    setTimeout(function () {
                        self.needsDraw = true;
                    }, 0);

                }
            }
        }
    },

    drawCluster: {
        value: function (key, cluster) {
            var symbols;
            switch (key) {
                case MockLayer.Protocol.PDCHP:
                case Protocol.HAZARD:
                    symbols = this._drawHazardCluster(cluster);
                    break;
                case MockLayer.Protocol.AGS:
                case MockLayer.Protocol.Camera:
                case MockLayer.Protocol.Product:
                case Protocol.ARCGIS:
                    symbols = this._drawFeatureCluster(cluster);
                    break;
            }
            return symbols;
        }
    },

    drawFeature: {
        value: function (feature) {
            var geometry = feature.geometry,
                self = this,
                symbol;

            switch (geometry.type) {
                case "Point":
                    symbol = this._drawPointFeature(feature);
                    break;
                case "MultiPoint":
                    symbol = this._drawMultiPointFeature(feature);
                    break;
                case "LineString":
                    symbol = this._drawLineFeature(feature);
                    break;
                case "MultiLineString":
                    symbol = this._drawMultiLineFeature(feature);
                    break;
                case "Polygon":
                case "MultiPolygon":
                    symbol = this._drawPolygonFeature(feature);
                    break;
                case "GeometryCollection":
                    if ( Array.isArray(geometry.geometries) ) {
                        symbol = geometry.geometries.map(function ( geometry ) {
                            var properties = feature.properties;
                            properties.type = geometry.type;

                            return self.drawFeature({
                                type: "Feature",
                                geometry: geometry,
                                properties: properties
                            });
                        });
                    }
                    break;
                case "GroundOverlay":
                    symbol = this._drawGroundOverlayFeature(feature);
                    break;
            }
            return symbol;
        }
    },

    drawQueuedObjects: {
        value: function () {
            if (this._drawTimer === null) {
                var self = this;
                setTimeout(function() {
                    self.needsDraw = true;
                    self._drawTimer = null;
                }, 200);
            }
        }
    },

    drawSymbol: {
        value: function (symbol) {
            var geometry = symbol.geometry,
                mapSymbol;

            switch (geometry.type) {
                case "Point":
                    mapSymbol = this._drawPointSymbol(symbol);
                    break;
            }
            return mapSymbol;
        }
    },

    exitDocument: {
        value: function () {
            this.overlayRegistry = {};
        }
    },

    exportBaseMapToJpeg: {
        value: function (context, exceptions) {
            return this._exportRasterLayerToJpeg(this.application.delegate.baseMap, context, exceptions);
        }
    },

    exportFiguresToJpeg: {
        value: function (context, exceptions) {
            var self = this;
            return new Promise(function (resolve, reject) {
                var key, overlay, string, blob,
                    imagesToLoad = [], serializer = new XMLSerializer(),
                    offset = self.coordinateToPoint([self.bounds.west, self.bounds.north]),
                    DOMURL = window.URL || window.webkitURL || window;
                for (key in self.overlayRegistry) {
                    overlay = self.overlayRegistry[key];
                    if (overlay.component.figure) {
                        string = serializer.serializeToString(overlay.component.element);
                        blob = new Blob([string], {type: 'image/svg+xml;charset=utf-8'});
                        imagesToLoad.push({
                            element: overlay.component.element,
                            url: DOMURL.createObjectURL(blob)
                        });
                    }
                }
                if (imagesToLoad.length > 0) {
                    self._loadFeatureImages(imagesToLoad, exceptions, function (loadedImages) {
                        var i, n, symbol;
                        for (i = 0, n = loadedImages.length; i < n; ++i) {
                            symbol = loadedImages[i];
                            context.save();
                            context.drawImage(
                                symbol.image,
                                parseInt(symbol.element.style.left) - offset.x,
                                parseInt(symbol.element.style.top) - offset.y,
                                parseInt(symbol.element.getAttribute("width")),
                                parseInt(symbol.element.getAttribute("height"))
                            );
                            context.restore();
                        }
                        resolve(null);
                    });
                } else {
                    resolve(null);
                }
            });
        }
    },

    exportLayerToJpeg: {
        value: function (layer, context, exceptions) {
            if (layer.type === Layer.Type.RASTER) {
                return this._exportRasterLayerToJpeg(layer, context, exceptions);
            } else if (layer.type === Layer.Type.FEATURE && layer === this.application.delegate.layers.hazard) {
                return this._exportHazardLayerToJpeg(layer, context, exceptions);
            } else if (layer.type === Layer.Type.FEATURE) {
                return this._exportFeatureLayerToJpeg(layer, context, exceptions);
            }
            return null;
        }
    },

    extendBounds: {
        value: function (bounds) {}
    },

    fitToBounds: {
        value: function (bounds) {}
    },

    getLatLngBoundsForTile: {

        value: function (tile) {

            var tilesPerSide = Math.pow(2, tile.z),
                southWestPoint = {
                    x: tile.x * 256 / tilesPerSide,
                    y: (tile.y + 1) * 256 / tilesPerSide
                },
                northEastPoint = {
                    x: (tile.x + 1) * 256 / tilesPerSide,
                    y: tile.y * 256 / tilesPerSide
                },
                southWestCoordinate = this.mercatorPointToCoordinate(southWestPoint),
                northEastCoordinate = this.mercatorPointToCoordinate(northEastPoint);

            return [southWestCoordinate, northEastCoordinate];
        }
    },

    isInitialized: {
        value: false
    },

    layerAnimationController: {
        value: null
    },

    map: {
        value: null
    },

    maxScale: {
        value: -1
    },

    maxZoomLevelAtCoordinate: {
        value: function (coordinate, callback) {}
    },

    mercatorPointToCoordinate: {
        value: function (point) {
            var lng = (point.x - 128) / (256 / 360),
                lat = (2 * Math.atan(Math.exp((point.y - 128) / -(256 / (2 * Math.PI)))) -
                    Math.PI / 2)/ (Math.PI / 180);
            return [lng, lat];
        }
    },

    minScale: {
        value: -1
    },

    move: {
        value: function (direction, amount) {}
    },

    overlayRegistry: {
        get: function () {
            if (this._overlayRegistry === null) {
                this._overlayRegistry = {};
            }
            return this._overlayRegistry;
        }
    },

    pointWithinBounds: {
        value: function (point, bounds) {}
    },

    pointToCoordinate: {
        value: function (point) {}
    },

    pointToContainerCoordinate: {
        value: function (point) {}
    },

    position: {
        value: null
    },

    redrawFeature: {
        value: function (feature) {
            var oldSymbol = feature.layer.symbols[this.uuid][feature.id];
            if (oldSymbol) {
                feature.layer.symbols[this.uuid][feature.id] = this.drawFeature(feature);
                this.removeSymbol(oldSymbol);
            }
        }
    },

    removeElementFromOverlayPaneWithId: {
        value: function (element, paneId) {
            var pane = this.overlayPaneWithId(paneId);
            if (pane && element.parentNode === pane) {
                pane.removeChild(element);
            }
        }
    },

    removeOverlayComponent: {
        value: function (component) {
            var overlayId = component.uuid,
                overlay = this.overlayRegistry[overlayId];
            if (overlay) {
                this._queuedOverlays.push({
                    overlay: overlay,
                    action: "remove"
                });
                delete this.overlayRegistry[overlayId];
                this.needsDraw = true;
            }
        }
    },

    removeSymbol: {
        value: function (symbol) {}
    },

    setCenter: {
        value: function (coordinate) {}
    },

    setCenterAndZoom: {
        value: function (coordinate, zoom) {}
    },

    setZoom: {
        value: function (level) {}
    },

    showFeatures: {
        value: function (overlayId) {
        }
    },

    size: {
        value: {
            height: 0,
            width: 0
        }
    },

    tileBounds: {
        get: function () {
            return this._tileBounds;
        },
        set: function (value) {
            if (value) {
                this._tileBounds = value;
            }
        }
    },

    viewPortOffset: {
        value: function () {}
    },

    willZoom: {
        value: function () {
            var key, overlay;
            for (key in this.overlayRegistry) {
                overlay = this.overlayRegistry[key];
                if (overlay && overlay.component) {
                    overlay.component.willZoom();
                }
            }
        }
    }
});
