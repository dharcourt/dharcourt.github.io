/**
 * @module ui/map/figure-component.js
 * @requires montage/ui/component
 */
var OverlayComponent = require("ui/map/overlay-component").OverlayComponent,
    FigureType = require("logic/model/figure").FigureType,
    Renderer = require("logic/map/renderer").Renderer;


// TODO: Move renderer's utilities code into a common utilities class.

/**
 * @class FigureComponent
 * @extends Component
 */
var FigureComponent = exports.FigureComponent = OverlayComponent.specialize(/** @lends FigureComponent.prototype */ {

    constructor: {
        value: function FigureComponent() {
            if (this.constructor === FigureComponent) {
                throw new Error("FigureComponent cannot be instantiated.");
            }
        }
    },

    _bounds: {
        value: {
            xMin: 0,
            xMax: 0,
            yMin: 0,
            yMax: 0
        }
    },

    didDraw: {
        value: function() {
            if (this.figure && this.figure.type == FigureType["Placemark"] && this.element.style.visibility === "hidden") {
                this.needsDraw = true;
            }
        }
    },

    _drawAnnotation: {
        value: function () {
            if (this.figure.coordinates) {

                var rectangle,
                    textElement,
                    textMeasurement,
                    text = this.figure.mapTip.split(/\n/g),
                    labelBoxPadding = 6,
                    spans,
                    i, length;

                rectangle = this.element.querySelector("rect");
                if (! rectangle) {
                    rectangle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    this.element.appendChild(rectangle);
                }

                rectangle.setAttributeNS(null, 'fill', this.figure.fillColor);
                rectangle.setAttributeNS(null, 'fill-opacity', this.figure.fillOpacity);
                rectangle.setAttributeNS(null, 'stroke', this.strokeColor());
                rectangle.setAttributeNS(null, 'stroke-opacity', this.figure.strokeOpacity);
                rectangle.setAttributeNS(null, 'stroke-width', this.figure.strokeWidth);

                textElement = this.element.querySelectorAll("text")[0];
                if (! textElement) {
                    textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    this.element.appendChild(textElement);
                }

                textElement.style.fill = this.figure.fontColor;
                textElement.style.fontFamily = "Proxima Nova, sans-serif";
                textElement.style.fontSize = this.figure.fontSize + "px";
                textElement.style.stroke = 'none';

                // prune unneeded tspans
                while (textElement.childNodes.length > text.length) {
                    textElement.removeChild(textElement.lastChild);
                }

                spans = textElement.querySelectorAll("tspan");

                for (i = 0, length = text.length; i < length; i++) {
                    var span = spans[i];
                    if (! span) {
                        span = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        span.setAttributeNS(null, "text-anchor", "start");
                        textElement.appendChild(span);
                    }
                    span.textContent = text[i];
                    span.setAttributeNS(null, "alignment-baseline", "middle");
                    span.setAttributeNS(null, "x", this.figure.strokeWidth);
                    span.setAttributeNS(null, "dx", labelBoxPadding);
                    if (i == 0) {
                        // Works better in webkit to multiply the font size value by .75 for the first tspan.
                        // Firefox seems to prefer the full height... not sure what is a solution that
                        // accomodates both browsers.
                        span.setAttributeNS(null, "dy", this.figure.strokeWidth + this.figure.fontSize *.75);
                    } else {
                        span.setAttributeNS(null, "dy", this.figure.fontSize);
                    }
                }

                // Note: We multiply font size by a quarter to create a vertical padding that is realtive to the
                // font size because that looks more natural when resizing verse a fixed padding size.
                textMeasurement = textElement.getBBox();
                var width = textMeasurement.width + labelBoxPadding * 2 + this.figure.strokeWidth,
                    height = textMeasurement.height + this.figure.fontSize * .25 + this.figure.strokeWidth;

                this.element.setAttributeNS(null, "width", width + this.figure.strokeWidth);
                this.element.setAttributeNS(null, "height", height + this.figure.strokeWidth);
                rectangle.setAttributeNS(null, "width", width);
                rectangle.setAttributeNS(null, "height", height);
                rectangle.setAttributeNS(null, "x", this.figure.strokeWidth / 2);
                rectangle.setAttributeNS(null, "y", this.figure.strokeWidth / 2);
            }
        }
    },

    _drawCircle: {
        value: function () {
            var strokeWidth = this.figure.strokeWidth,
                circle,
                i,
                length,
                points = this.points[0] || [],
                polygonPoints = "",
                point;

            circle = this.element.querySelector("polygon");

            if (! circle) {
                circle = document.createElementNS('http://www.w3.org/2000/svg','polygon');
                this.element.appendChild(circle);
            }

            for (i = 0, length = points.length; i < length; i++) {
                point = points[i];
                var x = point.x - this.bounds.xMin,
                    y = point.y - this.bounds.yMin;
                polygonPoints += x;
                polygonPoints += ",";
                polygonPoints += y;
                if (points.length > 0) {
                    polygonPoints += " ";
                }
            }

            circle.setAttributeNS(null, "width", this.element.clientWidth);
            circle.setAttributeNS(null, "height", this.element.clientHeight);
            circle.setAttributeNS(null, 'fill', this.figure.fillColor);
            circle.setAttributeNS(null, 'fill-opacity', this.figure.fillOpacity);
            circle.setAttributeNS(null, 'stroke-opacity', this.figure.strokeOpacity);
            circle.setAttributeNS(null, 'stroke-width', strokeWidth);
            circle.setAttributeNS(null, 'stroke', this.strokeColor());
            circle.setAttributeNS(null, 'points', polygonPoints);
        }
    },

    _drawDistanceLabels: {
        value: function () {
            var i, length,
                distanceLabel, distance;
            for (i = 0, length = this.figure.distanceLabels.length; i < length; i++) {
                distanceLabel = this.figure.distanceLabels[i];
                if (distanceLabel) {
                    distance = distanceLabel.distance;
                    if (this.figure.units === "imperial") {
                        distance = distance * 0.386102;
                    }
                    this._drawLabel(distanceLabel.midPoint, this.figure.formatLabel(distance), i);
                }
            }
        }
    },

    _drawImage: {
        value: function() {
            var image,width,height,rectangle;

            rectangle = this.element.querySelector("rect");
            if (! rectangle) {
                rectangle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                this.element.appendChild(rectangle);
                rectangle.setAttributeNS(null, 'fill-opacity', 0);
            }
            image = this.element.querySelector("image");
            if (!image) {
                image = document.createElementNS('http://www.w3.org/2000/svg','image');
                this.element.appendChild(image);
            }

            width = this.figure.cartesian.width - 20;
            height = this.figure.cartesian.height - 20;

            image.setAttributeNS(null,"width",width);
            image.setAttributeNS(null,"height",height);
            image.setAttributeNS(null,"opacity",this.figure.imageOpacity);
            image.setAttributeNS(null,"preserveAspectRatio","none");
            image.setAttributeNS(null,"x",10);
            image.setAttributeNS(null,"y",10);
            image.setAttributeNS("http://www.w3.org/1999/xlink","href",this.figure.dataURL);
            rectangle.setAttributeNS(null,"width",width+this.figure.strokeWidth);
            rectangle.setAttributeNS(null,"height",height+this.figure.strokeWidth);
            rectangle.setAttributeNS(null,"x",10-(this.figure.strokeWidth/2));
            rectangle.setAttributeNS(null,"y",10-(this.figure.strokeWidth/2));
            rectangle.setAttributeNS(null, 'stroke-opacity', this.figure.strokeOpacity);
            rectangle.setAttributeNS(null, 'stroke-width', this.figure.strokeWidth);
            rectangle.setAttributeNS(null, 'stroke', this.strokeColor());
        }
    },

    _drawLabel: {
        value: function (anchor, text, index) {

            index = index !== undefined ? index : 0;

            if (text !== undefined) {

                var label,
                    labelBox,
                    labelBoxPadding = 6,
                    textMeasurement,
                    centerX = anchor.x - this.bounds.xMin,
                    centerY = anchor.y - this.bounds.yMin;


                labelBox = this.element.querySelectorAll("rect.contour-FigureOverlay-rect-LabelBox")[index];
                if (!labelBox) {
                    labelBox = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    labelBox.setAttributeNS(null, 'class', "contour-FigureOverlay-rect-LabelBox");
                    labelBox.setAttributeNS(null, 'fill', "#FFFFFF");
                    labelBox.setAttributeNS(null, 'fill-opacity', 1.0);
                    this.element.appendChild(labelBox);
                }

                if (this.figure.displayLabelBorder) {
                    labelBox.setAttributeNS(null, 'stroke', this.figure.labelStrokeColor);
                    labelBox.setAttributeNS(null, 'stroke-opacity', this.figure.labelStrokeOpacity);
                    labelBox.setAttributeNS(null, 'stroke-width', this.figure.labelStrokeWidth);
                } else {
                    labelBox.setAttributeNS(null, 'stroke', 'none');
                }

                label = this.element.querySelectorAll("text")[index];
                if (!label) {
                    label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    this.element.appendChild(label);
                }

                label.textContent = text;
                label.setAttributeNS(null, 'x', centerX);
                label.setAttributeNS(null, 'y', centerY);
                label.style.fill = this.figure.fontColor;
                label.style.fontFamily = "Proxima Nova, sans-serif";
                label.style.fontSize = this.figure.fontSize + "px";
                label.style.stroke = 'none';
                label.style.textAnchor = "middle";
                label.style.dominantBaseline = "central";
                textMeasurement = label.getBBox();

                if (textMeasurement.width !== 0 && textMeasurement.height !== 0) {
                    var width = textMeasurement.width + labelBoxPadding * 2 + this.figure.labelStrokeWidth * 2,
                        height = textMeasurement.height + labelBoxPadding * 2 + this.figure.labelStrokeWidth * 2;

                    labelBox.setAttributeNS(null, "x", centerX - width / 2);
                    labelBox.setAttributeNS(null, "y", centerY - height / 2);
                    labelBox.setAttributeNS(null, "width",  width);
                    labelBox.setAttributeNS(null, "height", height);
                } else {
                    this.needsDraw = true;
                }
            }
        }
    },

    _drawLine: {
        value: function () {

            var end = this.points[1][1],
                start = this.points[1][0],
                strokeWidth = this.figure.strokeWidth,
                line;

            line = this.element.querySelector("line");

            if (!line) {
                line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                var labelBox = this.element.querySelector("rect.contour-FigureOverlay-rect-LabelBox");
                if (labelBox) {
                    this.element.insertBefore(line,labelBox);
                } else {
                    this.element.appendChild(line);
                }
            }

            line.setAttributeNS(null, 'x1', start.x - this.bounds.xMin);
            line.setAttributeNS(null, 'y1', start.y - this.bounds.yMin);
            line.setAttributeNS(null, 'x2', end.x - this.bounds.xMin);
            line.setAttributeNS(null, 'y2', end.y - this.bounds.yMin);
            line.setAttributeNS(null, 'stroke-width', strokeWidth);
            line.setAttributeNS(null, 'stroke', this.strokeColor());
        }
    },

    _drawPlacemark: {
        value: function () {

            var defs = this.element.querySelectorAll("defs")[0],
                textElement = this.element.querySelectorAll("text")[0],
                spans, span, verticalPadding, textLength;

            if (! defs) {
                var filter,
                    feFlood,
                    feOffset,
                    feGaussianBlur,
                    feComposite,
                    feMerge,
                    feMergeNodeOne, feMergeTwo;

                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
                filter.setAttributeNS(null, "id", "dropshadow"+this.uuid);
                feGaussianBlur = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
                feGaussianBlur.setAttributeNS(null, "stdDeviation", "2.2");
                feGaussianBlur.setAttributeNS(null, "in", "SourceAlpha");
                filter.appendChild(feGaussianBlur);
                feOffset = document.createElementNS('http://www.w3.org/2000/svg', 'feOffset');
                feOffset.setAttributeNS(null, "dx", "0");
                feOffset.setAttributeNS(null, "dy", "2");
                feOffset.setAttributeNS(null, "result", "offsetblur");
                filter.appendChild(feOffset);
                feFlood = document.createElementNS('http://www.w3.org/2000/svg', 'feFlood');
                feFlood.setAttributeNS(null, "flood-color", "rgba(0,0,0,0.5)");
                filter.appendChild(feFlood);
                feComposite = document.createElementNS('http://www.w3.org/2000/svg', 'feComposite');
                feComposite.setAttributeNS(null, "in2", "offsetblur");
                feComposite.setAttributeNS(null, "operator", "in");
                filter.appendChild(feComposite);
                feMerge = document.createElementNS('http://www.w3.org/2000/svg', 'feMerge');
                filter.appendChild(feMerge);
                feMergeNodeOne = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                feMerge.appendChild(feMergeNodeOne);
                feMergeTwo = document.createElementNS('http://www.w3.org/2000/svg', 'feMergeNode');
                feMergeTwo.setAttributeNS(null, "in", "SourceGraphic");
                feMerge.appendChild(feMergeTwo);
                defs.appendChild(filter);
                this.element.appendChild(defs);
            }

            if (! textElement) {
                textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                this.element.appendChild(textElement);
                this.element.style.visibility = "hidden";
            } else {
                this.element.style.visibility = "visible";
            }

            textElement.style.fontFamily = "Contour";
            textElement.style.fontSize = this.figure.fontSize + "px";
            textElement.style.stroke = 'none';
            textElement.style.textAnchor = "middle";

            spans = textElement.querySelectorAll("tspan");
            if (spans.length === 0) {
                spans = [];
            }

            if (this.figure.isCrosshair) {
                if (! spans[0]) {
                    span = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    textElement.appendChild(span);
                    spans.push(span);
                }

                verticalPadding = (this.figure.cartesian.height - this.figure.fontSize)/2;
                textElement.setAttributeNS(null,"dx",this.figure.cartesian.width/2);
                textElement.setAttributeNS(null,"dy",this.figure.cartesian.height - verticalPadding);
                spans[0].textContent = this.figure.textCharacter;
                spans[0].style.fontSize = this.figure.fontSize + "px";
                textLength = spans[0].getComputedTextLength();
                if (textLength == 0) {
                    textLength = this.figure.fontSize;
                }
                spans[0].setAttributeNS(null, "dy", "135%");
                spans[0].style.fill = this.figure.fontColor;

            } else {
                if (! spans[0]) {
                    span = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    span.style.fontSize = this.figure.fontSize + "px";
                    span.setAttributeNS(null, "filter", "url(#dropshadow"+this.uuid+")");
                    span.setAttributeNS(null, "y", 0);
                    span.style.fill = "#FFFFFF";
                    span.textContent = "\ue65a";
                    textElement.appendChild(span);
                    spans.push(span);
                }

                if (! spans[1]) {
                    span = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    textElement.appendChild(span);
                    spans.push(span);
                }

                verticalPadding = (this.figure.cartesian.height - this.figure.fontSize)/2;
                textElement.setAttributeNS(null,"dx",this.figure.cartesian.width/2);
                textElement.setAttributeNS(null,"dy",this.figure.cartesian.height - verticalPadding);

                spans[1].textContent = this.figure.textCharacter;
                spans[1].style.fontSize = (0.95 * this.figure.fontSize) + "px";
                textLength = spans[0].getComputedTextLength();
                if (textLength == 0) {
                    textLength = this.figure.fontSize;
                }
                spans[1].setAttributeNS(null, "dx", -(textLength * 0.975));
                spans[1].setAttributeNS(null, "dy", -(this.figure.fontSize * 0.025));
                spans[1].style.fill = this.figure.fontColor;
            }

        }
    },

    _drawPolygon: {
        value: function () {

            var i, length,
                point, pointsStringBuffer = "",
                polygon;

            polygon = this.element.querySelector("polygon");

            if (! polygon) {
                polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                this.element.appendChild(polygon);
            }

            for (i = 0, length = this.points.length; i < length;) {
                point = this.points[i];
                pointsStringBuffer += (point.x - this.bounds.xMin);
                pointsStringBuffer += ",";
                pointsStringBuffer += (point.y - this.bounds.yMin);
                i++;
                if (i < length) {
                    pointsStringBuffer += " ";
                }
            }

            polygon.setAttributeNS(null, "points", pointsStringBuffer);
            polygon.setAttributeNS(null, "fill", this.figure.fillColor);
            polygon.setAttributeNS(null, "fill-opacity", this.figure.fillOpacity);
            polygon.setAttributeNS(null, 'stroke', this.strokeColor());
            polygon.setAttributeNS(null, 'stroke-opacity', this.figure.strokeOpacity);
            polygon.setAttributeNS(null, 'stroke-width', this.figure.strokeWidth);
        }
    },

    _drawPolyline: {
        value: function () {

            var i, length,
                point, pointsStringBuffer = "",
                polyline;

            polyline = this.element.querySelector("polyline");

            if (! polyline) {
                polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                this.element.appendChild(polyline);
            }

            for (i = 0, length = this.points.length; i < length;) {
                point = this.points[i];
                pointsStringBuffer += (point.x - this.bounds.xMin);
                pointsStringBuffer += ",";
                pointsStringBuffer += (point.y - this.bounds.yMin);
                i++;
                if (i < length) {
                    pointsStringBuffer += " ";
                }
            }

            polyline.setAttributeNS(null, "points", pointsStringBuffer);
            polyline.setAttributeNS(null, "fill", "none");
            polyline.setAttributeNS(null, 'stroke', this.strokeColor());
            polyline.setAttributeNS(null, 'stroke-opacity', this.figure.strokeOpacity);
            polyline.setAttributeNS(null, 'stroke-width', this.figure.strokeWidth);
        }
    },

    _drawRectangle: {
        value: function () {

            var points = this.points,
                height = Math.abs(points[0].y - points[3].y),
                width = Math.abs(points[1].x - points[0].x),
                rectangle;

            rectangle = this.element.querySelector("rect");

            if (! rectangle) {
                rectangle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                this.element.appendChild(rectangle);
            }

            rectangle.setAttributeNS(null, "x", 10);
            rectangle.setAttributeNS(null, "y", 10);
            rectangle.setAttributeNS(null, "width", width);
            rectangle.setAttributeNS(null, "height", height);
            rectangle.setAttributeNS(null, 'fill', this.figure.fillColor);
            rectangle.setAttributeNS(null, 'fill-opacity', this.figure.fillOpacity);
            rectangle.setAttributeNS(null, 'stroke', this.strokeColor());
            rectangle.setAttributeNS(null, 'stroke-opacity', this.figure.strokeOpacity);
            rectangle.setAttributeNS(null, 'stroke-width', this.figure.strokeWidth);
        }
    },

    _elementName: {
        value: null
    },

    _figure: {
        value: null
    },

    _isReadyForDraw: {
        get: function () {
            var isReady = true;
            switch (this.figure.type) {
                case FigureType["Annotation"]:
                case FigureType["Placemark"]:
                    isReady = (typeof this.figure.cartesian.center !== "undefined");
                    break;
                case FigureType["Circle"]:
                    isReady = (typeof this.figure.cartesian.center !== "undefined");
                    if (this.figure.hasLabel && this.figure.labelType === "buffer") {
                        isReady = (this.points && this.points[1]);
                    }
                    break;
                case FigureType["Image"]:
                case FigureType["Rectangle"]:
                    isReady = (this.points && this.points.length == 4);
                    break;
                case FigureType["Polyline"]:
                    isReady = (this.points && this.points.length > 1);
                    break;
                case FigureType["Polygon"]:
                    isReady = (this.points && this.points.length > 2);
                    break;
            }
            return isReady;
        }

    },

    _points: {
        value: []
    },

    _removeLabels: {
        value: function() {
            var labelBoxes = this.element.querySelectorAll("rect.contour-FigureOverlay-rect-LabelBox"),
                labels = this.element.querySelectorAll("text"),
                i,length;

            for (i = 0, length = Math.max(labelBoxes.length,labels.length); i < length; i++) {
                if (i < labels.length) {
                    this.element.removeChild(labels[i]);
                }
                if (i < labelBoxes.length) {
                    this.element.removeChild(labelBoxes[i]);
                }
            }
        }
    },

    _removeLine: {
        value: function() {
            var line = this.element.querySelector("line");
            if (line) {
                this.element.removeChild(line);
            }
        }
    },

    bounds: {
        get: function () {
            if (this.figure) {
                return this.figure.cartesian.bounds;
            } else {
                return this._bounds;
            }
        },
        set: function (value) {
            if (this.figure) {
                this.figure.cartesian.bounds = value;
            } else {
                this._bounds = value;
            }
        }
    },

    clearCanvas: {
        value: function () {
            while (this.element.lastChild) {
                this.element.removeChild(this.element.lastChild);
            }
            this._elementName = null;
        }
    },

    draw: {
        value: function () {
            this.updateGeometry();
            if (this._isReadyForDraw) {
                switch (this.figure.type) {
                    case FigureType["Annotation"]:
                        this._drawAnnotation();
                        break;
                    case FigureType["Placemark"]:
                        this._drawPlacemark();
                        break;
                    case FigureType["Image"]:
                        this._drawImage();
                        break;
                    case FigureType["Rectangle"]:
                        this._drawRectangle();
                        break;
                    case FigureType["Circle"]:
                        this._drawCircle();
                        if (this.figure.hasLabel) {
                            if (this.figure.properties.labelType === "buffer") {
                                this._drawLine();
                            } else if (this.figure.needsLabelUpdate) {
                                this._removeLine();
                                this.figure.needsLabelUpdate = false;
                            }
                            if (this.figure.cartesian.center) {
                                this._drawLabel(this.figure.cartesian.center, this.figure.label);
                            }
                        } else if (this.figure.needsLabelUpdate) {
                            this._removeLabels();
                            this._removeLine();
                            this.figure.needsLabelUpdate = false;
                        }
                        break;
                    case FigureType["Polyline"]:
                        this._drawPolyline();
                        if (this.figure.hasLabel && this.figure.distanceLabels) {
                            this._drawDistanceLabels();
                        } else if (this.figure.needsLabelUpdate) {
                            this._removeLabels();
                            this.figure.needsLabelUpdate = false;
                        }
                        break;
                    case FigureType["Polygon"]:
                        this._drawPolygon();
                        if (this.figure.hasLabel && this.figure.coordinates.length > 2) {
                            this._drawLabel(this.figure.cartesian.center, this.figure.label);
                        } else if (this.figure.needsLabelUpdate) {
                            this._removeLabels();
                            this.figure.needsLabelUpdate = false;
                        }
                        break;
                }
            }
        }
    },

    elementName: {
        get: function () {
            if (this._elementName === null) {
                switch (this.figure.type) {
                    case FigureType["Polyline"]:
                        this._elementName = "polyline";
                        break;
                    case FigureType["Polygon"]:
                        this._elementName = "polygon";
                        break;
                    case FigureType["Rectangle"]:
                        this._elementName = "rect";
                        break;
                    case FigureType["Image"]:
                        this._elementName = "image";
                        break;
                }
            }
            return this._elementName;
        }
    },

    figure: {
        get: function () {
            return this._figure;
        },
        set: function (value) {
            if (this._figure !== value) {
                if (this._figure) {
                    this._figure.removeComponent(this);
                    this.clearCanvas();
                }
                this._figure = value;

                if (this._figure) {
                    this._figure.addComponent(this);
                }
            }
        }
    },

    hasTemplate: {
        value: true
    },

    points: {
        get: function () {
            if (this.figure) {
                return this.figure.cartesian.points;
            } else {
                return this._points;
            }
        },
        set: function (value) {
            if (this.figure) {
                this.figure.cartesian.points = value;
            } else {
                this._points = value;
            }
        }
    },

    strokeColor: {
        value: function () {
            return this.figure.strokeColor;
        }
    },

    updateGeometry: {
        value: function () {
            var bounds = this.figure.cartesian.bounds,
                height = Math.abs(bounds.yMax - bounds.yMin),
                width = Math.abs(bounds.xMax - bounds.xMin);

            this.element.setAttributeNS(null, "width", width);
            this.element.setAttributeNS(null, "height", height);
        }
    },


    width: {
        get: function () {
            if (this.figure) {
                return this.figure.cartesian.bounds;
            } else {
                return this._bounds;
            }
        },
        set: function (value) {
            if (this.figure) {
                this.figure.cartesian.bounds = value;
            } else {
                this._bounds = value;
            }
        }
    },

});
