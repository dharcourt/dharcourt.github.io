/**
 * @module ui/map-tip-overlay.reel
 * @requires montage/ui/component
 */
var OverlayComponent = require("ui/map/overlay-component").OverlayComponent,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    PressComposer = require("montage/composer/press-composer").PressComposer;

/**
 * @class MaptipOverlay
 * @extends Component
 */
exports.MapTipOverlay = OverlayComponent.specialize(/** @lends MaptipOverlay# */ {

    constructor: {
        value: function MapTipOverlay() {
            //this.super();
        }
    },

    _engine: {
        value: null
    },

    _feature: {
        value: null
    },

    _deregister: {
        value: function () {
            if (this._engine) {
                delete this.feature.mapTip;
                delete this.feature.properties._mapTipPinned;
                this._engine.removeOverlayComponent(this);
                this._removeMapTipFromHoveredList();
                this.isTransparent = true;
            }
        }
    },

    _isFocused: {
        value: null
    },

    _isHovered: {
        value: false
    },

    _needsPositioning: {
        value: false
    },

    __needsTransparencyRemoved: {
        value: null
    },

    _needsTransparencyRemoved: {
        get: function () {
            if (this.__needsTransparencyRemoved === null) {
                this.__needsTransparencyRemoved = false;
            }
            return this.__needsTransparencyRemoved;
        },
        set: function (value) {
            this.__needsTransparencyRemoved = value;
        }
    },

    _position: {
        value: null
    },

    _positionMapTipOverlay: {
        value: function (component) {
            var feature = component.feature,
                element = component.element,
                width = element.offsetWidth,
                height = element.offsetHeight,
                symbolOffset,
                coordinate = feature.properties.clusterCoordinate || feature.geometry.coordinates,
                point;

            if (feature.geometry && (feature.geometry.type === "Point" || feature.geometry.type === "MultiPoint")) {
                symbolOffset = feature.properties.iconDimensions;
                if (feature.properties.clusterCoordinate) {
                    coordinate = feature.properties.clusterCoordinate;
                } else if (feature.geometry.type === "Point") {
                    coordinate = feature.geometry.coordinates;
                } else if (feature.geometry.type === "MultiPoint") {
                    coordinate = feature.geometry.coordinates[0];
                }
            } else {
                coordinate = feature.properties.clickPosition;
            }

            symbolOffset = symbolOffset || {
                height: 0,
                width: 0
            };

            point = this.engine.coordinateToPoint(coordinate);
            point.x = point.x - width / 2;
            point.y = point.y - height - symbolOffset.height / 2 - 4;
            element.style.left = point.x + "px";
            element.style.top = point.y + "px";
        }
    },

    _register: {
        value: function () {
            if (this.feature && this.featureType && this.featureType === this.feature.type) {
                this._shouldAddToEngine = true;
                this.needsDraw = true;
            }
        }
    },

    _removeMapTipFromHoveredList: {
        value: function () {
            var index = this.mapComponent.hoveredMapTips.indexOf(this);
            if (index > -1) {
                this.mapComponent.hoveredMapTips.splice(index, 1);
            }
        }
    },

    _shouldAddToEngine: {
        value: false
    },

    _templateWasLoaded: {
        value: false
    },

    _type: {
        value: OverlayType["Maptip"]
    },

    productMapTipState: {
        value: "Gallery"
    },

    captureDblclick: {
        value: function (event) {
            event.stopPropagation();
        }
    },

    //captureClick: {
    //    value: function(event) {
    //        console.log("Stop click propagation...");
    //        event.stopPropagation();
    //    }
    //},

    captureMouseover: {
        value: function () {
            var index = this.mapComponent.hoveredMapTips.indexOf(this);
            if (index === -1) {
                this.mapComponent.hoveredMapTips.push(this);
            }
        }
    },

    captureMouseout: {
        value: function () {
            this._removeMapTipFromHoveredList();
        }
    },

    didAdd: {
        value: function () {
            this._needsPositioning = true;
            this.needsDraw = true;
        }
    },

    didZoom: {
        value: function () {
            this._needsPositioning = true;
            this.needsDraw = true;
            this.isZooming = false;
        }
    },

    draw: {
        value: function () {
            if (this._shouldAddToEngine === true && this.processing === false) {
                if (this._templateWasLoaded === true) {
                    this.processing = true;
                    this._engine.addOverlayComponent(this);
                    this._shouldAddToEngine = false;
                } else {
                    this.needsDraw = true;
                }
            }
            if (this._needsPositioning) {
                this._positionMapTipOverlay(this);
                this._needsPositioning = false;
                var self = this;
                setTimeout(function () {
                    self._needsTransparencyRemoved = true;
                    self.needsDraw = true;
                }, 0);
            }
            if (this._needsTransparencyRemoved) {
                this.isTransparent = false;
                this._needsTransparencyRemoved = false;
                this.processing = false;
            }
        }
    },

    editHazardButtonLabel: {
        value: "\e656"
    },

    engine: {
        get: function () {
            return this._engine;
        },
        set: function (value) {
            if (value && value !== this._engine) {
                if (this.feature && this._engine) {
                    this._deregister();
                }
                this._engine = value;
                this._register();
            }
        }
    },

    enterDocument: {
        value: function () {
            this._register();
            this.productMapTipState = "Gallery";
            this.element.addEventListener("mouseover", this, true);
            this.element.addEventListener("mouseout", this, true);
            this.element.addEventListener("dblclick", this, true);
            //this.element.addEventListener("click", this, true);
        }
    },

    engineEventHandlers: {
        value: []
    },

    exitDocument: {
        value: function () {
            this._deregister();
            this.element.removeEventListener("mouseover", this, true);
            this.element.removeEventListener("mouseout", this, true);
            this.element.removeEventListener("dblclick", this, true);
            //this.element.removeEventListener("click", this, true);
        }
    },

    feature: {
        get: function () {
            return this._feature;
        },
        set: function (value) {
            if (value && value !== this._feature) {
                this._feature = value;
                this._feature.mapTip = this;
                this.needsDraw = true;
            }
        }
    },

    featureType: {
        value: null
    },

    handleCloseMapTipButtonAction: {
        value: function (event) {
            event.stopPropagation();
            // [Jonathan] This looks really weird but it is the only
            // way I can stop the map tip from reopening on the Google
            // engine.  There is no way to capture/handle the event
            // before it goes to the engine.  So, it will always call
            // the click handler within the engine which can cause
            // the feature to get selected which triggers the map tip to
            // reopen.  But delaying this the click goes through but
            // the engine does not try to reopen a maptip for the symbol
            // because it thinks one is already open.
            var self = this;
            setTimeout(function () {
                self.mapComponent.deselectFeature(self.feature);
            }, 0);
        }
    },

    handleEditHazardButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.application.delegate.editHazard(this.feature);
        }
    },

    handleEnableDefaultLayersButtonAction: {
        value: function (event) {
            event.stopPropagation();
            // TODO awaiting the hazards/layers connection.
        }
    },

    handleListHazardProductsButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.application.delegate.listHazardProducts(this.feature);
        }
    },

    handleInspectHazardButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.application.delegate.inspectHazard(this.feature);
        }
    },

    handleInspectFeatureButtonAction: {
        value: function (event) {
            event.stopPropagation();
            // TODO awaiting the implementation of the feature inspector.
        }
    },

    handleInspectHazardAreaBriefButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.application.delegate.inspectHazardAreaBrief(this.feature);
        }
    },

    handleZoomToFeatureButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.application.delegate.centerOnAndZoomToFeature(this.feature);
        }
    },
    handleZoomToProductButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.application.delegate.centerOnAndZoomToFeature(this.feature);
        }
    },

    handleFullScreenButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.templateObjects.productsGallery.fullScreen = true;
        }
    },
    handleShowSummaryButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.productMapTipState = "Summary";

            this.didAdd();
        }
    },
    handleShowGalleryButtonAction: {
        value: function (event) {
            event.stopPropagation();
            this.productMapTipState = "Gallery";

            this.didAdd();
        }
    },

    handlePress: {
        value: function () {
            this.mapComponent.selectFeature(this.feature, true);
        }
    },

    hasTemplate: {
        value: true
    },

    isFocused: {
        get: function () {
            if (this._isFocused === null) {
                this._isFocused = false;
            }
            return this._isFocused;
        },
        set: function (value) {
            if (value !== null && value !== this._isFocused) {
                this._isFocused = value;
                if (this.feature && this.featureType === this.feature.type) {
                    this._needsPositioning = true;
                    this.needsDraw = true;
                }
            }
        }
    },

    isHovered: {
        get: function () {
            return this._isHovered;
        },
        set: function (value) {
            if (value !== null && value !== this._isHovered) {
                this._isHovered = value;
            }
        }
    },

    isTransparent: {
        value: true
    },

    isZooming: {
        value: false
    },

    mapComponent: {
        value: null
    },

    pressComposer: {
        value: null
    },

    prepareForActivationEvents: {
        value: function () {
            if (this.pressComposer === null) {
                this.pressComposer = PressComposer.create();
            }
            this.addComposerForElement(this.pressComposer, this.element);
            this.pressComposer.addEventListener("press", this, false);
        }
    },

    processing: {
        value: false
    },

    redraw: {
        value: function () {
            if (this.engine) {
                this._positionMapTipOverlay(this);
            }
        }
    },

    reset: {
        value: function () {
            delete this._feature.mapTip;
            this._feature = null;
            this._position = null;
        }
    },

    templateDidLoad: {
        value: function () {
            this._templateWasLoaded = true;
        }
    },

    type: {
        get: function () {
            return this._type;
        }
    },

    willZoom: {
        value: function () {
            this.isZooming = true;
        }
    }

});
