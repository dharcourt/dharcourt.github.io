/**
 * Based upon
 * https://github.com/mourner/simpleheat/blob/gh-pages/simpleheat.js
 * https://github.com/Leaflet/Leaflet.heat
 *  (c) 2014, Vladimir Agafonkin
 *  simpleheat, a tiny JavaScript library for drawing heatmaps with Canvas
 *  https://github.com/mourner/simpleheat
 *
 * */
/**
 * @module ui/heat-map-overlay.reel
 * @requires ui/map/overlay-component
 */
var LayerOverlayComponent = require("ui/map/layer-overlay-component").LayerOverlayComponent,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    Set = require("collections/set");;

/**
 * @class HeatMapOverlay
 * @extends LayerOverlayComponent
 */
var HeatMapOverlay = exports.HeatMapOverlay = LayerOverlayComponent.specialize(/** @lends HeatMapOverlay# */ {

    constructor: {
        value: function HeatMapOverlay() {
            //this.super();
        }
    },

    _colorize: {
        value: function (pixels, gradient) {

            for (var i = 3, len = pixels.length, j; i < len; i += 4) {
                j = pixels[i] * 4; // get gradient color from opacity value

                if (j) {
                    pixels[i - 3] = gradient[j];
                    pixels[i - 2] = gradient[j + 1];
                    pixels[i - 1] = gradient[j + 2];
                }
            }
        }
    },

    _createGradientWithColorRange: {
        value: function (colorRange) {

            var canvas = document.createElement('canvas'),
                ctx = canvas.getContext('2d'),
                gradient = ctx.createLinearGradient(0, 0, 0, 256);

            canvas.width = 1;
            canvas.height = 256;

            for (var index in colorRange) {
                gradient.addColorStop(index, colorRange[index]);
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 1, 256);

            return ctx.getImageData(0, 0, 1, 256).data;
        }
    },

    _currentBounds: {
        value: null
    },

    __data: {
        value: null
    },

    _data: {
        get: function () {
            return this.__data;
        },
        set: function (value) {
            if (value && value !== this.__data) {
                this.__data = value;
                this.needsDraw = true;
            }
        }
    },

    _gradient: {
        value: undefined
    },

    __points: {
        value: undefined
    },

    _points: {
       get: function () {
           if (this.__points === undefined) {
               this.__points = [];
           }
           return this.__points;
       }
    },

    /**
     Overloaded because the component's element
     can get added to the map's overlay and then it gets
     moved to be the child of the parent slot.  Which causes
     chaos to occur!
     */
    _register: {
        value: function () {
            this._shouldRegister = true;
            this.needsDraw = true;
        }
    },

    _shouldRegister: {
        value: false
    },

    _type: {
        value: OverlayType["Heatmap"]
    },

    blur: {
        value: 15
    },

    __circle: {
        value: undefined
    },

    _circle: {
        get: function () {
            if (this.__circle === undefined) {
                this.__circle = this._initializeCircle(HeatMapOverlay.DEFAULT_RADIUS, HeatMapOverlay.DEFAULT_BLUR);
            }
            return this.__circle;
        }
    },

    _initializeCircle: {
        value: function (radius, blur) {

            var circle = document.createElement('canvas'),
                context = circle.getContext('2d'),
                blurredRadius = this._radius = radius + blur;

            circle.width = circle.height = blurredRadius * 2;

            context.shadowOffsetX = context.shadowOffsetY = 200;
            context.shadowBlur = blur;
            context.shadowColor = 'black';

            context.beginPath();
            context.arc(blurredRadius - 200, blurredRadius - 200, radius, 0, Math.PI * 2, true);
            context.closePath();
            context.fill();

            return circle;
        }
    },

    _radius: {
        value: undefined
    },

    currentBounds: {
        get: function () {
            return this._currentBounds;
        },
        set: function (value) {
            if (value && this._currentBounds !== value) {
                this._currentBounds = value;
                if (this.layer) {
                    this.layer.bounds = this._currentBounds;
                }
            }
        }
    },

    draw: {
        value: function () {

            if (this._shouldRegister) {
                if (this.layer && this.engine) {
                    this.engine.addOverlayComponent(this);
                    this._shouldRegister = false;
                }
            }

            var context = this.element.getContext("2d"), point,
                colored, circle = this._circle,
                i, length;

            context.clearRect(0, 0, this.element.width, this.element.height);

            for (i = 0, length = this._points.length; i < length; i++) {
                point = this._points[i];
                context.globalAlpha = 0.1;
                context.drawImage(circle, point[0] - this._radius, point[1] - this._radius);
            }

            colored = context.getImageData(0, 0, this.element.width, this.element.height);
            this._colorize(colored.data, this.gradient);
            context.putImageData(colored, 0, 0);
        }
    },

    _features: {
        value: undefined
    },

    gradient: {
        get: function () {
            if (this._gradient === undefined) {
                this._gradient = this._createGradientWithColorRange(HeatMapOverlay.DEFAULT_GRADIENT);
            }
            return this._gradient;
        },
        set: function (value) {
            if (value) {
                this._gradient = this._createGradientWithColorRange(value);
            }
        }
    },

    hasTemplate: {
        value: true
    },

    layer: {
        get: function () {
            return this._layer;
        },
        set: function (value) {
            if (value && value !== this._layer) {
                this._layer = value;
                this._layer.bounds = this.currentBounds;
                //this.defineBinding("clustered", {"<-": "clustered", "source": this._layer});
                this.defineBinding("enabled", {"<-": "enabled", "source": this._layer});
                this.defineBinding("_data", {"<-": "features", "source": this._layer});
                //var data = this._data,
                //    self = this, item;
                //this._layer.features.addRangeChangeListener(function (plus, minus, index) {
                //    while (minus.length > 0) {
                //        item = minus.pop();
                //        if (data.has(item)) {
                //            data.delete(item);
                //        }
                //    }
                //    while (plus.length > 0) {
                //        item = plus.pop();
                //        if (data.has(item) === false) {
                //            data.add(item);
                //        }
                //    }
                //    self.needsDraw = true;
                //});
            }
        }
    },

    mapComponent: {
        get: function () {
            return this._mapComponent;
        },
        set: function (value) {
            if (value) {
                this._mapComponent = value;
                this.defineBinding("engine", {"<-": "mapEngine", "source": this._mapComponent});
                this.defineBinding("currentBounds", {"<-": "bounds", "source": this._mapComponent});
            }
        }
    },

    maxZoom: {
        value: 12
    },

    willDraw: {
        value: function () {
            if (this.currentBounds && this.currentBounds.west) {

                var self = this,
                    coordinatePoint,
                    originPoint = this.engine.coordinateToPoint(
                        [this.currentBounds.west, this.currentBounds.north]
                    );

                this._points.length = 0;

                this._data.forEach(function (value) {
                    coordinatePoint = self.engine.coordinateToPoint(value.geometry.coordinates);
                    coordinatePoint.x = coordinatePoint.x - originPoint.x;
                    coordinatePoint.y = coordinatePoint.y - originPoint.y;
                    self._points.push([
                        coordinatePoint.x, coordinatePoint.y, 1
                    ]);

                });
            }
        }
    }

}, {

    DEFAULT_BLUR: {
        value: 20
    },

    DEFAULT_RADIUS: {
        value: 20
    },

    DEFAULT_GRADIENT: {
        value: {
            0.4: 'blue',
            0.6: 'cyan',
            0.7: 'lime',
            0.8: 'yellow',
            1.0: 'red'
        }
    }

});
