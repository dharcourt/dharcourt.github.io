/**
 * @module ui/map/google-engine.reel
 * @requires montage/ui/component
 */
var MapEngine = require("ui/map/map-engine").MapEngine,
    Figure = require("logic/model/figure").Figure,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    Layer = require("logic/model/layer").Layer,
    MockLayer = require("logic/mock-model/layer").Layer,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    Projections = require("logic/map/projection-utilities").Projections,
    Promise = require("bluebird"),
    Protocol = require("logic/model/protocol").Protocol,
    Renderer = require("logic/map/renderer").Renderer,
    Tile = require("logic/model/tile").Tile,
    Units = require("logic/map/projection-utilities").Units;

/**
 * @class GoogleEngine
 * @extends Component
 */
exports.GoogleEngine = MapEngine.specialize(/** @lends GoogleEngine.prototype */ {

    constructor: {
        value: function () {
            var self = this;
            window.initialize = function initialize() {
                self._mapLoaded = true;
                self.needsDraw = true;
            };
        }
    },

    _bingBaseMapType: {
        value: function() {
            if (this._mapLoaded === false) {
                return false;
            }
            var self = this;
            return new google.maps.ImageMapType({
                getTileUrl: function (tile, zoom) {
                    var tileUrl;
                    if (self.baseMap.name === "Bing Imagery") {
                        tileUrl = "http://ecn.t";
                        tileUrl += self._getMVESubdomainForTile(tile);
                        tileUrl += ".tiles.virtualearth.net/tiles/a";
                        tileUrl += self._getMVEQuadTreeKey(tile.x, tile.y, zoom);
                        tileUrl += ".jpeg?g=1124&rand=";
                        tileUrl += Date.now();
                    } else if (self.baseMap.name === "Bing Hybrid") {
                        tileUrl = "http://ecn.dynamic.t";
                        tileUrl += self._getMVESubdomainForTile(tile);
                        tileUrl += ".tiles.virtualearth.net/comp/ch/";
                        tileUrl += self._getMVEQuadTreeKey(tile.x, tile.y, zoom);
                        tileUrl += "?mkt=en-en&it=A,G,L&rand=";
                        tileUrl += Date.now();
                    } else if (self.baseMap.name === "Bing Roads") {
                        tileUrl = "http://ecn.dynamic.t";
                        tileUrl += self._getMVESubdomainForTile(tile);
                        tileUrl += ".tiles.virtualearth.net/comp/CompositionHandler/";
                        tileUrl += self._getMVEQuadTreeKey(tile.x, tile.y, zoom);
                        tileUrl += "?mkt=en-en&it=G,VE,BX,L,LA&rand=";
                        tileUrl += Date.now();
                    }
                    return tileUrl;
                },
                maxZoom: 18,
                tileSize: new google.maps.Size(256, 256),
                name: "BingMap"
            });
        }
    },

    _wmsBaseMapType: {
        value: function () {

            if (this._mapLoaded === false) {
                return false;
            }

            var self = this;
            return new google.maps.ImageMapType({
                getTileUrl: function (tile, zoom) {

                    var baseMap = self.baseMap,
                        srid =  baseMap.mapServiceLayerId === "OSM-WMS" ? "3857" : "102100",
                        projection = Projections[srid],
                        extent = ProjectionUtilities.extentForTile([tile.x, tile.y, zoom]),
                        projectedExtent = ProjectionUtilities.bbox(extent, projection, Units["meters"]),
                        bbox = [projectedExtent.xmin, projectedExtent.ymin, projectedExtent.xmax, projectedExtent.ymax].join(","),
                        url;

                    url = baseMap.mapService.url;
                    url += "LAYERS=";
                    url += baseMap.mapServiceLayerId;
                    url += "&WIDTH=256";
                    url += "&HEIGHT=256";
                    url += "&format=";
                    // TODO is this configurable?
                    // url += this.imageFormat;
                    url += "image/png";
                    url += "&bboxSR=";
                    url += srid;
                    url += "&CRS=EPSG:";
                    url += srid;
                    url += "&SRS=EPSG:";
                    url += srid;
                    url += "&version=";
                    url += baseMap.mapService.protocolVersion;
                    url += "&BBOX=";
                    url += bbox;
                    url += "&service=WMS";
                    url += "&TRANSPARENT=TRUE";
                    url += "&request=GetMap";
                    url += "&STYLES=";
                    return url;
                },
                maxZoom: 18,
                tileSize: new google.maps.Size(256, 256),
                name: "WMS Map"
            });

        }
    },

    _wmtsBaseMapType: {
        value: function () {
            if (this._mapLoaded === false) {
                return false;
            }
            var self = this;
            return new google.maps.ImageMapType({
                getTileUrl : function(tile, zoom) {
                    var normalizedCoord = self._getNormalizedTile(tile, zoom);
                    if (!normalizedCoord) {
                        return null;
                    }
                    var url = self.baseMap.mapService.url;
                    url += "/WMTS";
                    url += "?service=WMTS";
                    url += "&version=1.0.0";
                    url += "&request=gettile";
                    url += "&format=image/png";
                    url += "&tileMatrix=" + zoom;
                    url += "&TileRow=" + normalizedCoord.y;
                    url += "&TileCol=" + normalizedCoord.x;
                    url += "&style=default";
                    url += "&tileMatrixSet=default028mm";
                    return url;
                },
                tileSize: new google.maps.Size(256, 256),
                name: "WMTSMap",
                maxZoom: 18
            });
        }
    },

    _disablePan: {
        value: function() {
            this.map.setOptions({
                draggable: false
            });
        }
    },

    _drawFeatureCluster: {
        value: function (cluster) {

            var coordinate = cluster.center,
                geometry = new google.maps.Data.Point(new google.maps.LatLng(
                    coordinate[1], coordinate[0]
                )),
                dataFeature = new google.maps.Data.Feature({
                    geometry: geometry
                });

            dataFeature.setProperty("cluster", true);
            dataFeature.setProperty("clusterProperties", cluster);
            this.map.data.add(dataFeature);
            return [dataFeature];
        }
    },

    _drawHazardCluster: {

        value: function (cluster) {

            var angle = 360 / cluster.size,
                radius = 22 + Math.ceil(cluster.size / 8),
                theta = 90,
                feature,
                hubCoordinate,
                coordinate,
                overlay = this.overlayRegistry[cluster.componentId],
                symbols = [],
                clusterCenter = this.overlaysContainer.getProjection().fromLatLngToDivPixel(
                    new google.maps.LatLng(cluster.center[1], cluster.center[0])
                ),
                i, length,
                x, y;

            hubCoordinate = new google.maps.LatLng(cluster.center[1], cluster.center[0]);
            var hubGeometry = new google.maps.Data.Point(hubCoordinate);

            var hub = new google.maps.Data.Feature({
                geometry: hubGeometry
            });

            hub.setProperty("properties", {
                clusterCenter: true,
                componentId: overlay.component.uuid,
                zIndex: overlay.component.layer.depth - 2
            });

            this.map.data.add(hub);
            symbols.push(hub);

            var hazardIcons = [];

            for (i = 0, length = cluster.size; i < length; i++) {

                feature = cluster.features[i];
                x = clusterCenter.x + radius * Math.cos(theta * (Math.PI / 180));
                y = clusterCenter.y - (radius * Math.sin(theta * (Math.PI / 180)));
                coordinate = this.overlaysContainer.getProjection().fromDivPixelToLatLng(new google.maps.Point(x, y));

                var spokeGeometry = new google.maps.Data.LineString([hubCoordinate, coordinate]);
                var spoke = new google.maps.Data.Feature({
                    geometry: spokeGeometry
                });
                spoke.setProperty("properties", {
                    componentId: overlay.component.uuid,
                    spoke: true,
                    zIndex: overlay.component.layer.depth - 1
                });

                this.map.data.add(spoke);
                symbols.push(spoke);

                var hazardGeometry = new google.maps.Data.Point(coordinate);
                var existingSymbol = overlay.component.symbols[this.uuid][feature.id];
                if (existingSymbol) {
                    this.removeSymbol(existingSymbol);
                }
                feature.properties.clusterCoordinate = [coordinate.lng(), coordinate.lat()];
                if (feature.mapTip) {
                    feature.mapTip.position = feature.properties.clusterCoordinate;
                }
                feature.properties.zIndex = overlay.component.layer.depth + cluster.size - i;
                hazardIcons.push({
                    geometry: hazardGeometry,
                    feature: feature,
                    overlay: overlay
                });

                theta -= angle;
            }

            for (i = hazardIcons.length - 1; i >= 0; i--) {
                var hazardIcon = hazardIcons[i];
                var icon = this._drawGeometry(hazardIcon.geometry, hazardIcon.feature);
                symbols.push(icon);
            }
            return symbols;
        }
    },

    _drawGeometry: {
        value: function (geometry, feature) {

            var dataFeature = new google.maps.Data.Feature({
                geometry: geometry
            });

            dataFeature.setProperty("feature", feature);
            this.map.data.add(dataFeature);
            return dataFeature;
        }
    },

    _drawPointFeature: {
        value: function (feature) {
            var coordinate = feature.geometry.coordinates,
                geometry = new google.maps.Data.Point(new google.maps.LatLng(
                    coordinate[1], coordinate[0]
                ));
            return this._drawGeometry(geometry, feature);
        }
    },

    _drawPointSymbol: {
        value: function (symbol) {
            var mapSymbol,
                style = symbol.properties.style;
            if (symbol.properties.radius) {
                var r = symbol.properties.radius,
                    d = r * 2,
                    path = "M -"+r+",0 a "+r+", "+r+" 0 1,0 "+d+", 0 a "+r+","+r+" 0 1,0 -"+d+" ,0",
                    icon = {
                        path: path,
                        strokeColor: style.strokeColor || "#000",
                        strokeWeight: style.strokeWeight || 1,
                        strokeOpacity: style.strokeOpacity || 1,
                        fillColor: style.fillColor || "#000",
                        fillOpacity: style.fillOpacity || 0
                    };
                mapSymbol = new google.maps.Marker({
                    position: {lat: symbol.geometry.coordinates[1],lng: symbol.geometry.coordinates[0]},
                    icon: icon,
                    map: this.map
                });

            }
            return mapSymbol;
        }
    },

    _drawMultiPointFeature: {
        value: function (feature) {
            var coordinate,
                geometry;

            // TODO add handling for drawFeature returning an array...
            for (var i = 0, length = feature.geometry.coordinates.length; i < length; i++) {
                coordinate = feature.geometry.coordinates[i];
                geometry = new google.maps.Data.Point(new google.maps.LatLng(
                    coordinate[1], coordinate[0]
                ));
                return this._drawGeometry(geometry, feature);
            }
        }
    },

    _drawMultiLineFeature: {
        value: function ( feature ) {
            var dataArray = [],
                paths = feature.geometry.coordinates,
                geometry,
                i, length, j, jLength;

            for (i = 0, length = paths.length; i < length; i++) {
                var path = paths[i];
                for (j = 0, jLength = path.length; j < jLength; j++) {
                    dataArray.push(new google.maps.LatLng(
                        path[j][1], path[j][0]
                    ));
                }
            }

            geometry = new google.maps.Data.LineString(dataArray);
            return this._drawGeometry(geometry, feature);
        }
    },

    _drawLineFeature: {
        value: function (feature) {
            var dataArray = [],
                paths = feature.geometry.coordinates,
                geometry,
                i, length;

            for (i = 0, length = paths.length; i < length; i++) {
                var path = paths[i];
                dataArray.push(new google.maps.LatLng(
                    path[1], path[0]
                ));
            }

            geometry = new google.maps.Data.LineString(dataArray);
            return this._drawGeometry(geometry, feature);
        }
    },

    _drawPolygonFeature: {
        value: function (feature) {
            var linearRings = [],
                rings = feature.geometry.coordinates,
                geometry,
                i, length,
                j, jLength;

            for (i = 0, length = rings.length; i < length; i++) {

                var ring = rings[i],
                    path = [];

                for (j = 0, jLength = ring.length; j < jLength; j++) {
                    path.push(new google.maps.LatLng(
                        ring[j][1], ring[j][0]
                    ));
                }

                linearRings.push(new google.maps.Data.LinearRing(path));
            }

            geometry = new google.maps.Data.Polygon(linearRings);
            return this._drawGeometry(geometry, feature);
        }
    },

    _drawGroundOverlayFeature: {
        value: function( feature ) {
            var coordinates = feature.geometry.coordinates;
            var properties = feature.properties;
            var sw = new google.maps.LatLng(coordinates[0][0], coordinates[0][1]);
            var ne = new google.maps.LatLng(coordinates[1][0], coordinates[1][1]);
            var bound = new google.maps.LatLngBounds(sw, ne);
            var options = {
                opacity: properties.opacity,
                map: this.map
            };

            return new google.maps.GroundOverlay(properties.url, bound, options);
        }
    },

    _enablePan: {
        value: function () {
            this.map.setOptions({
                draggable: true
            });
        }
    },

    _mveSubdomains: {
        value: ["0", "1", "2", "3"]
    },

    _getMVESubdomainForTile: {
        value: function (tile) {
            var index = Math.abs(tile.x + tile.y) % this._mveSubdomains.length;
            return this._mveSubdomains[index];
        }
    },

    _getMVEQuadTreeKey: {
        value: function (x, y, zoom) {
            var quad = "", digit, mask, i;
            for ( i = zoom; i > 0; i--) {
                digit = 0;
                mask = 1 << (i - 1);
                if ((x & mask) != 0) {
                    digit += 1;
                }

                if ((y & mask) != 0) {
                    digit += 2;
                }

                quad = quad + digit;
            }
            return quad;
        }
    },

    _getNormalizedTile: {
        value: function (tile, zoom) {
            var y = tile.y,
                x = tile.x,
                // tile range in one direction range is dependent on zoom level
                // 0 = 1 tile, 1 = 2 tiles, 2 = 4 tiles, 3 = 8 tiles, etc
                tileRange = 1 << zoom;
            // don't repeat across y-axis (vertically)
            if (y < 0 || y >= tileRange) {
                return null;
            }
            // repeat across x-axis
            if (x < 0 || x >= tileRange) {
                x = (x % tileRange + tileRange) % tileRange;
            }
            return {
                x: x,
                y: y
            };
        }
    },

    _idleAfterZoomChangedListener: {
        value: null
    },

    _initializeEventListeners: {

        value: function () {

            var self = this,
                maxZoomCountRequests = -1,
                lastSuccessfulZoomCountId = -1;

            this._mapEventListeners["idle"] = google.maps.event.addListener(this.map, 'idle', function () {
                self._setPositionAndBounds();
                //if (self.layerAnimationController.status === ["NeedsRestart"]) {
                //    self.layerAnimationController.startAnimation();
                //}
                ++maxZoomCountRequests;
                self._maxZoomService.getMaxZoomAtLatLng(new google.maps.LatLng(self.position.center[1], self.position.center[0]), function (response) {
                    var requestId = maxZoomCountRequests;
                    if (response.status === google.maps.MaxZoomStatus.OK && requestId >= lastSuccessfulZoomCountId) {
                        lastSuccessfulZoomCountId = requestId;
                        //if (response.zoom > 16) {
                            self.maxScale = response.zoom;
                        //}
                    }
                });
            });

            //this._mapEventListeners["center_changed"] = google.maps.event.addListener(this.map, 'center_changed', function () {
            //    //if (self.layerAnimationController.status === AnimationStatus["Playing"]) {
            //    //    self.layerAnimationController.stopAnimation();
            //    //    self.layerAnimationController.status = AnimationStatus["NeedsRestart"];
            //    //}
            //});

            google.maps.event.addListenerOnce(this.map, "tilesloaded", function () {
                ++maxZoomCountRequests;
                self._maxZoomService.getMaxZoomAtLatLng(new google.maps.LatLng(self.position.center[1], self.position.center[0]), function (response) {
                    var requestId = maxZoomCountRequests;
                    if (response.status === google.maps.MaxZoomStatus.OK && requestId >= lastSuccessfulZoomCountId) {
                        lastSuccessfulZoomCountId = requestId;
                        //if (response.zoom > 16) {
                            self.maxScale = response.zoom;
                        //}
                    }
                });
            });

            this._mapEventListeners["zoomChanged"] = google.maps.event.addListener(this.map, 'zoom_changed', function () {
                //self.clearTiles(true);
                self.willZoom();
                if (self._idleAfterZoomChangedListener !== null) {
                    google.maps.event.removeListener(self._idleAfterZoomChangedListener);
                }
                setTimeout(function () {
                    self._idleAfterZoomChangedListener = google.maps.event.addListenerOnce(self.map, 'idle', function () {
                        self.didZoom();
                        self._idleAfterZoomChangedListener = null;
                    });
                }, 200);
            });

            this._mapEventListeners["baseMapChanged"] = google.maps.event.addListener(this.map, 'maptypeid_changed', function () {
                var newBaseMap = self.map.mapTypes[self.map.mapTypeId];
                if (newBaseMap) {
                    self.maxScale = newBaseMap.maxZoom;
                }
                setTimeout(function () {
                    self.updateTileBounds();
                    for (var key in self.overlayRegistry) {
                        var component = self.overlayRegistry[key].component;
                        if (component.type === OverlayType["Tile"]) {
                            component._tileBounds = self.tileBounds;
                        }
                    }
                }, 0);
            });

            this._mapEventListeners["resize"] = google.maps.event.addDomListener(window, "resize", function () {
                var mapDiv = self.map.getDiv();
                self.size.width = mapDiv.offsetWidth;
                self.size.height = mapDiv.offsetHeight;
                self.map.setOptions({
                    minZoom: self._calculateMinimumZoomLevel(self.size.width, self.size.height)
                });
                self._resize();
            });
        }
    },

    _initializeFigureOverlay: {
        value: function (overlay) {
            var self = this,
                component = overlay.component;

            this.appendElementToOverlayPaneWithId(component.element, "PopUp");
            if (component.figure && component.figure.isNewObject === false) {
                component.figure.needsDraw = true;
            }
            if (component.isPersistent === false || (component.figure && component.figure.isNewObject)) {
                if (component.events.boundsChangedEvent === undefined) {
                    component.events.boundsChangedEvent = google.maps.event.addListener(this.map, 'bounds_changed',
                        self._positionFigureOverlay.bind(self, component, "bounds"));
                }
                if (component.events.windowResizeEvent === undefined) {
                    component.events.windowResizeEvent = google.maps.event.addDomListener(window, 'resize',
                        self._positionFigureOverlay.bind(self, component));
                }
            }
            this._positionFigureOverlay(component);
        }
    },

    _initializeHeatMapOverlay: {
        value: function (overlay) {
            var self = this;
            this.appendElementToOverlayPaneWithId(overlay.component.element, "OverlayLayer");
            if (overlay.component.events.boundsChangedEvent === undefined) {
                overlay.component.events.boundsChangedEvent = google.maps.event.addListener(this.map, 'bounds_changed',
                    self._positionHeatMapOverlay.bind(self, overlay.component));
            }

            if (overlay.component.events.windowResizeEvent === undefined) {
                overlay.component.events.windowResizeEvent = google.maps.event.addDomListener(window, 'resize',
                    self._positionHeatMapOverlay.bind(self, overlay.component));
            }

            this._positionHeatMapOverlay(overlay.component);
        }
    },

    _initializeMap: {

        value: function () {

            var element = this.element.querySelector(".contour-GoogleEngine-map"),
                self = this;

            this.map = new google.maps.Map(element, {
                center: {lat: this.position.center[1], lng: this.position.center[0]},
                mapTypeControl: false,
                minZoom: this._calculateMinimumZoomLevel(element.offsetWidth, element.offsetHeight),
                disableDefaultUI: true,
                //panControl: true,
                //panControlOptions: {
                //    position: google.maps.ControlPosition.RIGHT_CENTER
                //},
                //zoomControl: true,
                //zoomControlOptions: {
                //    position: google.maps.ControlPosition.RIGHT_CENTER
                //},
                //maxZoom: 18,
                zoom: this.position.zoom
            });

            //var streetView = new google.maps.StreetViewCoverageLayer();
            //streetView.setMap(this.map);
            this._updateBaseMap();
            google.maps.event.addListenerOnce(this.map, 'idle', function () {
                self.maxScale = self.map.mapTypes[self.map.mapTypeId].maxZoom;
            });

            this.map.data.setStyle(function (feature) {

                var style, featureStyle, size;

                if (feature.getProperty("cluster")) {

                    var cluster = feature.getProperty("clusterProperties");
                    featureStyle = cluster.clusterer.renderer.render(cluster);
                    style = {
                        icon: featureStyle,
                        zIndex: self.application.delegate.layers.all.length + 100
                    };

                } else {

                    var layerFeature = feature.getProperty("feature"),
                        properties = layerFeature !== undefined ? layerFeature.properties : feature.getProperty("properties"),
                        layer,
                        geometry = feature.getGeometry();

                    if (layerFeature !== undefined) {
                        layer = layerFeature.layer;
                    } else {
                        layer = self.overlayRegistry[properties.componentId].component.layer;
                    }

                    properties.layerOpacity = feature.getProperty("layerOpacity");
                    featureStyle = layer.renderer.render(properties);
                    if (geometry instanceof google.maps.Data.Point) {
                        style = {
                            icon: featureStyle,
                            zIndex: properties.zIndex || layer.depth
                        };
                        size = style.icon.scaledSize || style.icon.size;
                        if (size) {
                            properties.iconDimensions = {
                                width: size.width,
                                height: size.height
                            };
                        }
                    } else if (
                        geometry instanceof google.maps.Data.LineString ||
                        geometry instanceof google.maps.Data.Polygon) {
                        style = featureStyle;
                        style.zIndex = layer.depth;
                    }
                }
                feature.setProperty("_style", style);
                return style;
            });

            this.map.data.addListener('click', function(event) {
                var symbol = event.feature,
                    feature;

                if (self.mapComponent.hoveredMapTips.length === 0) {
                    if (symbol.getProperty("cluster")) {
                        var properties = symbol.getProperty("clusterProperties"),
                            geographicBounds = properties.geographicBounds();
                        self.map.fitBounds(new google.maps.LatLngBounds(
                            new google.maps.LatLng(geographicBounds[0][1], geographicBounds[0][0]),
                            new google.maps.LatLng(geographicBounds[1][1], geographicBounds[1][0])
                        ));
                    } else {
                        feature = symbol.getProperty("feature");
                        if (feature) {
                            if (feature.layer.protocol === MockLayer.Protocol.Camera) {
                                self.application.delegate.inspectCamera(feature);
                            } else if (feature.properties._mapTipPinned === false || feature.properties._mapTipPinned === undefined) {
                                feature.properties._mapTipPinned = true;
                                self.mapComponent.selectFeature(feature, true);
                                if (feature.geometry && (feature.geometry.type !== "Point" || feature.geometry.type !== "MultiPoint")) {
                                    feature.properties.clickPosition = [event.latLng.lng(), event.latLng.lat()];
                                }
                            } else if (feature.mapTip && feature.mapTip.isFocused === false) {
                                self.mapComponent.selectFeature(feature, true);
                            } else {
                                self.mapComponent.deselectFeature(feature);
                            }
                        }
                    }
                }
            });

            this.map.data.addListener('mouseover', function(event) {
                var symbol = event.feature,
                    feature;
                if (self.mapComponent.hoveredMapTips.length === 0) {
                    if (symbol.getGeometry() instanceof google.maps.Data.Point &&
                        symbol.getProperty("cluster") === undefined) {
                        feature = symbol.getProperty("feature");
                        if (feature &&
                            feature.properties._mapTipPinned !== true &&
                            feature.layer.protocol !== MockLayer.Protocol.Camera) {
                            feature._mapTipOpener = setTimeout(function () {
                                feature.properties._mapTipPinned = false;
                                self.mapComponent.selectFeature(feature, false);
                                self.mapComponent.setHoveredFeature(feature);
                            }, 250);
                        }
                    }
                }
            });

            this.map.data.addListener('mouseout', function(event) {
                var symbol = event.feature,
                    feature;
                if (self.mapComponent.hoveredMapTips.length === 0) {
                    if (symbol.getGeometry() instanceof google.maps.Data.Point &&
                        symbol.getProperty("cluster") === undefined) {
                        feature = symbol.getProperty("feature");
                        if (feature._mapTipOpener) {
                            clearTimeout(feature._mapTipOpener);
                        }
                        if (feature &&
                            feature.properties._mapTipPinned !== true &&
                            feature.layer.protocol !== MockLayer.Protocol.Camera) {
                            self.mapComponent.deselectFeature(feature);
                            self.mapComponent.unsetHoveredFeature(feature);
                        }
                    }
                }
            });

            // This is a bit of a wart but I do not know
            // how to require this object as an external resource
            // since it is has a dependency on Google maps.
            function OverlaysContainer(map) {
                this.setMap(map);
            }

            OverlaysContainer.prototype = new google.maps.OverlayView();
            OverlaysContainer.prototype.constructor = OverlaysContainer;
            OverlaysContainer.prototype.draw = function() {
                //self.redrawFigureOverlays();
                var key, overlay;
                for (key in self.overlayRegistry) {
                    overlay = self.overlayRegistry[key];
                    if (overlay && overlay.component) {
                        overlay.component.redraw();
                    }
                }
            };
            OverlaysContainer.prototype.onAdd = function() {
                self.isInitialized = true;
            };
            OverlaysContainer.prototype.onRemove = function() {};

            this.overlaysContainer = new OverlaysContainer(this.map);

            google.maps.event.addListenerOnce(this.map, 'bounds_changed', function() {
                self._setPositionAndBounds();
            });

            this._initializeEventListeners();

        }
    },

    _initializeMaptipOverlay: {
        value: function (overlay) {
            var component = overlay.component;
            this.appendElementToOverlayPaneWithId(component.element, "PopUp");
            component.didAdd();
        }
    },

    _initializeTileOverlay: {

        value: function (overlay) {
            // Need this check in case the overlay view that
            // holds the tile overlayRegistry has not been initialized
            if (this.overlaysContainer.getPanes()) {
                this.super(overlay);
            } else {
                var self = this;
                setTimeout(function() {
                    self._queuedOverlays.push({
                        overlay: overlay,
                        action: "add"
                    });
                    self.needsDraw = true;
                }, 0);
            }
        }
    },

    __maxZoomService: {
        value: null
    },

    _maxZoomService: {
        writeable: false,
        get: function () {
            if (this.__maxZoomService === null) {
                this.__maxZoomService = new google.maps.MaxZoomService();
            }
            return this.__maxZoomService;
        }
    },

    _origin: {
        enumerable: false,
        value: {
            point: undefined,
            maxX: 0,
            maxY: 0,
            minX: 0,
            minY: 0
        }
    },

    _positionFigureOverlay: {
        value: function (component) {

            var height = this.map.getDiv().offsetHeight,
                width = this.map.getDiv().offsetWidth,
                pixelCenter = this.overlaysContainer.getProjection().fromLatLngToDivPixel(this.map.getCenter()),
                offset = {
                    left: pixelCenter.x - width / 2,
                    top: pixelCenter.y - height / 2
                },
                element = component.element;

            element.setAttributeNS(null, "width", width);
            element.setAttributeNS(null, "height", height);
            element.style.left = offset.left + "px";
            element.style.top = offset.top + "px";
            element.style.zIndex = 10000;
            component.offset = offset;
        }
    },

    _positionHeatMapOverlay: {
        value: function (component) {

            var height = this.size.height,
                width = this.size.width,
                center = this.map.getCenter(),
                pixelCenter = this.coordinateToPoint([center.lng(), center.lat()]),
                offset = {
                    left: pixelCenter.x - width / 2,
                    top: pixelCenter.y - height / 2
                },
                element = component.element;

            element.setAttribute("width", width + "px");
            element.setAttribute("height", height + "px");
            element.style.left = offset.left + "px";
            element.style.top = offset.top + "px";
        }
    },

    _resize: {
        value: function () {
            google.maps.event.trigger(this.map, 'resize');
            this.map.setCenter(new google.maps.LatLng(this.position.center[1], this.position.center[0]));
            this._setPositionAndBounds();
        }
    },

    _setPositionAndBounds: {

        value: function () {

            if (this.map) {
                var mapBounds = this.map.getBounds(),
                    zoom = this.map.getZoom(),
                    center = this.map.getCenter();

                this.super(
                    center.lat(),
                    center.lng(),
                    zoom,
                    mapBounds.getSouthWest().lat(),
                    mapBounds.getSouthWest().lng(),
                    mapBounds.getNorthEast().lat(),
                    mapBounds.getNorthEast().lng()
                );
            }
        }
    },

    _steps: {
        value: function (x1, x2) {
            return Math.ceil((x1 - x2) / 256);
        }
    },

    _baseMapForProtocol: {
        value: function (protocol) {
            var baseMap;
            switch (protocol) {
                case Protocol.BING:
                    baseMap = this._bingBaseMapType();
                    break;
                case Protocol.WMTS:
                    baseMap = this._wmtsBaseMapType();
                    break;
                case Protocol.WMS:
                    baseMap = this._wmsBaseMapType();
                    break;
            }
            return baseMap;
        }
    },

    _updateBaseMap: {
        value: function () {
            if (this.baseMap && this.baseMap.mapService && this.map) {
                var protocol = this.baseMap.mapService.protocol;
                switch (protocol) {
                    case Protocol.BING:
                    case Protocol.WMTS:
                    case Protocol.WMS:
                        if (this.map.mapTypes.get(this.baseMap.name) === undefined) {
                            this.map.mapTypes.set(this.baseMap.name, this._baseMapForProtocol(protocol));
                        }
                        this.map.setMapTypeId(this.baseMap.name);
                        break;
                    case Protocol.GOOGLE:
                        switch (this.baseMap.name) {
                            case "Google Basemap":
                                this.map.setMapTypeId(google.maps.MapTypeId.SATELLITE);
                                break;
                            case "Google Street":
                                this.map.setMapTypeId(google.maps.MapTypeId.ROADMAP);
                                break;
                            case "Google Hybrid":
                                this.map.setMapTypeId(google.maps.MapTypeId.HYBRID);
                                break;
                            case "Google Terrain":
                                this.map.setMapTypeId(google.maps.MapTypeId.TERRAIN);
                                break;
                        }
                        break;
                }
            }
        }
    },

    clearOverlayEvents: {
        value: function (component) {
            for (var key in component.events) {
                google.maps.event.removeListener(component.events[key]);
                delete component.events[key];
            }
        }
    },

    updateTileBounds: {
        value: function () {
            var mapSize = this.size,
                center = this.getCenter(),
                zoom = this.position.zoom,
                tileRange = Math.pow(2, zoom),
                truePixelCenter = this.coordinateToPoint(center),
                horizontalRange = this._steps(truePixelCenter.x, truePixelCenter.x - mapSize.width / 2),
                verticalRange = this._steps(truePixelCenter.y, truePixelCenter.y - mapSize.height / 2),
                centerPoint = this.coordinateToMercatorPoint(center),
                centerTile = Tile.create(
                    Math.floor((centerPoint.x * tileRange) / 256),
                    Math.floor((centerPoint.y * tileRange) / 256),
                    zoom
                ),
                centerTileBounds = this.getLatLngBoundsForTile(centerTile),
                origin, minX, maxX, minY, maxY;

            origin = this.coordinateToPoint([centerTileBounds[0][0], centerTileBounds[1][1]]);
            origin.x = origin.x - horizontalRange * 256;
            minX = (centerTile.x - horizontalRange) % tileRange;

            while (minX < 0) {
                minX += tileRange;
            }

            maxX = minX + horizontalRange * 2;
            minY = centerTile.y - verticalRange;
            maxY = minY  + verticalRange * 2;
            origin.y -= verticalRange * 256;

            this.tileBounds = {
                origin: origin,
                minX: minX,
                maxX: maxX,
                minY: minY,
                maxY: maxY,
                zoom: zoom
            };
        }
    },

    coordinateToPoint: {
        value: function (coordinate) {
            if (! this.overlaysContainer || ! this.overlaysContainer.getProjection()) {
                return;
            }
            return this.overlaysContainer.getProjection().fromLatLngToDivPixel(
                new google.maps.LatLng(coordinate[1], coordinate[0]));
        }
    },

    createBounds: {
        value: function (minPoint, maxPoint) {
            return new google.maps.LatLngBounds(
                new google.maps.LatLng(minPoint[1], minPoint[0]),
                new google.maps.LatLng(maxPoint[1], maxPoint[0])
            );
        }
    },

    currentBounds: {
        value: function () {
            var mapBounds = this.map.getBounds();
            return {
                east: mapBounds.getNorthEast().lng(),
                north: mapBounds.getNorthEast().lat(),
                northEast: {
                    lat: mapBounds.getNorthEast().lat(),
                    lng: mapBounds.getNorthEast().lng()
                },
                south: mapBounds.getSouthWest().lat(),
                southWest: {
                    lat: mapBounds.getSouthWest().lat(),
                    lng: mapBounds.getSouthWest().lng()
                },
                west: mapBounds.getSouthWest().lng()
            };
        }
    },

    enterDocument: {
        value: function (firstTime) {

            if ((! firstTime) && this.map) {

                google.maps.event.trigger(this.map, "resize");
                var position = this.mapComponent.position;

                this.map.setZoom(position.zoom);
                this.map.setCenter({
                    lat: position.center[1],
                    lng: position.center[0]
                });

                this._initializeEventListeners();
                this._setPositionAndBounds();
                this.updateTileBounds();
            }
        }
    },

    exitDocument: {
        value: function () {
            this.super();
            for (var key in this._mapEventListeners) {
                google.maps.event.removeListener(this._mapEventListeners[key]);
            }
            window.removeEventListener('resize', this._resize);
        }
    },

    extendBounds: {
        value: function (bounds, pixelRadius) {

            var topRightPoint,
                bottomLeftPoint,
                extendedNorthEastCoordinate,
                extendedSouthWestCoordinate;

            // Convert the points to pixels and the extend out by the grid size.
            topRightPoint = projection.fromLatLngToDivPixel(bounds.getNorthEast());
            topRightPoint.x += pixelRadius;
            topRightPoint.y -= pixelRadius;

            bottomLeftPoint = projection.fromLatLngToDivPixel(bounds.getSouthWest());
            bottomLeftPoint.x -= pixelRadius;
            bottomLeftPoint.y += pixelRadius;

            // Convert the pixel points back to LatLng
            extendedNorthEastCoordinate = projection.fromDivPixelToLatLng(topRightPoint);
            extendedSouthWestCoordinate = projection.fromDivPixelToLatLng(bottomLeftPoint);

            // Extend the bounds to contain the new bounds.
            bounds.extend(extendedNorthEastCoordinate);
            bounds.extend(extendedSouthWestCoordinate);

            return bounds;
        }
    },

    fitToBounds: {
        value: function (bounds) {
            this.map.fitBounds(new google.maps.LatLngBounds(
                new google.maps.LatLng(bounds[0][1], bounds[0][0]),
                new google.maps.LatLng(bounds[1][1], bounds[1][0])
            ));
        }
    },

    getCenter: {
        value: function () {
            var center = this.map.getCenter();
            return [center.lng(), center.lat()];
        }
    },

    _isInitialized: {
        value: false
    },

    isInitialized: {
        get: function () {
            return this._isInitialized && this.overlaysContainer.getPanes();
        },
        set: function (value) {
            this._isInitialized = value;
        }
    },

    maxZoomLevelAtCoordinate: {
        value: function (coordinate, callback) {
            var zoom,
                self = this;
            this._maxZoomService.getMaxZoomAtLatLng(new google.maps.LatLng(coordinate[1], coordinate[0]), function (response) {
                if (response.status !== google.maps.MaxZoomStatus.OK) {
                    zoom = self.map.getZoom();
                } else {
                    zoom = response.zoom;
                }
                callback(zoom);
            });
        }
    },

    move: {
        value: function (x, y) { // , callback) {
            this.map.panBy(x, y);
            //if (callback) {
            //    setTimeout(function () {
            //        callback("CB");
            //    }, 0);
            //}
        }
    },

    overlaysContainer: {
        value: null
    },

    overlayPaneWithId: {
        value: function (paneId) {
            var pane;
            switch (paneId) {
                case "OverlayLayer":
                case "TileLayer":
                case "ImportLayer":
                    pane = this.overlaysContainer.getPanes().overlayLayer;
                    break;
                case "PopUp":
                    pane = this.overlaysContainer.getPanes().floatPane;
                    break;
            }
            return pane;
        }
    },

    pointToCoordinate: {
        value: function (point) {
            var latLng = this.overlaysContainer.getProjection().fromDivPixelToLatLng(point);
            return [latLng.lng(), latLng.lat()];
        }
    },

    pointToContainerCoordinate: {
        value: function (point) {
            var latLng = this.overlaysContainer.getProjection().fromContainerPixelToLatLng(point);
            return [latLng.lng(), latLng.lat()];
        }
    },

    pointWithinBounds: {
        value: function (point, bounds) {
            return bounds.contains(new google.maps.LatLng(point[1], point[0]));
        }
    },

    removeSymbol: {
        value: function (symbol) {
            if (symbol instanceof google.maps.Data.Feature) {
                this.map.data.remove(symbol);
            } else {
                symbol.setMap(null);
            }
        }
    },

    setCenter: {
        value: function (coordinate) {
            this.map.setCenter({lat: coordinate[1], lng: coordinate[0]});
        }
    },

    setCenterAndZoom: {
        value: function (coordinate, level) {
            if (this.map) {
                var currentCenter = this.map.getBounds().getCenter(),
                    zoom = this.map.getZoom();
                if (currentCenter.lng() !== coordinate[0] || currentCenter.lat() !== coordinate[1]) {
                    this.map.setCenter({lat: coordinate[1], lng: coordinate[0]});
                }
                if (zoom !== level) {
                    this.map.setZoom(level);
                }
            }
        }
    },

    setZoom: {
        value: function (level) {
            if (this.map) {
                this.map.setZoom(level);
            }
        }
    },

    tilePosition: {
        value: function (tile, tilePosition, origin, minX, minY) {
            return {
                left: origin.x + (256 * (tilePosition.x - minX)) + "px",
                top: origin.y + (256 * (tile.y - minY)) + "px"
            };
        }
    },

    updateSymbolLayerOpacity: {
        value: function (symbol, opacity) {
            symbol.setProperty("layerOpacity", opacity);
        }
    },

    viewPortOffset: {
        value: function () {
            if (! this.map) {
                return null;
            }
            var height = this.map.getDiv().offsetHeight,
                width = this.map.getDiv().offsetWidth,
                center = this.map.getCenter(),
                pixelCenter = this.coordinateToPoint([center.lng(), center.lat()]);
            return {
                left: pixelCenter.x - width / 2,
                top: pixelCenter.y - height / 2
            };
        }
    },

    willDraw: {
        value: function () {

            if (! this.map) {
                var element = this.element.querySelector(".contour-GoogleEngine-map");
                this.size.width = element.offsetWidth;
                this.size.height = element.offsetHeight;
            }

        }
    }

});
