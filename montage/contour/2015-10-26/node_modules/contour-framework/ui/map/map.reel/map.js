/**
 * @module ui/map/map.reel
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    AnimationStatus = require("logic/controller/animation-controller").AnimationStatus,
    Figure = require("logic/model/figure").Figure,
    FigureType = require("logic/model/figure").FigureType,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    Hazard = require("logic/mock-model/hazard").Hazard,
    Promise = require("bluebird"),
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    Projections = require("logic/map/projection-utilities").Projections,
    KeyComposer = require("montage/composer/key-composer").KeyComposer,
    Layer = require("logic/model/layer").Layer,
    MockLayer = require("logic/mock-model/layer").Layer,
    PressComposer = require("montage/composer/press-composer").PressComposer,
    Enum = require("montage/core/enum").Enum,
    Mode = exports.Mode = new Enum().initWithMembers(
        "Pan", "Zoom", "AreaBriefRectangle", "AreaBriefCircle", "Identify",
        "BufferTool", "LineTool", "PolygonTool", "FreeLineTool", "FreePolygonTool",
        "CircleAreaTool", "Rectangle", "Circle", "PolygonAreaTool", "DistanceTool",
        "AnnotationTool", "PlacemarkTool", "ImageTool", "Point"
    );

/**
 * @class Map
 * @extends Component
 */
var Map = exports.Map = Component.specialize(/** @lends Map# */ {
    constructor: {
        value: function Map() {
            //this.super();
            this.application.map = this;
        }
    },

    _areaSelectionFigure: {
        value: null
    },

    _bounds: {
        value: null
    },

    _currentMode: {
        value: null
    },

    _enabledOverlays: {
        value: null
    },

    _eventProperties: {
        value: function (event) {
            var eventProperties = {},
                boundingRectangle = this.element.getBoundingClientRect(),
                offset = this.mapEngine.viewPortOffset(),
                point = {
                    x: offset.left + event.pageX - boundingRectangle.left,
                    y: offset.top + event.pageY - boundingRectangle.top
                };
            eventProperties.coordinate = this.mapEngine.pointToCoordinate(point);
            switch (event.which) {
                case 1:
                    eventProperties.button = "left";
                    break;
                case 2:
                    eventProperties.button = "middle";
                    break;
                case 3:
                    eventProperties.button = "right";
                    break;
            }
            eventProperties.keys = [];
            if (event.shiftKey) {
                eventProperties.keys.push("shift");
            }
            if (event.altKey) {
                eventProperties.keys.push("alt");
            }
            if (event.ctrlKey) {
                eventProperties.keys.push("ctrl");
            }
            return eventProperties;
        }
    },

    _figures: {
        value: []
    },

    _figureOverlayRegistry: {
        value: {}
    },

    _keyComposer: {
        value: null
    },

    _keyComposerKeyPressListenerRemoved: {
        value: false
    },

    _overlayComponentRegistry: {
        value: {}
    },

    _mapEngine: {
        value: null
    },

    _maxScale: {
        value: 16
    },

    _minScale: {
        value: 4
    },

    _mgrsCoordinate: {
        value: null
    },

    _oldMode: {
        value: Mode["Pan"]
    },

    _pixelBoundsToCoordinateBounds: {
        value: function (minPoint, maxPoint) {
            return [
                this.mapEngine.pointToCoordinate({x: minPoint[0], y: maxPoint[1]}),
                this.mapEngine.pointToCoordinate({x: maxPoint[0], y: minPoint[1]})
            ];
        }
    },

    _position: {
        value: {
            center: [0, 0],
            zoom: 5
        }
    },

    _pressComposer: {
        value: null
    },

    _purgeIncompleteFigures: {
        value: function () {
            var figures = this._figures,
                figure,
                i = 0,
                length = figures.length;

            while (i < length) {
                figure = figures[i];
                if (figure.isNewObject) {
                    figures.splice(i, 1);
                    length = figures.length;
                } else {
                    i++;
                }
            }
        }
    },

    _selectedEngineKey: {
        enumerable: false,
        value: null
    },

    _selectedFigureOverlay: {
        value: null
    },

    _watermark: {
        value: null
    },

    _watermarkUrl: {
        value: null
    },

    _zoom: {
        value: null
    },

    _needsInsetUpdate: {
        value: false
    },

    insets: {
        get: function () {
            return this._insets || {top: 0, left: 0, right: 0, bottom: 0};
        },
        set: function (insets) {
            if (this._insets) {
                this._shouldAnimateInset =  this._insets.left === 0 && insets.left > 0 ? true : // opening left panel in landscape
                                            this._insets.left > 0 && insets.left === 0 ? true : // closing left panel in landscape
                                            this._insets.right === 0 && insets.right > 0 ? true : // opening right panel in landscape
                                            this._insets.right > 0 && insets.right === 0 ? true : // closing right panel in landscape
                                            this._insets.top === 0 && insets.top > 0 ? true : // opening portrait mode
                                            this._insets.top > 0 && insets.top === 0  ? true : // closing portrait mode
                                            false;
            }
            this._insets = insets;
            this._needsInsetUpdate = true;
            this.needsDraw = true;
        }
    },

    undo: {
        value: []
    },

    /**
     * Import data to map
     * @param {*} data imported data
     * @param {string} type imported data type
     * @param {boolean} show specifies that imported layer must be shown immediately
     * @returns {Object}
     */
    importData: {
        value: function importData(name, data, type) {
            var layer = MockLayer.initializeImportLayer(name, data, type);

            this.addOverlay(layer);

            return layer;
        }
    },

    /**
     * Add overlay to map
     * @param {Object} overlay
     */
    addOverlay: {
        value: function addOverlay(overlay) {
            var overlaysRangeController = this.overlaysRangeController;
            if (!overlaysRangeController.has(overlay)) {
                overlaysRangeController.add(overlay);
            } else {
                console.warn("Overlay already added");
            }
        }
    },

    baseMap: {
        value: undefined
    },

    /**
     * Remove overlay from map
     * @param {Object} overlay
     */
    removeOverlay: {
        value: function removeOverlay(overlay) {
            this.overlaysRangeController.delete(overlay);
        }
    },

    areaBriefBoundsColor: {
        value: function (figure) {
            var boundsColor = "#FFFFFF";
            if (figure && figure.bbox) {
                boundsColor = this.isValidAreaBriefBounds(
                    [figure.bbox[0], figure.bbox[1]],
                    [figure.bbox[2], figure.bbox[3]]) ? "#00FF00" : "#FF0000";
            }
            return boundsColor;
        }
    },

    areaSelectionOverlay: {
        value: null
    },

    bounds: {
        get: function () {
            return this._bounds;
        },
        set: function (value) {
            this._bounds = value;
        }
    },

    /**
     * Instruct the map to center on the provided feature
     * @param {Feature} the feature to center the map on.
     */
    centerOnFeature: {
        value: function (feature) {
            if (feature.layer.clustered && feature.properties.clusterCoordinate) {
                this.setCenter(feature.properties.clusterCoordinate);
            } else {
                this.setCenter(feature.getCenter());
            }
        }
    },

    /**
     * Instruct the map to center and zoom on the provided feature
     * @param {Feature} the feature to center and zoom the map on.
     */
    centerOnAndZoomToFeature: {
        value: function (feature) {
            var center = feature.getCenter();

            switch (feature.geometry.type) {
                case "Point":
                    this.setCenterAndZoom(center, this.defaultZoomLevel);
                    break;
                case "MultiPoint":
                    if (feature.geometry.coordinates.length === 1) {
                        this.setCenterAndZoom(center, this.defaultZoomLevel);
                    } else {
                        this.setCenter(center);
                    }
                    break;
                case "MultiLineString":
                case "MultiPolygon":
                    this.setCenter(center);
                    break;
            }
        }
    },

    currentCenter: {
        get: function () {
            if (this._currentCenter === null) {
                this._currentCenter = this.position.center;
            }
            return this._currentCenter;
        },
        set: function (value) {
            if (value && this._currentCenter !== value) {
                while (value[0] > 180) {
                    value[0] -= 360;
                }
                while (value[0] < -180) {
                    value[0] += 360;
                }
                this._currentCenter = value;
                this._mgrsCoordinate = ProjectionUtilities.project(Projections["MGRS"], value);
                this.dispatchOwnPropertyChange("mgrsCoordinate", this._mgrsCoordinate);
            }
        }
    },

    currentHazard: {
        get: function () {
            return this.application.delegate.currentHazard;
        },
        set: function (value) {
            if (value === undefined && this.selectedFeaturesRangeController &&
                this.selectedFeaturesRangeController.selection.length > 0) {
                if (this.selectedFeaturesRangeController.selection[0] instanceof Hazard) {
                    this.application.delegate.currentHazard = this.selectedFeaturesRangeController.selection[0];
                }
            }
        }
    },

    currentMode: {
        get: function () {
            if (this._currentMode === null) {
                this._currentMode = Mode["Pan"];
            }
            return this._currentMode;
        },
        set: function (value) {
            if (value !== undefined && value !== this._currentMode) {
                this._currentMode = value;
                this.needsDraw = true;
            }
        }
    },

    currentZoom: {
        get: function () {
            if (this._zoom === null) {
                this._zoom = this.position.zoom;
            }
            return this._zoom;
        },
        set: function (value) {
            if (value && this._zoom !== value) {
                this._zoom = value;
            }
        }
    },

    defaultZoomLevel: {
        value: 10
    },

    draw: {
        value: function () {

            if (this._needsInsetUpdate) {

                var x = Math.round((this.insets.left - this.insets.right) / 2),
                    y = Math.round((this.insets.top - this.insets.bottom) / 2),
                    watermarkLeft = x + this.insets.right,
                    watermarkLeftMaxRight = (this.size.width - this._scaleOverlayWidth) / 2 - this.watermarkWidth - 20;
                    offsetBottom = 20 + y + this.insets.bottom,
                    availableHeight = this.size.height - this.insets.top - this.insets.bottom - this._navigatorHeight - 130 -20,
                    overviewMapRight = 12 + x + this.insets.right,
                    overviewMapMaxRight = (this.size.width - this._scaleOverlayWidth) / 2 - 130 - 20,
                    navigatorTop = 120 - y + this.insets.top,
                    viewableHeight = this.size.height - (this.insets.top + this.insets.bottom);

                this.element.style.transition = this._shouldAnimateInset === true ? "-webkit-transform 500ms" : "none";
                this.navigator.element.style.transition = this._shouldAnimateInset ? "right 500ms, top 500ms" : "none";
                this.overviewMap.element.style.transition = this._shouldAnimateInset ? "bottom 500ms, right 500ms" : "none";
                this.scaleOverlay.element.style.transition = this._shouldAnimateInset ? "bottom 500ms" : "none";
                this.watermark.style.transition = this._shouldAnimateInset ? "bottom 500ms, left 500ms" : "none";

                if (availableHeight < 0) {
                    offsetBottom += availableHeight;
                }

                if (120 + this._navigatorHeight / 2 > viewableHeight) {
                    navigatorTop -= 120 + this._navigatorHeight / 2 - viewableHeight;
                }

                this.overviewMap.element.style.bottom = offsetBottom + "px";
                this.scaleOverlay.element.style.bottom = offsetBottom + "px";
                this.watermark.style.bottom = offsetBottom + "px";

                this.overviewMap.element.style.right = (overviewMapRight > overviewMapMaxRight ? overviewMapMaxRight : overviewMapRight) + "px";
                this.watermark.style.left = (watermarkLeft > watermarkLeftMaxRight ? watermarkLeftMaxRight : watermarkLeft) + "px";
                this.navigator.element.style.right = (12 + x + this.insets.right) + "px";
                this.navigator.element.style.top = navigatorTop + "px";
                x += x > 0 || x < 0 ? "px" : "";
                y += y > 0 || y < 0 ? "px" : "";
                this.element.style.transform = "translate3d(" + x + ", " + y + ", 0)";
            }

            if (this._oldMode !== this.currentMode) {
                this._purgeIncompleteFigures();
                switch (this._oldMode) {
                    case Mode["Zoom"]:
                    case Mode["AreaBriefRectangle"]:
                    case Mode["AreaBriefCircle"]:
                    case Mode["Identify"]:
                        this.areaSelectionOverlay.disableAreaSelection(this.mapEngine);
                        break;
                    case Mode["Point"]:
                        this.exitPointSelectionMode();
                        break;
                }

                var figure;

                switch (this.currentMode) {
                    case Mode["AnnotationTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Annotation"], [0, 0], {});
                        break;
                    case Mode["AreaBriefRectangle"]:
                        this._areaSelectionFigure = Figure.initializeFigureWithType(FigureType["Rectangle"], [0,
                            0], {
                            fillColor: "#FFFFFF"
                        });
                        this.enterAreaSelectionMode({
                            callback: this.handleAreaBriefSelection.bind(this),
                            style: {
                                fillColor: "#FFFFFF",
                                fillOpacity: 0.2,
                                strokeColor: "#FFFFFF",
                                strokeOpacity: 1.0
                            }
                        });

                        break;
                    case Mode["AreaBriefCircle"]:
                        this._areaSelectionFigure = Figure.initializeFigureWithType(FigureType["Circle"], [0,
                            0], {
                            fillColor: "#FFFFFF"
                        });
                        this.enterAreaSelectionMode({
                            callback: this.handleAreaBriefSelection.bind(this),
                            style: {
                                fillColor: "#FFFFFF",
                                fillOpacity: 0.2,
                                strokeColor: "#FFFFFF",
                                strokeOpacity: 1.0
                            }
                        });
                        break;
                    case Mode["BufferTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Circle"], [0, 0], {
                            hasLabel: true,
                            labelType: "buffer"
                        });
                        break;
                    case Mode["Circle"]:
                        figure = Figure.initializeFigureWithType(FigureType["Circle"], [0, 0], {});
                        break;
                    case Mode["CircleAreaTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Circle"], [0, 0], {
                            hasLabel: true,
                            labelType: "area"
                        });
                        break;
                    case Mode["DistanceTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Polyline"], [], {
                            hasLabel: true,
                            displayDistanceTotal: true
                        });
                        figure.name = "Distance Tool";
                        figure.mapTip = "Distace Tool Line Figure";
                        break;
                    case Mode["FreeLineTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Polyline"], [], {
                            isFreeHand: true
                        });
                        break;
                    case Mode["FreePolygonTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Polygon"], [], {
                            isFreeHand: true
                        });
                        break;
                    case Mode["Identify"]:
                        this._areaSelectionFigure = Figure.initializeFigureWithType(FigureType["Rectangle"], [0,
                            0], {
                            fillColor: "#FFFFFF",
                            strokeColor: "#00FF00"
                        });
                        this.enterAreaSelectionMode({
                            callback: this.handleIdentify.bind(this),
                            style: {
                                fillColor: "#FFFFFF",
                                fillOpacity: 0.2,
                                strokeColor: "#00FF00",
                                strokeOpacity: 1.0
                            }
                        });
                        break;
                    case Mode["LineTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Polyline"], [], {
                            isFreeHand: false
                        });
                        break;
                    case Mode["Pan"]:
                        this.enterPanMode();
                        break;
                    case Mode["PlacemarkTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Placemark"], [0, 0], {});
                        break;
                    case Mode["Point"]:
                        this.enterPointSelectionMode();
                        break;
                    case Mode["PolygonAreaTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Placemark"], [], {
                            hasLabel: true,
                            isFreeHand: false
                        });
                        break;
                    case Mode["PolygonTool"]:
                        figure = Figure.initializeFigureWithType(FigureType["Polygon"], [], {
                            isFreeHand: false
                        });
                        break;
                    case Mode["Rectangle"]:
                        figure = Figure.initializeFigureWithType(FigureType["Rectangle"], [0, 0], {});
                        break;
                    case Mode["Zoom"]:
                        this.enterZoomMode();
                        break;

                }
                if (figure) {
                    this.figures.add(figure);
                    this.mapEngine.draggable = false;
                }

                this._oldMode = this.currentMode;
            }
        }
    },

    figures: {
        get: function () {
            return this._figures;
        },
        set: function (value) {
            if (value !== this._figures) {
                this._figures = value;
            }
        }
    },

    /**
     * Instructs the map to set the viewport to contain the provided bounds
     * @param {Bounds} an array of two coordinates  A coordinate is defined as an array
     * of two numbers [longitude, latitude] where each number is specified in degrees.
     */
    fitToBounds: {
        value: function (bounds) {
            this.mapEngine.fitToBounds(bounds);
        }
    },

    goHome: {
        value: function () {
            this.undo = [];
            this.redo = [];
            this._position = this._homePosition;
            this.currentCenter = this._homePosition.center;
            this.currentZoom = this._homePosition.zoom;
            this.setCenterAndZoom(this._homePosition.center, this._homePosition.zoom);
        }
    },

    _homePosition: {
        value: {
            center: [0, 0],
            zoom: 7
        }
    },

    hoveredMapTips: {
        value: []
    },

    googleEngine: {
        value: null
    },

    handleAreaBriefSelection: {
        value: function (figure) {
            var selectionType = figure.type === FigureType["Circle"] ? "areaBriefCircle" : "areaBriefRectangle";
            this.dispatchEventNamed("selectionAction", true, true, {
                bbox: figure.bbox,
                selectionType: selectionType
            });
        }
    },

    _pointSelectionCallback: {
        value: null
    },

    handlePointSelection: {
        value: function (coordinate) {
            if (this._pointSelectionCallback && typeof this._pointSelectionCallback === "function") {
                this._pointSelectionCallback(coordinate);
            } else {
                this.dispatchEventNamed("selectionAction", true, true, {
                    point: coordinate,
                    selectionType: "point"
                });
            }
        }
    },

    handleIdentify: {
        value: function (figure) {
            this.dispatchEventNamed("selectionAction", true, true, {
                bbox: figure.bbox,
                selectionType: "identify"
            });
        }
    },

    handleEnableMgrsButtonAction: {
        value: function () {
            this.mgrsEnabled = !this.mgrsEnabled;
        }
    },

    handleShiftKeyPress: {
        value: function () {
            if (this.currentMode !== Mode["Zoom"]) {
                this._keyComposer.removeEventListener("keyPress", this);
                this._keyComposerKeyPressListenerRemoved = true;
                this.enterZoomMode();
            }
        }
    },

    handleShiftKeyRelease: {
        value: function () {
            if (this.currentMode === Mode["Zoom"]) {
                this.enterPanMode();
            }
        }
    },

    handleToggleAnimationLayersButtonAction: {
        value: function (e) {
            console.log("Toggle Layesr!");
            e.stopPropagation();
            globalClouds.enabled = !globalClouds.enabled;
            rainfallAccumulations.enabled = !rainfallAccumulations.enabled;
        }
    },

    handleToggleEngineButtonAction: {
        value: function () {
            this.selectedEngineKey = (this.selectedEngineKey === Map.EngineKeys.LeafletEngine) ?
                Map.EngineKeys.GoogleEngine :
                Map.EngineKeys.LeafletEngine;
            this.needsDraw = true;
        }
    },

    handleToggleOpenStreetMapsOverlayButtonAction: {
        value: function () {
            if (this.animationController.status === AnimationStatus["Stopped"]) {
                this.animationController.startAnimation();
            } else {
                this.animationController.stopAnimation();
            }
        }
    },

    handleToggleEarthquakesClusterButtonAction: {
        value: function () {
            historicalEarthQuakesLayer.clustered = !historicalEarthQuakesLayer.clustered;
        }
    },

    handleToggleZoomModeButtonAction: {
        value: function () {
            this.currentMode = this.currentMode === Mode["Pan"] ?
                Mode["Zoom"] : Mode["Pan"];
            this.needsDraw = true;
        }
    },

    isValidAreaBriefBounds: {
        value: function (minPoint, maxPoint) {
            var west = minPoint[0],
                south = minPoint[1],
                east = maxPoint[0],
                north = maxPoint[1],
                width,
                height;

            switch (this._areaSelectionFigure.type) {
                case FigureType["Rectangle"]:
                    if (west > east) {
                        var leftSide = 180 - Math.abs(west),
                            rightSide = 180 - Math.abs(east);
                        width = leftSide + rightSide;
                    } else {
                        width = Math.abs(east - west);
                    }
                    height = Math.abs(north - south).toFixed(4);
                    break;
                case FigureType["Circle"]:
                    width = height = north - south;
                    break;
            }

            return Math.max(width, height) <= 3;
        }
    },

    leafletEngine: {
        value: null
    },

    mapEngine: {
        get: function () {
            if (this._mapEngine === null) {
                this._mapEngine = this.selectedEngineKey === Map.EngineKeys.GoogleEngine ?
                    this.googleEngine : this.leafletEngine;
            }
            return this._mapEngine;
        },
        set: function (value) {
            if (value && value !== this._mapEngine) {
                this._mapEngine = value;
                this._oldMode = -1;
                this.currentMode = Mode["Pan"];
            }
        }
    },

    maxScale: {
        get: function () {
            return this._maxScale;
        },
        set: function (value) {
            if (value && value !== this._maxScale) {
                this._maxScale = value;
                if (this._maxScale < this.position.zoom) {
                    this.setZoom(this._maxScale);
                }
            }
        }
    },

    /**
     Returns the maximum zoom level the map may view at a given coordinate.
     @param {array} the coordinate.
     @return {number} the maximum zoom level
     **/
    maxZoomLevelAtCoordinate: {
        value: function (coordinate, callback) {
            return this.mapEngine.maxZoomLevelAtCoordinate(coordinate, callback);
        }
    },

    mgrsCoordinate: {
        get: function () {
            if (this._mgrsCoordinate === null && this.currentCenter) {
                this._mgrsCoordinate = ProjectionUtilities.project(Projections["MGRS"], this.currentCenter);
            }
            return this._mgrsCoordinate;
        },
        set: function (value) {
            if (value && value !== this._mgrsCoordinate) {
                var point = ProjectionUtilities.inverse(Projections["MGRS"], value);
                this._mgrsCoordinate = value;
                this.setCenter(point);
            }
        }
    },

    mgrsEnabled: {
        value: false
    },

    mode: {
        value: function (type) {
            return Mode[type];
        }
    },

    minScale: {
        get: function () {
            return this._minScale;
        },
        set: function (value) {
            if (value && value !== this._minScale) {
                this._minScale = value;
                if (this._minScale > this.position.zoom) {
                    this.setZoom(this._minScale);
                }
            }
        }
    },

    /**
     Use this function to close a map tip for the provided feature.  If a map tip is not open
     the method will do nothing.
     @param {Object} a feature.
     */
    deselectFeature: {
        value: function (feature) {
            if (feature && this.selectedFeaturesRangeController) {
                if (this.selectedFeaturesRangeController.has(feature) === true) {
                    this.selectedFeaturesRangeController.delete(feature);
                }
            }
        }
    },

    enterAreaSelectionMode: {
        value: function (options) {
            this.areaSelectionOverlay.prepareForAreaSelection(this.mapEngine, this._areaSelectionFigure, options);
            this.mapEngine.draggable = false;
        }
    },

    enterDocument: {
        value: function (firstTime) {
            var desktopMediaQuery;
            if (firstTime) {
                desktopMediaQuery = window.matchMedia("(min-height: 700px) and (min-width: 700px)");
                desktopMediaQuery.addListener(this.displayWatermark.bind(this));
                this.displayWatermark(desktopMediaQuery);
            }
        }
    },

    _displayWatermark: {
        value: false
    },

    displayWatermark: {
        value: function (desktopMediaQuery) {
            this._displayWatermark = desktopMediaQuery.matches;
            if (this._displayWatermark && this.watermark) {
                this.watermark.style.display = "block";
            } else {
                this.watermark.style.display = "none";
            }
        }
    },

    enterPanMode: {
        value: function () {
            this.mapEngine.draggable = true;
            if (this._keyComposerKeyPressListenerRemoved === true) {
                this._keyComposer.addEventListener("keyPress", this);
            }
            this.currentMode = Mode["Pan"];
        }
    },

    enterPointSelectionMode: {
        value: function (options) {
            this.currentMode = Mode["Point"];
            this.mapEngine.draggable = false;
            if (!this._pressComposer) {
                this._pressComposer = new PressComposer();
                this.addComposer(this._pressComposer);
                this._pressComposer.addEventListener("press", this, false);
                if (options && options.callback) {
                    this._pointSelectionCallback = options.callback;
                }
            }
        }
    },

    enterZoomMode: {
        value: function () {
            this._areaSelectionFigure = Figure.initializeFigureWithType(FigureType["Rectangle"], [0, 0], {
                fillColor: "#FFFFFF",
                strokeColor: "#FFFFFF"
            });
            this.enterAreaSelectionMode({
                callback: function (figure) {
                    this.fitToBounds([figure.coordinates[0], figure.coordinates[2]]);
                }.bind(this),
                style: {
                    fillColor: "#FFFFFF",
                    fillOpacity: 0.2,
                    strokeColor: "#FFFFFF",
                    strokeOpacity: 1.0
                }
            });
            this.currentMode = Mode["Zoom"];
        }
    },

    exitPointSelectionMode: {
        value: function () {
            if (this._pressComposer) {
                this._pressComposer.removeEventListener("press", this);
                this.removeComposer(this._pressComposer);
                this._pressComposer = null;
            }
        }
    },

    exportMapToJpeg: {
        value: function (context, exceptions) {
            var self = this;
            return this.mapEngine.exportBaseMapToJpeg(context, exceptions).then(function () {
                var layers = self.application.delegate.layers.enabled.filter(function (layer) {
                    return layer.isClustering === false && layer !== self.application.delegate.baseMap;
                }), promises = [];
                layers.sort(function (a, b) {
                    return  a.type === Layer.Type.RASTER && b.type === Layer.Type.RASTER ||
                            a.type !== Layer.Type.RASTER && b.type !== Layer.Type.RASTER        ? a.depth - b.depth :
                            a.type === Layer.Type.RASTER && b.type !== Layer.Type.RASTER        ? -1 : 1;
                });
                layers.forEach(function (layer) {
                    promises.push(self.mapEngine.exportLayerToJpeg(layer, context, exceptions));
                });
                return Promise.all(promises);
            }).then(function () {
                var layers = self.application.delegate.layers.enabled.filter(function (layer) {
                    return layer.isClustering === true;
                }), promises = [];
                layers.sort(function (a, b) {
                    return  a === self.application.delegate.layers.hazard ? 1   :
                            b === self.application.delegate.layers.hazard ? -1  : 0

                });
                layers.forEach(function (layer) {
                    if (layer === self.application.delegate.layers.hazard) {
                        promises.push(self.mapEngine.exportLayerToJpeg(layer, context, exceptions));
                    }
                });
                return Promise.all(promises);
            }).then(function () {
                if (self.mgrsEnabled) {
                    context.drawImage(self.mgrsOverlay.element, 0, 0);
                }
                return null;
            }).then(function () {
                return self.mapEngine.exportFiguresToJpeg(context, exceptions);
            }).then(function () {
                return self.scaleOverlay.exportToJpeg(context, exceptions);
            }).then(function () {
                return self.overviewMap.exportToJpeg(context, exceptions);
            }).then(function () {
                if (self._displayWatermark && self.watermarkUrl && self.watermarkHeight && self.watermarkWidth) {
                    return new Promise(function (resolve, reject) {
                        var image = new Image();
                        image.onload = function () {
                            context.drawImage(
                                image,
                                0,
                                self.size.height - 20 - self.watermarkHeight,
                                self.watermarkWidth,
                                self.watermarkHeight
                            );
                            resolve(exceptions);
                        };
                        image.setAttribute('crossOrigin', 'anonymous');
                        image.src = self.watermarkUrl
                    });
                } else {
                    return exceptions;
                }
            }).catch(function (reason) {
                return [reason];
            });
        }
    },

    handlePress: {
        value: function (e) {
            e.stopPropagation();
            var boundingRectangle = this.element.getBoundingClientRect(),
                offset = this.mapEngine.viewPortOffset(),
                point = {
                    x: offset.left + event.pageX - boundingRectangle.left,
                    y: offset.top + event.pageY - boundingRectangle.top
                },
                coordinate = this.mapEngine.pointToCoordinate(point);
            this.handlePointSelection(coordinate);
        }
    },

    hoveredFeature: {
        value: null
    },

    _overlaysRangeController: {
        value: null
    },

    overlaysRangeController: {
        get: function () {
            return this._overlaysRangeController;
        },
        set: function (value) {
            if (value && value !== this._overlaysRangeController) {
                this._overlaysRangeController = value;
                this._overlaysRangeController.content = this.application.delegate.enabledLayers;
            }
        }
    },

    position: {
        get: function () {
            return this._position;
        },
        set: function (value) {
            if (this.mapEngine.isInitialized && value !== undefined) {
                var currentPixelLocation = this.mapEngine.coordinateToPoint(this._position.center),
                    newPixelLocation = this.mapEngine.coordinateToPoint(value.center);
                if (currentPixelLocation && newPixelLocation) {
                    if (
                        !this._position ||
                        Math.abs(currentPixelLocation.x - newPixelLocation.x) > 20 ||
                        Math.abs(currentPixelLocation.y - newPixelLocation.y) > 20 ||
                        this._position.zoom !== value.zoom
                    ) {
                        // TODO add logic for handling situation when you go home...
                        this.undo.push(this._position);
                        this._position = value;
                        this.currentZoom = value.zoom;
                        this.currentCenter = value.center;
                        this.redo = [];
                    }
                    if (this.currentZoom !== value.zoom) {
                        this.currentZoom = value.zoom;
                    }
                    if (!this.currentCenter || this.currentCenter[0] !== value.center[0] || this.currentCenter[1] !== value.center[1]) {
                        this.currentCenter = value.center;
                    }
                }
            }
        }
    },

    prepareForActivationEvents: {
        value: function () {
            var self = this;

            this.element.addEventListener("mousedown", function (event) {
                var eventProperties = self._eventProperties(event);
                eventProperties.type = "single";
                self.dispatchEventNamed("mapClickAction", true, false, eventProperties);
            }, false);

            this.element.addEventListener("dblclick", function (event) {
                var eventProperties = self._eventProperties(event);
                eventProperties.type = "double";
                self.dispatchEventNamed("mapClickAction", true, false, eventProperties);
            }, false);

            this._keyComposer = KeyComposer.createGlobalKey(this, "shift+z", "shift");
            this._keyComposer.addEventListener("keyPress", this);
            this._keyComposer.addEventListener("keyRelease", this);
        }
    },

    redoPositionChange: {
        value: function () {
            if (this.redo.length > 0) {
                this.undo.push(this._position);
                this._position = this.redo.pop();
                this.mapEngine.setCenterAndZoom(this._position.center, this._position.zoom);
            }
        }
    },

    redo: {
        value: []
    },

    redrawFeature: {
        value: function (feature) {
            this.mapEngine.redrawFeature(feature);
        }
    },

    selectedEngineKey: {
        get: function () {
            if (this._selectedEngineKey === null) {
                this._selectedEngineKey = Map.EngineKeys.GoogleEngine;
            }
            return this._selectedEngineKey;
        },
        set: function (value) {
            if (value !== this._selectedEngineKey) {
                this._selectedEngineKey = value;
                if (value === Map.EngineKeys.LeafletEngine) {
                    this.mapEngine = this.leafletEngine;
                } else if (value === Map.EngineKeys.GoogleEngine) {
                    this.mapEngine = this.googleEngine;
                }
            }
        }
    },

    /**
     Use this function to open a map tip for the provided feature.  If a map tip is already open
     it will not open a second one.
     @param {Object} a feature.
     */
    selectFeature: {
        value: function (feature, makeFocused) {
            if (feature && this.selectedFeaturesRangeController) {
                if (this.selectedFeaturesRangeController.has(feature) === false) {
                    this.selectedFeaturesRangeController.add(feature);
                }

                if (this.selectedFeaturesRangeController.selection.has(feature) === false && makeFocused) {
                    this.selectedFeaturesRangeController.select(feature);
                    if (feature instanceof Hazard) {
                        this.application.delegate.currentHazard = feature;
                    }
                }
            }
        }
    },

    selectedFeaturesRangeController: {
        value: null
    },

    /**
     Set the map to a specified mgrs coordinate.
     @param {mgrs} the coordinate to center the map on.
     **/
    setCenterWithMgrsCoordinates: {
        value: function (mgrs) {
            if (this.mapEngine) {
                this.mgrsCoordinate = mgrs;
            }
        }
    },

    /**
     Set the map to a specified coordinate.
     @param {array[lng, lat]} the coordinate to center the map on.
     **/
    setCenter: {
        value: function (coordinate) {
            if (this.mapEngine) {
                this.mapEngine.setCenter(coordinate);
            }
        }
    },

    /**
     Set the map to a specified coordinate and zoom level.
     @param {array[lng, lat]} the coordinate to center the map on.
     @param {number} the zoom level
     **/
    setCenterAndZoom: {
        value: function (coordinate, level) {
            if (this.mapEngine) {
                this.mapEngine.setCenterAndZoom(coordinate, level);
            }
        }
    },

    setHoveredFeature: {
        value: function (value) {
            if (value) {
                this.hoveredFeature = value;
            }
        }
    },

    setSelectedFigureOverlay: {
        value: function (component) {
            if (this._selectedFigureOverlay !== component) {
                if (this._selectedFigureOverlay) {
                    this._selectedFigureOverlay.selected = false;
                }
                this._selectedFigureOverlay = component;
                if (this._selectedFigureOverlay) {
                    this._selectedFigureOverlay.selected = true;
                }
            }
        }
    },

    /**
     Set the map to a specified zoom level.
     @param {number} the zoom level
     **/
    setZoom: {
        value: function (level) {
            if (this.mapEngine) {
                this.mapEngine.setZoom(level);
            }
        }
    },

    /**
     Set the map to nearest supported zoom level.
     @param {number} the zoom level
     **/
    setZoomWithRange: {
        value: function (range) {
            this.setZoom(GeometryUtilities.zoomLevelForRange(range));
        }
    },

    size: {
        get: function () {
            return this.mapEngine.size;
        }
    },

    watermark: {
        get: function () {
            return this._watermark;
        },
        set: function (value) {
            if (value && value !== this._watermark) {
                this._watermark = value;
                if (this.watermarkUrl && this.watermarkHeight && this.watermarkWidth) {
                    this.watermark.style.background = "url(" + this._watermarkUrl + ")";
                    this.watermark.style.height = this.watermarkHeight + "px";
                    this.watermark.style.width = this.watermarkWidth + "px";
                }
            }
        }
    },

    watermarkHeight: {
        get: function () {
            return this._watermarkHeight;
        },
        set: function (value) {
            if (value && value !== this._watermarkHeight) {
                this._watermarkHeight = value;
                if (this.watermark) {
                    this.watermark.style.height = this.watermarkHeight + "px";
                }
            }
        }
    },

    watermarkWidth: {
        get: function () {
            return this._watermarkWidth;
        },
        set: function (value) {
            if (value && value !== this._watermarkWidth) {
                this._watermarkWidth = value;
                if (this.watermark) {
                    this.watermark.style.width = this.watermarkWidth + "px";
                }
            }
        }
    },

    watermarkUrl: {
        get: function () {
            return this._watermarkUrl;
        },
        set: function (value) {
            if (value && value !== this._watermarkUrl) {
                this._watermarkUrl = value;
                if (this.watermark) {
                    this.watermark.style.background = "url(" + this._watermarkUrl + ")";
                }
            }
        }
    },

    undoPositionChange: {
        value: function () {
            if (this.undo.length > 0) {
                this.redo.push(this._position);
                this._position = this.undo.pop();
                this.mapEngine.setCenterAndZoom(this._position.center, this._position.zoom);
            }
        }
    },

    unsetHoveredFeature: {
        value: function (value) {
            if (value && this.hoveredFeature === value) {
                this.hoveredFeature = null;
            }
        }
    },

    willDraw: {
        value: function () {
            if (this._needsInsetUpdate) {
                this._navigatorHeight = this.navigator.element.offsetHeight;
                this._scaleOverlayWidth = this.scaleOverlay.element.offsetWidth;
            }
        }
    },

    zoomButtonLabel: {
        value: "Zoom"
    }

}, {
    EngineKeys: {
        value: {
            LeafletEngine: "leaflet",
            GoogleEngine: "google"
        }
    }
});
