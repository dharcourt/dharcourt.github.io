/**
 * @module ui/figure-overlay.reel
 * @requires montage/ui/component
 */
var FigureComponent = require("ui/map/figure-component").FigureComponent,
    Figure = require("logic/model/figure").Figure,
    FigureType = require("logic/model/figure").FigureType,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    OverlayType = require("logic/map/overlay-type").OverlayType,
    PressComposer = require("montage/composer/press-composer").PressComposer,
    TranslateComposer = require("montage/composer/translate-composer").TranslateComposer;

/**
 * @class FigureOverlay
 * @extends Component
 */
exports.FigureOverlay = FigureOverlay = FigureComponent.specialize(/** @lends FigureOverlay# */ {

    constructor: {
        value: function FigureOverlay() {
            //this.super();
            this.figureId = FigureOverlay.nextFigureIndex;
        }
    },

    _calculateImageCoordinates: {
        value: function (originCoordinate) {

            var pixelOrigin = this.engine.coordinateToPoint(originCoordinate),
                mapWidth = this.mapComponent.element.clientWidth,
                mapHeight = this.mapComponent.element.clientHeight,
                imgWidth = Math.min((mapWidth/2),this.figure.cartesian.width),
                imgHeight = Math.min((mapHeight/2),this.figure.cartesian.height),
                ratio = imgWidth/imgHeight,
                northEast,southEast,southWest,coordinates;
            if (this.figure.aspectRatio > ratio) {
                imgHeight = imgWidth/this.figure.aspectRatio;
            } else if (this.figure.aspectRatio < ratio) {
                imgWidth = imgHeight*this.figure.aspectRatio;
            }
            var northEast = this.engine.pointToCoordinate({x: pixelOrigin.x + imgWidth, y: pixelOrigin.y}),
                southEast = this.engine.pointToCoordinate({x: pixelOrigin.x + imgWidth, y: pixelOrigin.y + imgHeight}),
                southWest = this.engine.pointToCoordinate({x: pixelOrigin.x, y: pixelOrigin.y + imgHeight}),
                coordinates = [originCoordinate,northEast,southEast,southWest];
            return coordinates;
        }
    },

    _events: {
        value: null
    },

    _engine: {
        value: null
    },

    _extendPathWithMidPoints: {
        value: function (path) {

            var i, length,
                extendedPath = [],
                point,
                x, y, midPoint;

            for (i = 0, length = path.length; i < length; i++) {
                point = path[i].split(",");
                if (i + 1 < length) {
                    var nextPoint = path[i+1].split(",");
                    x = (Number(point[0]) + Number(nextPoint[0])) / 2;
                    y = (Number(point[1]) + Number(nextPoint[1])) / 2;
                    midPoint = [x, y];
                    extendedPath.push(point.join(","), midPoint.join(","));
                } else {
                    extendedPath.push(point.join(","));
                }
            }

            if (this.figure.type === FigureType["Polygon"] && path.length > 1) {
                var firstPoint = path[0].split(","),
                    lastPoint = path[length - 1].split(",");
                x = (Number(firstPoint[0]) + Number(lastPoint[0])) / 2;
                y = (Number(firstPoint[1]) + Number(lastPoint[1])) / 2;
                midPoint = [x, y];
                extendedPath.push(midPoint.join(","));
            }

            return extendedPath;
        }
    },

    _handleCoordinates: {
        value: null
    },

    _illustrationOptions: {
        value: null
    },

    _initializeGeometryBoundaries: {
        value: function (point) {
            this.bounds.xMin = this.bounds.xMax = point.x;
            this.bounds.yMin = this.bounds.yMax = point.y;
        }
    },

    _isMoving: {
        value: false
    },

    _isResizing: {
        value: false
    },

    _persist: {
        value: function () {
            this.classList.add("contour-FigureOverlay--persisted");
            if (this.figure.isNewObject) {
                this.figure.isNewObject = false;
                this.engine.clearOverlayEvents(this);
                this.mapComponent.setSelectedFigureOverlay(this);
            }
            if (! this.initializedEvents) {
                this.element.addEventListener("mouseover", this);
                this.element.addEventListener("mouseup", this);
                this.element.addEventListener("mouseout", this);
                this.element.addEventListener("click", this);
                this.initializedEvents = true;
            }
        }
    },

    _disableDrag: {
        value: function () {
            this.engine.draggable = false;
        }
    },

    _disablePressEvents: {
        value: function () {
            this.removeComposer(this._pressComposer);
            if (this._pressComposer) {
                this._pressComposer.removeEventListener("press", this, false);
                this._pressComposer.removeEventListener("longPress", this, false);
            }
            this.engine.element.removeEventListener("click", this, true);
        }
    },

    _disableTranslationEvents: {

    },

    _enableDrag: {
        value: function () {
            this.engine.draggable = true;
        }
    },

    handleClick: {
        value: function (event) {
            this.mapComponent.setSelectedFigureOverlay(this);
        }
    },

    captureClick: {
        value: function(event) {
            event.stopPropagation();
        }
    },

    handleMouseover: {
        value: function () {
            this._disableDrag();
        }
    },

    handleMouseout: {
        value: function () {
            this._enableDrag();
        }
    },

    handleMouseup: {
        value: function () {
            this._disableDrag();
        }
    },

    _prepareForPressEvents: {
        value: function () {
            if (this._pressComposer === null) {
                this._pressComposer = PressComposer.create();
            }
            this.addComposerForElement(this._pressComposer, this.engine.element);
            this._pressComposer.addEventListener("press", this, false);
            if (this.figure.type !== FigureType["Annotation"] && this.figure.type !== FigureType["Placemark"] && this.figure.type !== FigureType["Image"]) {
                this._pressComposer.addEventListener("longPress", this, false);
            }
            if (this.figure.isNewObject) {
                this.engine.element.addEventListener("click", this, true);
            }
        }
    },

    _prepareForTranslationEvents: {
        value: function () {
            if (this._translateComposer === null) {
                this._translateComposer = TranslateComposer.create();
                this._translateComposer.hasMomentum = false;
            }
            this.addComposer(this._translateComposer);
            this._translateComposer.addEventListener("translate", this, false);
            this._translateComposer.addEventListener("translateStart", this, false);
            this._translateComposer.addEventListener("translateEnd", this, false);
        }
    },

    _pressComposer: {
        value: null
    },

    _translateComposer: {
        value: null
    },

    _type: {
        value: OverlayType["Figure"]
    },

    _updateGeometryBoundaries: {

        value: function (point) {
            if (this.bounds.xMin > point.x) {
                this.bounds.xMin = point.x;
            }
            if (this.bounds.xMax < point.x) {
                this.bounds.xMax = point.x;
            }
            if (this.bounds.yMin > point.y) {
                this.bounds.yMin = point.y;
            }
            if (this.bounds.yMax < point.y) {
                this.bounds.yMax = point.y;
            }
        }
    },

    addBuffer: {
        value: function () {
            this.bounds.xMin -= 10;
            this.bounds.xMax += 10;
            this.bounds.yMin -= 10;
            this.bounds.yMax += 10;
        }
    },

    addHandles: {
        value: function () {

            var group = this.createGroup();

            switch (this.figure.type) {
                case FigureType["Rectangle"]:

                    var structure = this.element.querySelector(this.elementName),
                        x = parseInt(structure.getAttribute("x"), 10),
                        y = parseInt(structure.getAttribute("y"), 10),
                        width = parseInt(structure.getAttribute("width"), 10),
                        height = parseInt(structure.getAttribute("height"), 10);

                    group.setAttributeNS(null, "class", "contour-FigureOverlayGroup--resizable");
                    group.appendChild(this.createHandle(0, {x: x, y: y}));
                    group.appendChild(this.createHandle(1, {x: x + width, y: y}));
                    group.appendChild(this.createHandle(2, {x: x + width, y: y + height}));
                    group.appendChild(this.createHandle(3, {x: x, y: y + height}));
                    break;
                case FigureType["Image"]:
                    var structure = this.element.querySelector(this.elementName),
                        x = parseInt(structure.getAttribute("x"), 10),
                        y = parseInt(structure.getAttribute("y"), 10),
                        width = parseInt(structure.getAttribute("width"), 10),
                        height = parseInt(structure.getAttribute("height"), 10);
                    group.appendChild(this.createHandle(0, {x: x + width, y: y + height}));
                    break;
                case FigureType["Circle"]:
                    var coordinate = this.figure.coordinates[0][1],
                        left = parseFloat(this.element.style.left, 10),
                        top = parseFloat(this.element.style.top, 10),
                        point = this.engine.coordinateToPoint(coordinate);

                    point.x = point.x - left;
                    point.y = point.y - top;

                    group.setAttributeNS(null, "class", "contour-FigureOverlayGroup--resizable");
                    group.appendChild(this.createHandle(0, point));
                    break;

                case FigureType["Polygon"]:
                case FigureType["Polyline"]:

                    var structure = this.element.querySelector(this.elementName),
                        points = structure.getAttribute("points").split(" "),
                        group = document.createElementNS('http://www.w3.org/2000/svg', 'g'),
                        point,
                        i, length;

                    group.setAttributeNS(null, "class", "contour-FigureOverlayGroup--editable");
                    if (this.figure.type === FigureType["Polygon"] || this.figure.hasLabel === false) {
                        points = this._extendPathWithMidPoints(points);
                    }
                    for (i = 0, length = points.length; i < length; i++) {
                        point = points[i].split(",");
                        group.appendChild(this.createHandle(i, {
                            x: point[0],
                            y: point[1]
                        }));
                    }

                    break;
            }

            this.element.appendChild(group);
            this.needsHandles = false;
        }
    },

    calculateAnnotationGeometry: {
        value: function () {
            var origin = this.figure.coordinates,
                originPixelLocation = this.engine.coordinateToPoint(origin),
                label = this.element.querySelector("text"),
                labelBoxPadding = 6,
                textMeasurement, labelHeight, labelHeight;

            this.bounds.xMin = originPixelLocation.x;
            this.bounds.yMin = originPixelLocation.y;

            if (label) {
                textMeasurement = label.getBBox();
                labelWidth = textMeasurement.width + labelBoxPadding * 2;
                labelHeight = textMeasurement.height + labelBoxPadding * 2;
                this.bounds.xMax = this.bounds.xMin + labelWidth;
                this.bounds.yMax = this.bounds.yMin + labelHeight;
            }
        }
    },

    calculateCircleGeometry: {
        value: function () {
            if (this.figure.radius > 0) {

                var centerCoordinate = this.figure.coordinates[0][0],
                    centerEngineLocation = this.engine.coordinateToPoint(centerCoordinate),
                    centerPixel = this.engine.coordinateToPixels(centerCoordinate),
                    zoom = this.engine.position.zoom,
                    mapSize = 256 * Math.pow(2, zoom),
                    shift = {
                        x: centerEngineLocation.x - centerPixel.x,
                        y: centerEngineLocation.y - centerPixel.y
                    },
                    coordinates = GeometryUtilities.circleArcCoordinates(centerCoordinate, this.figure.radius, 72),
                    points = [], point,
                    i, length;


                this.figure.cartesian.center = centerEngineLocation;

                for (i = 0, length = coordinates.length; i < length; i++) {

                    var coordinate = coordinates[i].coordinate,
                        bearing = coordinates[i].bearing,
                        pixelLocation = this.engine.coordinateToPixels(coordinate);
                    if (bearing > 0 && bearing < 180 && pixelLocation.x < centerPixel.x) {
                        pixelLocation.x += mapSize;
                    } else if (bearing > 180 && bearing < 360 && pixelLocation.x > centerPixel.x) {
                        pixelLocation.x -= mapSize;
                    }
                    point = {
                        x: pixelLocation.x + shift.x,
                        y: pixelLocation.y + shift.y
                    };
                    points.push(point);
                    if (i === 0) {
                        this._initializeGeometryBoundaries(point);
                    } else {
                        this._updateGeometryBoundaries(point);
                    }
                }
                this.points[0] = points;
            }
        }
    },

    calculateImageGeometry: {
        value: function() {
            var coordinates = this.figure.coordinates;
            if (coordinates && coordinates.length < 4) {
                this.figure.coordinates = coordinates = this._calculateImageCoordinates(coordinates[0]);
            }
            var    originPoint = this.engine.coordinateToPoint(coordinates[0]),
                originPixelLocation = this.engine.coordinateToPixels(coordinates[0]),
                shift = {
                    x: originPoint.x - originPixelLocation.x,
                    y: originPoint.y - originPixelLocation.y
                },
                southWest = coordinates[3],
                northEast = coordinates[1],
                northEastPoint = this.engine.coordinateToPixels(northEast),
                southWestPoint = this.engine.coordinateToPixels(southWest),
                zoomLevel = this.engine.position.zoom,
                mapSize = Math.pow(2, zoomLevel) * 256,
                meridianShift = (mapSize - southWestPoint.x < ((northEastPoint.x - southWestPoint.x) / 2)) ? -1 : 0,
                left = southWestPoint.x + shift.x + meridianShift * mapSize,
                top = northEastPoint.y + shift.y,
                meridianShift = (meridianShift > -1 && northEastPoint.x < southWestPoint.x) ? +1 : meridianShift,
                right = northEastPoint.x + shift.x + meridianShift * mapSize,
                bottom = southWestPoint.y + shift.y,
                points = [],
                height = Math.abs(top - bottom),
                width = Math.abs(left - right),
                ratio = width/height;


            if (!this.figure.preserveAspectRatio) {
                this.figure.aspectRatio = ratio;
            } else if (this.figure.aspectRatio.toFixed(4) !== ratio.toFixed(4)) {
                if (this.figure.preserveAspectRatio) {
                    if (this.figure.aspectRatio < ratio) {
                        height = width/this.figure.aspectRatio;
                    } else {
                        width = height*this.figure.aspectRatio;
                    }
                }
                this.bounds.xMax = this.bounds.xMin + width;
                this.bounds.yMax = this.bounds.yMin + height;

                this.figure.coordinates = [
                    this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMin}),
                    this.engine.pointToCoordinate({x: this.bounds.xMax, y: this.bounds.yMin}),
                    this.engine.pointToCoordinate({x: this.bounds.xMax, y: this.bounds.yMax}),
                    this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMax}),
                    this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMin})
                ];

                this.figure.bbox = [
                    this.figure.coordinates[0][0], // west
                    this.figure.coordinates[2][1], // south
                    this.figure.coordinates[2][0], // east
                    this.figure.coordinates[0][1]  // north
                ];
                right = left + width;
                bottom = top + height;
            }



            points.push({
                x: left,
                y: top
            });
            this._initializeGeometryBoundaries(points[0]);
            points.push({
                x: right,
                y: top
            });
            this._updateGeometryBoundaries(points[1]);
            points.push({
                x: right,
                y: bottom
            });
            this._updateGeometryBoundaries(points[2]);
            points.push({
                x: left,
                y: bottom
            });
            this._updateGeometryBoundaries(points[3]);
            this.points = points;
        }
    },

    calculateLabelGeometry: {
        value: function (text) {

            var label = this.element.querySelector("text"),
                labelWidth,
                labelHeight,
                minX, maxX,
                minY, maxY,
                labelBoxPadding = 6,
                textMeasurement;

            if (label) {

                label.textContent = text;
                textMeasurement = label.getBBox();
                labelWidth = textMeasurement.width + labelBoxPadding * 2;
                labelHeight = textMeasurement.height + labelBoxPadding * 2;
                minX = this.bounds.xMax - labelWidth;
                maxX = this.bounds.xMin + labelWidth;
                minY = this.bounds.yMax - labelHeight;
                maxY = this.bounds.yMin + labelHeight;

                if (this.bounds.xMin > minX) {
                    this.bounds.xMin = minX;
                }
                if (this.bounds.xMax < maxX) {
                    this.bounds.xMax = maxX;
                }
                if (this.bounds.yMin > minY) {
                    this.bounds.yMin = minY;
                }
                if (this.bounds.yMax < maxY) {
                    this.bounds.yMax = maxY;
                }
            }
        }
    },

    calculateLineGeometry: {
        value: function () {
            if (this.figure.coordinates[0][0] && this.figure.coordinates[0][1]) {
                this.points[1] = [
                    this.engine.coordinateToPoint(this.figure.coordinates[0][0]),
                    this.engine.coordinateToPoint(this.figure.coordinates[0][1])
                ];
            }
        }
    },

    calculatePathGeometry: {
        value: function () {

            var i, length,
                bearing,
                coordinate,
                mapSize = 256 * Math.pow(2, this.engine.position.zoom),
                meridianShift = 0,
                originPoint = this.engine.coordinateToPoint(this.figure.geometry.coordinates[0]),
                originPixelLocation = this.engine.coordinateToPixels(this.figure.geometry.coordinates[0]),
                pixelLocation,
                point,
                points = [],
                previousCoordinate,
                shift = {
                    x: originPoint.x - originPixelLocation.x,
                    y: originPoint.y - originPixelLocation.y
                };

            for (i = 0, length = this.figure.geometry.coordinates.length; i < length; i++) {

                coordinate = this.figure.geometry.coordinates[i];
                pixelLocation = this.engine.coordinateToPixels(coordinate);

                if (previousCoordinate) {
                    bearing = GeometryUtilities.bearingToPoint(previousCoordinate, coordinate);
                    if (bearing > 0 && bearing < 180 && previousCoordinate[0] > 0 && coordinate[0] < 0) {
                        meridianShift += 1;
                    } else if (bearing > 180 && bearing < 360 && previousCoordinate[0] < 0 && coordinate[0] > 0) {
                        meridianShift -= 1;
                    }
                }

                previousCoordinate = coordinate;
                point = {
                    x: pixelLocation.x + shift.x + meridianShift * mapSize,
                    y: pixelLocation.y + shift.y
                };

                points.push(point);

                if (i === 0) {
                    this._initializeGeometryBoundaries(point);
                } else {
                    this._updateGeometryBoundaries(point);
                }
            }

            this.points = points;

        }
    },

    calculatePlacemarkGeometry:{
        value:function() {
            var origin = this.figure.coordinates,
                originPixelLocation = this.engine.coordinateToPoint(origin),
                label = this.element.querySelector("text"),
                labelBoxPadding = 6,
                textMeasurement,
                labelHeight, labelWidth;

            this.bounds.xMin = originPixelLocation.x;
            this.bounds.yMin = originPixelLocation.y;

            if (label) {
                textMeasurement = label.getBBox();
                labelWidth = textMeasurement.width + labelBoxPadding * 2;
                labelHeight = textMeasurement.height + labelBoxPadding * 2;
                this.bounds.xMin = originPixelLocation.x - labelWidth/2;
                this.bounds.yMin = originPixelLocation.y - labelHeight;
                this.bounds.xMax = this.bounds.xMin + labelWidth;
                this.bounds.yMax = this.bounds.yMin + labelHeight;

            }
        }
    },

    calculateDistanceLabels: {
        value: function () {
            var coordinates = this.figure.coordinates,
                coordinate, nextCoordinate,
                point, nextPoint,
                distance, midPoint,
                distanceLabels = [],
                i, length;

            for (i = 0; length = coordinates.length, i < length; i++) {
                if (i + 1 < length) {
                    coordinate = coordinates[i];
                    nextCoordinate = coordinates[i+1];
                    point = this.points[i];
                    nextPoint = this.points[i+1];
                    midPoint = {
                        x: (nextPoint.x + point.x) / 2,
                        y: (nextPoint.y + point.y) / 2
                    };

                    distance = GeometryUtilities.distanceBetweenGeographicPoints(coordinate, nextCoordinate);
                    distanceLabels.push({
                        distance: distance,
                        midPoint: midPoint
                    });

                }
            }
            this.figure.distanceLabels = distanceLabels;
        }
    },

    calculatePolygonCenter: {
        value: function () {
            this.figure.cartesian.center = {
                x: ((this.bounds.xMax - this.bounds.xMin) / 2) + this.bounds.xMin,
                y: ((this.bounds.yMax - this.bounds.yMin) / 2) + this.bounds.yMin
            };
            this.figure.updateLabel();
        }
    },

    calculateRectangleGeometry: {
        value: function () {
            var coordinates = this.figure.coordinates,
                originPoint = this.engine.coordinateToPoint(coordinates[0]),
                originPixelLocation = this.engine.coordinateToPixels(coordinates[0]),
                shift = {
                    x: originPoint.x - originPixelLocation.x,
                    y: originPoint.y - originPixelLocation.y
                },
                southWest = coordinates[3],
                northEast = coordinates[1],
                northEastPoint = this.engine.coordinateToPixels(northEast),
                southWestPoint = this.engine.coordinateToPixels(southWest),
                lastPoint,
                zoomLevel = this.engine.position.zoom,
                mapSize = Math.pow(2, zoomLevel) * 256,
                meridianShift = 0,
                points = [];

            if (mapSize - southWestPoint.x < ((northEastPoint.x - southWestPoint.x) / 2)) {
                meridianShift = -1;
            }
            points.push({
                x: southWestPoint.x + shift.x + meridianShift * mapSize,
                y: northEastPoint.y + shift.y
            });
            this._initializeGeometryBoundaries(points[0]);
            lastPoint = {
                x: southWestPoint.x + shift.x + meridianShift * mapSize,
                y: southWestPoint.y + shift.y
            };
            if (meridianShift > -1 && northEastPoint.x < southWestPoint.x) {
                meridianShift = +1;
            }
            points.push({
                x: northEastPoint.x + shift.x + meridianShift * mapSize,
                y: northEastPoint.y + shift.y
            });
            this._updateGeometryBoundaries(points[1]);
            points.push({
                x: northEastPoint.x + shift.x + meridianShift * mapSize,
                y: southWestPoint.y + shift.y
            });
            this._updateGeometryBoundaries(points[2]);
            points.push(lastPoint);
            this._updateGeometryBoundaries(points[3]);
            this.points = points;
        }
    },

    checkViewPort: {
        value: function () {

            if (this.isMoving) {
                switch (this.figure.type) {
                    case FigureType["Circle"]:

                        var figureCenter = this.figure.center,
                            mapPixelCenter = this.engine.coordinateToPoint(this.engine.getCenter()),
                            figurePixelCenter = this.engine.coordinateToPoint(figureCenter),
                            width = this.engine.size.width,
                            height = this.engine.size.height,
                            distanceX = 0, distanceY = 0;

                        if (figurePixelCenter.x < (mapPixelCenter.x - width / 2)) {
                            distanceX = -Math.abs(figurePixelCenter.x - (mapPixelCenter.x - width / 2));
                            if (distanceX < -20) distanceX = -20;
                        } else if (figurePixelCenter.x > (mapPixelCenter.x + width / 2)) {
                            distanceX = Math.abs(figurePixelCenter.x - (mapPixelCenter.x + width / 2));
                            if (distanceX > 20) distanceX = 20;
                        }

                        if (Math.abs(figureCenter[1]) < 80) {
                            if (figurePixelCenter.y < (mapPixelCenter.y - height / 2)) {
                                distanceY = -Math.abs(figurePixelCenter.y - (mapPixelCenter.y - height / 2));
                                if (distanceY < -20) distanceY = -20;
                            } else if (figurePixelCenter.y > (mapPixelCenter.y + height / 2)) {
                                distanceY = Math.abs(figurePixelCenter.y - (mapPixelCenter.y + height / 2));
                                if (distanceY > 20) distanceY = 20;
                            }
                        }

                        if (distanceX !== 0 || distanceY !== 0) {
                            this.figure.center = this.engine.pointToCoordinate({
                                x: figurePixelCenter.x + distanceX,
                                y: figurePixelCenter.y + distanceY
                            });
                            this.needsDraw = true;
                            this.engine.move(distanceX, distanceY);
                        }
                        break;
                }

            }
        }
    },

    didZoom: {
        value: function () {
            this.redraw();
            this.element.classList.remove("contour-FigureOverlay--zooming");
        }
    },

    createGroup: {
        value: function () {
            var group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttributeNS(null, "stroke", "red");
            group.setAttributeNS(null, "fill", "black");
            group.setAttributeNS(null, "stroke-width", 2);
            return group;
        }
    },

    createHandle: {
        value: function (identifier, point) {
            var handle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            handle.setAttributeNS(null, "cx", point.x);
            handle.setAttributeNS(null, "cy", point.y);
            handle.setAttributeNS(null, "r", 5);
            handle.setAttributeNS(null, "data-type", "handle");
            handle.setAttributeNS(null, "data-identifier", identifier);
            return handle;
        }
    },

    disableAreaSelection: {
        value: function () {
            this.engine.removeOverlayComponent(this);
        }
    },

    draw: {
        value: function () {

            if (this.figure && this.figure.needsDraw) {

                this.super();
                if (this.figure.type === FigureType["Polyline"] && this.figure.needsLabelUpdate) {
                    this.removeHandles();
                    this.addHandles();
                    this.figure.needsLabelUpdate = false;
                } else if (this.figure.type == FigureType["Placemark"]) {
                    var textElement = this.element.querySelector("text");
                    if (textElement) {
                        textElement.setAttributeNS(null,"class","contour-FigureOverlay--placemark");
                    }
                }

                if (this.selected) {
                    if (this.needsHandles) {
                        this.element.style.zIndex = 3000;
                        this.addHandles();
                    } else {
                        this.updateHandles();
                    }
                } else {
                    this.element.style.zIndex = 2000;
                    this.removeHandles();
                }

                if (this.isMoving) {
                    this.checkViewPort();
                }
            }
        }
    },

    engine: {
        get: function () {
            return this._engine;
        },
        set: function (value) {
            if (value && value !== this._engine) {
                if (this._engine) {
                    this._engine.removeOverlayComponent(this);
                }
                this._engine = value;
                if (this.figure) {
                    this._engine.addOverlayComponent(this);
                }
            }
        }
    },

    engineShift: {
        writeable: true,
        value: 0
    },

    events: {
        get: function () {
            if (this._events === null) {
                this._events = {};
            }
            return this._events;
        },
        set: function (value) {
            this._events = value;
        }
    },

    enterDocument: {
        value: function (firstTime) {
            if (this.element) {
                this.element.setAttribute("contour-figure-id", this.figureId);
            }
            if (this.figure && this.engine) {
                this.engine.addOverlayComponent(this);
            }
            if (! firstTime) {
                this.prepareForActivationEvents();
            }
        }
    },

    exitDocument: {
        value: function () {

            if (this._pressComposer) {
                this._pressComposer.removeEventListener("press", this, false);
                this._pressComposer.removeEventListener("longPress", this, false);
                this.engine.element.removeEventListener("click", this,true);
                this.removeComposer(this._pressComposer);
                //this._pressComposer = null;
            }
            if (this._translateComposer) {
                this._translateComposer.removeEventListener("translate", this, false);
                this._translateComposer.removeEventListener("translateStart", this, false);
                this._translateComposer.removeEventListener("translateEnd", this, false);
                this.removeComposer(this._translateComposer);
                //this._translateComposer = null;
            }
            if (this.initializedEvents) {
                this.element.removeEventListener("mouseover", this);
                this.element.removeEventListener("mouseup", this);
                this.element.removeEventListener("mouseout", this);
                this.element.removeEventListener("click", this);
                this.initializedEvents = false;
            }
            var index = this.figure.components.indexOf(this);
            if (index > -1) {
                this.figure.components.splice(index, 1);
            }
            this.figure = null;
            this.engine.removeOverlayComponent(this);
            this.needsHandles = true;
            this.element.parentNode.removeChild(this.element);
            this.classList.remove("contour-FigureOverlay--persisted");

        }
    },

    handleLongPress: {
        value: function (event) {
            this._persist();
            this._disablePressEvents();
            this._prepareForTranslationEvents();
            this.mapComponent.enterPanMode();
        }
    },

    handlePress: {
        value: function (event) {

            var boundingRectangle = this._pressComposer.element.getBoundingClientRect(),
                x = event.event.clientX - boundingRectangle.left,
                y = event.event.clientY - boundingRectangle.top,
                mapCenter = this.engine.getCenter(),
                mapPixelCenter = this.engine.coordinateToPoint(mapCenter),
                left = mapPixelCenter.x - boundingRectangle.width / 2,
                top = mapPixelCenter.y - boundingRectangle.height / 2,
                coordinate = this.engine.pointToCoordinate({x: left + x, y: top + y});

            if (this.figure && this.figure.isNewObject === true) {

                switch (this.figure.type) {
                    case FigureType["Annotation"]:
                    case FigureType["Placemark"]:
                        this.figure.coordinates = coordinate;
                        this._persist();
                        this._disablePressEvents();
                        this._prepareForTranslationEvents();
                        this.mapComponent.enterPanMode();
                        break;
                    case FigureType["Image"]:
                        var coordinates = this._calculateImageCoordinates(coordinate);
                        this.figure.coordinates = coordinates;
                        this.figure.isPlaced = true;
                        this._persist();
                        this._disablePressEvents();
                        this._prepareForTranslationEvents();
                        this.mapComponent.enterPanMode();
                    default:
                        this.figure.addCoordinate(coordinate);
                        break;
                }

                this.figure.needsDraw = true;
                this.needsDraw = true;

            } else {
                // TODO return the coordinate of the click if a callback is defined.
            }

        }
    },

    hasTemplate: {
        value: true
    },

    handleTranslate: {
        value: function(event) {
            if (this.isPersistent === false || this.figure.isNewObject) {

                this.translationPoint.x = this.origin.x + this._translateComposer.translateX;
                this.translationPoint.y = this.origin.y + this._translateComposer.translateY;

                switch (this.figure.type) {
                    case FigureType["Rectangle"]:

                        var width = Math.abs(this.origin.x - this.translationPoint.x),
                            height = Math.abs(this.origin.y - this.translationPoint.y);

                        this.bounds.xMin = Math.min(this.origin.x, this.translationPoint.x);
                        this.bounds.yMin = Math.min(this.origin.y, this.translationPoint.y);
                        this.bounds.xMax = this.bounds.xMin + width;
                        this.bounds.yMax = this.bounds.yMin + height;

                        this.figure.coordinates = [
                            this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMin}),
                            this.engine.pointToCoordinate({x: this.bounds.xMax, y: this.bounds.yMin}),
                            this.engine.pointToCoordinate({x: this.bounds.xMax, y: this.bounds.yMax}),
                            this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMax}),
                            this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMin})
                        ];

                        this.figure.bbox = [
                            this.figure.coordinates[0][0], // west
                            this.figure.coordinates[2][1], // south
                            this.figure.coordinates[2][0], // east
                            this.figure.coordinates[0][1]  // north
                        ];
                        break;
                    case FigureType["Circle"]:
                        this.translateCoordinate = this.engine.pointToCoordinate(this.translationPoint);
                        this.figure.coordinates[0][1] = this.translateCoordinate;
                        this.figure.radius = GeometryUtilities.distanceBetweenGeographicPoints(this.startCoordinate, this.translateCoordinate) * 1000;
                        this.figure.bbox = GeometryUtilities.boundingBoxForCircle(this.startCoordinate, this.figure.radius);
                        this.figure.bearing = GeometryUtilities.bearingToPoint(this.startCoordinate, this.translateCoordinate);
                        break;
                    case FigureType["Polyline"]:
                    case FigureType["Polygon"]:
                       this.translateCoordinate = this.engine.pointToCoordinate(this.translationPoint);
                        this.figure.coordinates.push(this.translateCoordinate);
                        this.calculatePathGeometry();
                        // Only add for free hand?  Probably.
                        this.points = GeometryUtilities.simplify(this.points, 2.0, true);
                        var coordinates = [],
                            i, length;
                        for (i = 0, length = this.points.length; i < length; i++) {
                            coordinates.push(this.engine.pointToCoordinate(this.points[i]));
                        }
                        this.figure.coordinates = coordinates;
                        break;
                }

            } else {

                var target = event.target,
                    pointerX = target._pointerX,
                    pointerY = target._pointerY,
                    screenWidth = window.innerWidth,
                    screenHeight = window.innerHeight,
                    type = this.target.getAttribute("data-type");

                switch (this.figure.type) {

                    case FigureType["Annotation"]:
                    case FigureType["Placemark"]:


                        var left = this.bounds.xMin + this._translateComposer.translateX,
                            top = this.bounds.yMin + this._translateComposer.translateY;

                        this.element.style.left = this.engineShift + left + "px";
                        this.element.style.top = top + "px";
                        this.isMoving = true;

                        break;
                    case FigureType["Image"]:

                        if (type && type === "handle") {
                            this.translationPoint.x = this.origin.x + this.originShift.x + this._translateComposer.translateX;
                            this.translationPoint.y = this.origin.y + this.originShift.y + this._translateComposer.translateY;

                            var width = Math.abs(this.origin.x - this.translationPoint.x),
                                height = Math.abs(this.origin.y - this.translationPoint.y);
                            if (width < 10) {
                                width = 10
                            }
                            if (height < 10) {
                                height = 10;
                            }

                            this.bounds.xMin = this.origin.x;
                            this.bounds.yMin = this.origin.y;
                            this.bounds.xMax = this.bounds.xMin + width;
                            this.bounds.yMax = this.bounds.yMin + height;

                            this.figure.coordinates = [
                                this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMin}),
                                this.engine.pointToCoordinate({x: this.bounds.xMax, y: this.bounds.yMin}),
                                this.engine.pointToCoordinate({x: this.bounds.xMax, y: this.bounds.yMax}),
                                this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMax}),
                                this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMin})
                            ];

                            this.figure.bbox = [
                                this.figure.coordinates[0][0], // west
                                this.figure.coordinates[2][1], // south
                                this.figure.coordinates[2][0], // east
                                this.figure.coordinates[0][1]  // north
                            ];




                        } else {
                            var left = this.bounds.xMin + this._translateComposer.translateX,
                                top = this.bounds.yMin + this._translateComposer.translateY;
                            this.element.style.left = this.engineShift + left + "px";
                            this.element.style.top = top + "px";
                            this.isMoving = true;
                        }


                        break;
                    case FigureType["Rectangle"]:

                        if (type && type === "handle") {

                            this.translationPoint.x = this.origin.x - this.originShift.x + this._translateComposer.translateX;
                            this.translationPoint.y = this.origin.y - this.originShift.y + this._translateComposer.translateY;

                            var width = Math.abs(this.origin.x - this.translationPoint.x),
                                height = Math.abs(this.origin.y - this.translationPoint.y);


                            this.bounds.xMin = Math.min(this.origin.x, this.translationPoint.x);
                            this.bounds.yMin = Math.min(this.origin.y, this.translationPoint.y);
                            this.bounds.xMax = this.bounds.xMin + width;
                            this.bounds.yMax = this.bounds.yMin + height;

                            this.figure.coordinates = [
                                this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMin}),
                                this.engine.pointToCoordinate({x: this.bounds.xMax, y: this.bounds.yMin}),
                                this.engine.pointToCoordinate({x: this.bounds.xMax, y: this.bounds.yMax}),
                                this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMax}),
                                this.engine.pointToCoordinate({x: this.bounds.xMin, y: this.bounds.yMin})
                            ];

                            this.figure.bbox = [
                                this.figure.coordinates[0][0], // west
                                this.figure.coordinates[2][1], // south
                                this.figure.coordinates[2][0], // east
                                this.figure.coordinates[0][1]  // north
                            ];

                        } else {
                            var left = this.bounds.xMin + this._translateComposer.translateX,
                                top = this.bounds.yMin + this._translateComposer.translateY;
                            this.element.style.left = this.engineShift + left + "px";
                            this.element.style.top = top + "px";
                            this.isMoving = true;
                        }

                        break;

                    case FigureType["Polyline"]:
                    case FigureType["Polygon"]:
                        if (type && type === "handle") {

                            var divisor = this.figure.type === FigureType["Polygon"] ||
                                this.figure.hasLabel === false ? 2 : 1,
                                index = parseInt(this.target.getAttribute("data-identifier"), 10) / divisor,
                                coordinates = this.figure.coordinates,
                                handleCoordinate = coordinates[index],
                                handlePixelPosition = this.engine.coordinateToPoint(handleCoordinate),
                                oldTranslationPoint = {
                                    x: this.translationPoint.x,
                                    y: this.translationPoint.y
                                },
                                pixelChangeHorizontal,
                                pixelChangeVertical;

                            this.isResizing = true;
                            this.translationPoint.x = this.origin.x + this._translateComposer.translateX;
                            this.translationPoint.y = this.origin.y + this._translateComposer.translateY;
                            pixelChangeHorizontal = oldTranslationPoint.x - this.translationPoint.x;
                            pixelChangeVertical = oldTranslationPoint.y - this.translationPoint.y;
                            handlePixelPosition.x -= pixelChangeHorizontal;
                            handlePixelPosition.y -= pixelChangeVertical;
                            handleCoordinate = this.engine.pointToCoordinate(handlePixelPosition);
                            coordinates[index] = handleCoordinate;
                            this.figure.coordinates = coordinates;

                        } else {

                            var left = this.bounds.xMin + this._translateComposer.translateX,
                                top = this.bounds.yMin + this._translateComposer.translateY;

                            this.element.style.left = this.engineShift + left + "px";
                            this.element.style.top = top + "px";
                            this.isMoving = true;
                        }

                        break;

                    case FigureType["Circle"]:

                        if (pointerX > 0 && pointerX < screenWidth &&
                            pointerY > 0 && pointerY < screenHeight) {

                            if (type && type === "handle") {

                                var centerCoordinate = this.figure.coordinates[0][0],
                                    handleCoordinate = this.figure.coordinates[0][1],
                                    handlePixelPosition = this.engine.coordinateToPoint(handleCoordinate),
                                    oldTranslationPoint = {
                                        x: this.translationPoint.x,
                                        y: this.translationPoint.y
                                    },
                                    pixelChangeHorizontal,
                                    pixelChangeVertical;

                                this.isResizing = true;
                                this.translationPoint.x = this.origin.x + this._translateComposer.translateX;
                                this.translationPoint.y = this.origin.y + this._translateComposer.translateY;
                                pixelChangeHorizontal = oldTranslationPoint.x - this.translationPoint.x;
                                pixelChangeVertical = oldTranslationPoint.y - this.translationPoint.y;
                                handlePixelPosition.x -= pixelChangeHorizontal;
                                handlePixelPosition.y -= pixelChangeVertical;
                                handleCoordinate = this.engine.pointToCoordinate(handlePixelPosition);
                                this.figure.coordinates[0] = [centerCoordinate, handleCoordinate];
                                this.figure.radius = GeometryUtilities.distanceBetweenGeographicPoints(centerCoordinate, handleCoordinate) * 1000;
                                this.figure.bearing = GeometryUtilities.bearingToPoint(centerCoordinate, handleCoordinate);
                                this.figure.bbox = GeometryUtilities.boundingBoxForCircle(centerCoordinate, this.figure.radius);
                            } else {

                                var centerCoordinate = this.figure.coordinates[0][0],
                                    centerPixelPosition = this.engine.coordinateToPoint(centerCoordinate),
                                    oldTranslationPoint = {
                                        x: this.translationPoint.x,
                                        y: this.translationPoint.y
                                    },
                                    pixelChangeHorizontal,
                                    pixelChangeVertical;

                                this.isMoving = true;
                                this.translationPoint.x = this.origin.x + this._translateComposer.translateX;
                                this.translationPoint.y = this.origin.y + this._translateComposer.translateY;
                                pixelChangeHorizontal = oldTranslationPoint.x - this.translationPoint.x;
                                pixelChangeVertical = oldTranslationPoint.y - this.translationPoint.y;
                                centerPixelPosition.x -= pixelChangeHorizontal;
                                centerPixelPosition.y -= pixelChangeVertical;
                                centerCoordinate = this.engine.pointToCoordinate(centerPixelPosition);
                                this.translateCoordinate = GeometryUtilities.vincentyDirect(centerCoordinate, null, this.figure.radius, this.figure.bearing).point;
                                this.figure.coordinates[0] = [centerCoordinate, this.translateCoordinate];
                                this.figure.bbox = GeometryUtilities.boundingBoxForCircle(centerCoordinate, this.figure.radius);
                                this.figure.radius = this.figure.radius;
                                this.checkViewPort();
                            }
                        } else {
                            this.isMoving = false;
                        }
                        break;
                }
            }
        }
    },

    handleTranslateEnd: {
        value: function(event) {

            if (this.isPersistent === false || this.figure.isNewObject) {

                if (this.isPersistent) {
                    if (this.figure.isValid()) {
                        this._persist();
                    } else {
                        //this.mapComponent.removeFigure(this.figure);
                    }
                } else {
                    this.clearCanvas();
                    this.engine._positionFigureOverlay(this);
                    if (this._illustrationOptions.callback && this.isValidAreaBriefBounds()) {
                        this._illustrationOptions.callback(this.figure);
                    }
                    if (this.figure) {
                        this.figure.needsDraw = false;
                    }
                }

            } else if (this.isPersistent === true && this.figure.isNewObject === false) {

                switch (this.figure.type) {

                    case FigureType["Annotation"]:
                        var left = parseFloat(this.element.style.left, 10) - this.engineShift,
                            top = parseFloat(this.element.style.top, 10);

                        this.figure.coordinates = this.engine.pointToCoordinate({
                            x: left, y: top
                        });
                        break;
                    case FigureType["Placemark"]:

                        var left = parseFloat(this.element.style.left, 10) - this.engineShift,
                            top = parseFloat(this.element.style.top, 10),
                            height = this.figure.cartesian.height,
                            width = this.figure.cartesian.width;

                        this.figure.coordinates = this.engine.pointToCoordinate({
                            x: left + width/2, y: top + height
                        });
                        break;

                    case FigureType["Rectangle"]:
                    case FigureType["Image"]:
                        if (this.isMoving) {
                            var left = parseFloat(this.element.style.left, 10) - this.engineShift,
                                top = parseFloat(this.element.style.top, 10),
                                structure = this.element.querySelector(this.elementName),
                                x = parseInt(structure.getAttribute("x"), 10),
                                y = parseInt(structure.getAttribute("y"), 10),
                                width = parseFloat(structure.getAttribute("width")),
                                height = parseFloat(structure.getAttribute("height")),
                                coordinates = [];

                            coordinates.push(this.engine.pointToCoordinate({
                                x: left + x,
                                y: top + y
                            }));
                            coordinates.push(this.engine.pointToCoordinate({
                                x: left + x + width,
                                y: top + y
                            }));
                            coordinates.push(this.engine.pointToCoordinate({
                                x: left + x + width,
                                y: top + y + height
                            }));
                            coordinates.push(this.engine.pointToCoordinate({
                                x: left + x,
                                y: top + y + height
                            }));
                            coordinates.push(this.engine.pointToCoordinate({
                                x: left + x,
                                y: top + y
                            }));

                            this.figure.coordinates = coordinates;
                        }

                        break;
                    case FigureType["Polyline"]:
                    case FigureType["Polygon"]:
                        if (this.isMoving) {

                            var left = parseFloat(this.element.style.left, 10) - this.engineShift,
                                top = parseFloat(this.element.style.top, 10),
                                structure = this.element.querySelector(this.elementName),
                                points = structure.getAttribute("points").split(" "),
                                point,
                                i, length;

                            this.bounds.xMin = left;
                            this.bounds.yMin = top;

                            this.figure.coordinates = [];

                            for (i = 0, length = points.length; i < length; i++) {

                                point = points[i].split(",");
                                var x = parseFloat(point[0], 10),
                                    y = parseFloat(point[1], 10);

                                this.figure.addCoordinate(this.engine.pointToCoordinate({
                                    x: x + this.bounds.xMin,
                                    y: y + this.bounds.yMin
                                }));
                            }
                        }

                        break;
                }
                this.element.classList.remove("contour-FigureOverlay--moving");
                this.isMoving = false;
                this.isResizing = false;
                this.needsDraw = true;
                this.figure.needsDraw = true;
            }

            this.mapComponent.enterPanMode();
        }
    },

    handleTranslateStart: {
        value: function(event) {
            var boundingRectangle = this.engine.element.getBoundingClientRect(),
                offset = this.engine.viewPortOffset();

            this._translateComposer.translateX = this._translateComposer.translateY = 0;

            this.origin = {
                x: offset.left + this._translateComposer.pointerStartEventPosition.pageX - boundingRectangle.left,
                y: offset.top + this._translateComposer.pointerStartEventPosition.pageY - boundingRectangle.top
            };

            this.translationPoint = {
                x: this.origin.x,
                y: this.origin.y
            };

            if (this.isPersistent === false || this.figure.isNewObject) {

                var coordinates;

                this.startCoordinate = this.engine.pointToCoordinate(this.origin);
                this.translateCoordinate = [this.startCoordinate[0], this.startCoordinate[1]];
                this.bounds.xMin = this.bounds.xMax = this.origin.x;
                this.bounds.yMin = this.bounds.yMax = this.origin.y;

                switch (this.figure.type) {
                    case FigureType["Rectangle"]:
                        coordinates = [
                            this.startCoordinate,
                            this.startCoordinate,
                            this.startCoordinate,
                            this.startCoordinate,
                            this.startCoordinate
                        ];
                        if (this.figure) {
                            this.figure.coordinates = coordinates;
                        } else {
                            this.figure = Figure.initializeRectangle(coordinates, this._illustrationOptions.style);
                        }
                        break;
                    case FigureType["Circle"]:
                        coordinates = [[this.startCoordinate, this.startCoordinate]];
                        this.figure.coordinates = coordinates;
                        break;
                    case FigureType["Polyline"]:
                    case FigureType["Polygon"]:
                        coordinates = [this.startCoordinate];
                        this.figure.coordinates = coordinates;
                        break;
                }

                if (this.figure) {
                    this.figure.needsDraw = true;
                }

            } else if (this.isPersistent === true && this.figure.isNewObject === false) {

                //TODO add better target detection for mobile devices.
                this.target = this._translateComposer.pointerStartEventPosition.target;
                var type = this.target.getAttribute("data-type");
                this.element.classList.add("contour-FigureOverlay--moving");
                this.figure.needsDraw = true;
                this.engine.draggable = false;
                switch (this.figure.type) {
                    case FigureType["Image"]:
                        if (type && type === "handle") {
                            var originPoint = this.points[0],
                                width = this.figure.cartesian.width,
                                height = this.figure.cartesian.height;

                            this.originShift = {
                                x: width - 20,
                                y: height - 20
                            };

                            this.origin = {
                                x: originPoint.x,
                                y: originPoint.y
                            };
                        }
                        break;
                    case FigureType["Rectangle"]:


                        if (type && type === "handle") {

                            var index = parseInt(this.target.getAttribute("data-identifier"), 10),
                                originIndex = (index + 2) % 4;
                            var handlePoint = this.points[index],
                                originPoint = this.points[originIndex],
                                width = Math.abs(originPoint.x - handlePoint.x),
                                height = Math.abs(originPoint.y - handlePoint.y);

                            if (index === 1 || index === 2) {
                                width = -1 * width;
                            }

                            if (index === 2 || index === 3) {
                                height = -1 * height;
                            }

                            this.originShift = {
                                x: width,
                                y: height
                            };

                            this.origin = {
                                x: this.origin.x + this.originShift.x,
                                y: this.origin.y + this.originShift.y
                            };
                        }
                        break;
                    case FigureType["Polyline"]:
                    case FigureType["Polygon"]:
                        this._translateComposer.translateX = this._translateComposer.translateY = 0;
                        this.figure.needsDraw = true;
                        this.needsDraw = true;
                        if (type && type === "handle" &&
                            (this.figure.type === FigureType["Polygon"] || this.figure.hasLabel === false)) {

                            var index = parseInt(this.target.getAttribute("data-identifier"), 10);
                            if (index % 2 === 1) {
                                var handleCoordinate = this.engine.pointToCoordinate({
                                        x: this.bounds.xMin + Number(this.target.getAttribute("cx")),
                                        y: this.bounds.yMin + Number(this.target.getAttribute("cy"))
                                    }),
                                    coordinates = this.figure.geometry.coordinates;

                                coordinates.splice(((index - 1) / 2) + 1, 0, handleCoordinate);
                                this.figure.coordinates = coordinates;
                                var point = {
                                        x: Number(this.target.getAttribute("cx")),
                                        y: Number(this.target.getAttribute("cy"))
                                    },
                                    previousHandle = this.createHandle(-1, point),
                                    nextHandle = this.createHandle(-1, point),
                                    parentNode = this.target.parentNode,
                                    i, length;
                                parentNode.insertBefore(previousHandle, this.target);
                                parentNode.insertBefore(nextHandle, this.target.nextSibling);
                                for (i = 0, length = parentNode.childNodes.length; i < length; i++) {
                                    parentNode.childNodes[i].setAttributeNS(null, "data-identifier", i);
                                }
                            }
                        }
                        break;
                }
                this.mapComponent.setSelectedFigureOverlay(this);
            }
        }
    },

    initializedEvents: {
        value: false
    },

    isMoving: {
        get: function () {
            return this._isMoving;
        },
        set: function (value) {
            this._isMoving = value;
            this.engine.draggable = ! this._isMoving;
        }
    },

    isPersistent: {
        value: false
    },

    isResizing: {
        get: function () {
            return this._isResizing;
        },
        set: function (value) {
            this._isResizing = value;
            this.engine.draggable = ! this._isResizing;
        }
    },

    isValidAreaBriefBounds: {
        value: function () {
            var isValid = true;
            if (this.maxDegreesInSelection !== -1 && this.figure && this.figure.bbox) {
                var minPoint = [this.figure.bbox[0], this.figure.bbox[1]],
                    maxPoint = [this.figure.bbox[2], this.figure.bbox[3]],
                    west  = minPoint[0],
                    south = minPoint[1],
                    east  = maxPoint[0],
                    north = maxPoint[1],
                    width,
                    height;

                switch (this.figure.type) {
                    case FigureType["Rectangle"]:
                        if (west > east) {
                            var leftSide = 180 - Math.abs(west),
                                rightSide = 180 - Math.abs(east);
                            width = leftSide + rightSide;
                        } else {
                            width = Math.abs(east - west);
                        }
                        height = Math.abs(north - south).toFixed(4);
                        break;
                    case FigureType["Circle"]:
                        width = height = north - south;
                        break;
                }

                isValid = Math.max(width, height) <= this.maxDegreesInSelection;
            }
            return isValid;
        }
    },

    isVisible: {
        writeable: true,
        value: false
    },

    mapComponent: {
        value: null
    },

    maxDegreesInSelection: {
        value: -1
    },

    needsHandles: {
        value: false
    },

    needsRemoveHandles: {
        value: false
    },

    offset: {
        value: null
    },

    origin: {
        value: null
    },

    originShift: {
        value: null
    },

    prepareForActivationEvents: {
        value: function () {
            if (this.figure) {
                switch (this.figure.type) {
                    case FigureType["Annotation"]:
                    case FigureType["Placemark"]:
                    case FigureType["Image"]:
                        if (this.figure.isNewObject) {
                            this._prepareForPressEvents();
                        } else {
                            this._prepareForTranslationEvents();
                        }
                        break;
                    case FigureType["Circle"]:
                    case FigureType["Rectangle"]:
                        this._prepareForTranslationEvents();
                        break;
                    case FigureType["Polyline"]:
                    case FigureType["Polygon"]:
                        if (this.figure.properties.isFreeHand === true || this.figure.isNewObject === false) {
                            this._prepareForTranslationEvents();
                        } else {
                            this._prepareForPressEvents();
                        }
                        break;
                }
                if (! this.figure.isNewObject) {
                    this._persist();
                }
            } else {
                this._prepareForTranslationEvents();
            }
        }
    },

    prepareForAreaSelection: {
        value: function (engine, figure, options) {
            this.clearCanvas();
            this.engine = engine;
            this.figure = figure;
            this.engine.addOverlayComponent(this);
            this._illustrationOptions = options;
        }
    },

    prepareForPointSelection: {
        value: function (engine, options) {
            this.clearCanvas();
        }
    },

    redraw: {
        value: function () {
            if (this.figure && this.isPersistent) {
                this.figure.needsDraw = true;
            }
        }
    },

    removeHandles: {
        value: function () {
            var handleGroup = this.element.querySelector("g");
            if (handleGroup) {
                this.element.removeChild(handleGroup);
                this.needsRemoveHandles = false;
            }
        }
    },

    selected: {
        get: function () {
            return this._selected;
        },
        set: function (value) {
            if (value !== this._selected) {
                this._selected = value;
                if (this._selected === true) {
                    this.needsHandles = true;
                } else {
                    this.needsRemoveHandles = true;
                }
                this.figure.needsDraw = true;
                this.needsDraw = true;
            }
        }
    },

    strokeColor: {
        value: function () {
            var strokeColor;
            if (this.element.classList.contains("contour-FigureOverlay--moving")) {
                strokeColor = "red";
            } else if (!this.isPersistent && this.maxDegreesInSelection !== -1) {
                strokeColor = this.isValidAreaBriefBounds() ? "#00FF00": "#FF0000";
            } else {
                strokeColor = this._illustrationOptions && this._illustrationOptions.style && this._illustrationOptions.style.strokeColor ?
                    this._illustrationOptions.style.strokeColor :
                    this.figure.strokeColor;
            }
            return strokeColor;
        }
    },

    target: {
        value: null
    },

    type: {
        enumerable: true,
        writeable: false,
        get: function () {
            return this._type;
        }
    },

    translationPoint: {
        value: null
    },

    updateGeometry: {
        value: function () {
            this.super();
            var bounds = this.figure.cartesian.bounds;
            this.element.style.left = (this.engineShift + bounds.xMin) + "px";
            this.element.style.top = (bounds.yMin) + "px";
        }
    },

    updateHandles: {
        value: function () {
            var group = this.element.querySelector("g");
            if (group && this.element.lastChild !== group) {
                this.element.removeChild(group);
                this.element.appendChild(group);
            }
            switch (this.figure.type) {
                case FigureType["Image"]:
                    var structure = this.element.querySelector(this.elementName),
                        handles = this.element.querySelectorAll("circle"),
                        x = parseInt(structure.getAttribute("x"), 10),
                        y = parseInt(structure.getAttribute("y"), 10),
                        width = parseInt(structure.getAttribute("width"), 10),
                        height = parseInt(structure.getAttribute("height"), 10);
                    handles[0].setAttributeNS(null, "cx", x + width);
                    handles[0].setAttributeNS(null, "cy", y + height);
                    break;

                case FigureType["Rectangle"]:

                    var structure = this.element.querySelector(this.elementName),
                        handles = this.element.querySelectorAll("circle"),
                        x = parseInt(structure.getAttribute("x"), 10),
                        y = parseInt(structure.getAttribute("y"), 10),
                        width = parseInt(structure.getAttribute("width"), 10),
                        height = parseInt(structure.getAttribute("height"), 10);

                    handles[0].setAttributeNS(null, "cx", x);
                    handles[0].setAttributeNS(null, "cy", y);
                    handles[1].setAttributeNS(null, "cx", x + width);
                    handles[1].setAttributeNS(null, "cy", y);
                    handles[2].setAttributeNS(null, "cx", x + width);
                    handles[2].setAttributeNS(null, "cy", y + height);
                    handles[3].setAttributeNS(null, "cx", x);
                    handles[3].setAttributeNS(null, "cy", y + height);
                    break;

                case FigureType["Circle"]:
                    var handle = this.element.querySelector("circle"),
                        left = parseFloat(this.element.style.left, 10),
                        top = parseFloat(this.element.style.top, 10),
                        arcPoint = this.engine.coordinateToPoint(this.figure.coordinates[0][1]);
                    handle.setAttributeNS(null, "cx", arcPoint.x - left);
                    handle.setAttributeNS(null, "cy", arcPoint.y - top);
                    break;

                case FigureType["Polygon"]:
                case FigureType["Polyline"]:
                    var structure = this.element.querySelector(this.elementName),
                        points = structure.getAttribute("points").split(" "),
                        handles = group.querySelectorAll("circle"),
                        i, length;

                    if (this.figure.type === FigureType["Polygon"] || this.figure.hasLabel === false) {
                        points = this._extendPathWithMidPoints(points);
                    }

                    for (i = 0, length = points.length; i < length; i++) {
                        var point = points[i].split(",");
                        handle = handles[i];
                        handle.setAttributeNS(null, "cx", point[0]);
                        handle.setAttributeNS(null, "cy", point[1]);
                    }
                    break;
            }
        }
    },

    willDraw: {
        value: function () {
            if (this.figure && this.figure.needsDraw) {
                switch (this.figure.type) {
                    case FigureType["Annotation"]:
                        this.calculateAnnotationGeometry();
                        break;
                    case FigureType["Placemark"]:
                        this.calculatePlacemarkGeometry();
                        break;
                    case FigureType["Image"]:
                        this.calculateImageGeometry();
                        this.addBuffer();
                        break;
                    case FigureType["Rectangle"]:
                        this.calculateRectangleGeometry();
                        this.addBuffer();
                        break;
                    case FigureType["Circle"]:
                        this.calculateCircleGeometry();
                        if (this.figure.hasLabel) {
                            this.calculateLineGeometry();
                            this.calculateLabelGeometry(this.figure.label);
                        }
                        this.addBuffer();
                        break;
                    case FigureType["Polyline"]:
                        this.calculatePathGeometry();
                        if (this.figure.hasLabel) {
                            if (this.figure.coordinates.length > 1) {
                                this.calculateDistanceLabels();
                            }
                        }
                        this.addBuffer();
                        break;
                    case FigureType["Polygon"]:
                        this.calculatePathGeometry();
                        if (this.figure.coordinates.length > 2) {
                            this.calculatePolygonCenter();
                        }
                        if (this.figure.hasLabel) {
                            this.calculateLabelGeometry(this.figure.label);
                        }
                        this.addBuffer();
                        break;

                }
            }
        }
    },

    willZoom: {
        value: function () {
            this.element.classList.add("contour-FigureOverlay--zooming");
        }
    }

}, {
    _nextFigureIndex: {
        value: 0
    },
    nextFigureIndex: {
        get: function() {
            var ret = FigureOverlay._nextFigureIndex;
            FigureOverlay._nextFigureIndex++;
            return ret;
        }
    }
});
