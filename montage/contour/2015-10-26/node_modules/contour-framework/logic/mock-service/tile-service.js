/**
 * @module logic/tile-service.js
 */
var ObjectService = require("logic/mock-montage-data/object-service").ObjectService,
    moment = require("moment-timezone"),
    ObjectStream = require("logic/mock-montage-data/object-stream").ObjectStream,
    SRID = require("logic/map/projection-utilities").SRID,
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    Layer = require("logic/mock-model/layer").Layer;

/**
 * @class TileService
 * @extends ObjectService
 *
 * Object representing a service that provides tile images. This
 * placeholder version just works with open street maps tiles.
 */
var TileService = exports.TileService = ObjectService.specialize(/** @lends TileService.prototype */ {

    constructor: {
        value: function TileService() {
            this.super("tileService");
        }
    },

    _tileCache: {
        value: {}
    },

    _tileInLayerCache: {
        value: function (layer, tileId) {
            var image;
            if (this._tileCache[layer.id]) {
                if (this._tileCache[layer.id][tileId]) {
                    image = this._tileCache[layer.id][tileId].image;
                }
            } else {
                this._tileCache[layer.id] = {};
            }
            return image;
        }
    },

    query: {

        value: function (selector) {

            var tileId = selector.tileId,
                layer = selector.layer,
                image = this._tileInLayerCache(layer, tileId),
                stream = new ObjectStream(selector);

            if (image) {
                setTimeout(function() {
                    var imageObject = {
                        id: tileId,
                        image: image
                    };
                    stream.add([imageObject]);
                    stream.resolve([imageObject]);
                }, 0);
            } else {
                var tile = selector.tileId.split(":");
                image = new Image();
                image.src = TileService.generateTileRequest(layer, tile);
                image.onload = this._onLoad.bind(this, layer, selector.tileId, image, stream);
            }

            return stream;

        }

    },

    _onLoad: {
        value: function (layer, tileId, image, stream) {
            var imageObject = {id: tileId, image: image};
            this._tileCache[layer.id][tileId] = {
                fetchTime: new Date(),
                image: imageObject.image
            };
            stream.add([imageObject]);
            stream.resolve([imageObject]);
        }
    },

    _normalizedCoord: {

        value: function (coord, zoom) {

            var y = coord.y;
            var x = coord.x;

            // tile range in one direction range is dependent on zoom level
            // 0 = 1 tile, 1 = 2 tiles, 2 = 4 tiles, 3 = 8 tiles, etc
            var tileRange = 1 << zoom;

            // don't repeat across y-axis (vertically)
            if (y < 0 || y >= tileRange) {
                return null;
            }

            // repeat across x-axis
            if (x < 0 || x >= tileRange) {
                x = (x % tileRange + tileRange) % tileRange;
            }

            return {
                x: x,
                y: y
            };
        }

    }

}, {

    generateTileRequest: {
        value: function (layer, tile) {

            var url;
            switch (layer.protocol) {

                case Layer.Protocol.OSM:

                    url = layer.url;
                    url += tile[2] + "/" + tile[0] + "/" + tile[1] + ".png";
                    break;

                case Layer.Protocol.WMS:

                    var extent = ProjectionUtilities.extentForTile(tile),
                        projectedExtent = ProjectionUtilities.bbox(extent, layer.projection, layer.units),
                        bbox = [projectedExtent.xmin, projectedExtent.ymin, projectedExtent.xmax, projectedExtent.ymax].join(",");

                    url = layer.url;
                    if (layer.mapService) {
                        url += layer.mapService;
                    }
                    url += "LAYERS=";
                    url += layer.id;
                    url += "&WIDTH=256";
                    url += "&HEIGHT=256";
                    url += "&format=";
                    // TODO is this configurable?
                    // url += this.imageFormat;
                    url += "image/png";
                    url += "&bboxSR=";
                    url += SRID[layer.projection];
                    url += "&CRS=EPSG:";
                    url += SRID[layer.projection];
                    url += "&SRS=EPSG:";
                    url += SRID[layer.projection];
                    url += "&version=";
                    url += layer.version;
                    url += "&BBOX=";
                    url += bbox;
                    url += "&service=WMS";
                    url += "&TRANSPARENT=TRUE";
                    url += "&request=GetMap";
                    url += "&STYLES=";
                    if (tile[3]) {
                        url += "&TIME=";
                        url += moment.unix(tile[3]).utc().format("YYYY-MM-DDTHH:mm:ss");
                        url += ".000Z";
                    }
                    url;
                    break;

                case Layer.Protocol.AGS:

                    var extent = ProjectionUtilities.extentForTile(tile),
                        projectedExtent = ProjectionUtilities.bbox(extent, layer.projection, layer.units),
                        bbox = [projectedExtent.xmin, projectedExtent.ymin, projectedExtent.xmax, projectedExtent.ymax].join(",");

                    url = layer.url;
                    url += "/export";
                    url += "?format=png";
                    url += "&bboxSR=";
                    url += SRID[layer.projection];
                    url += "&SRS=EPSG:";
                    url += SRID[layer.projection];
                    url += "&version=";
                    url += layer.version;
                    url += "&BBOX=";
                    url += bbox;
                    url += "&layers=show:";
                    url += layer.mapServiceLayerId;
                    url += "&size=256,256";
                    url += "&transparent=true";
                    url += "&f=image";
                    url += "&dpi=96";
                    url += "&imageSR=102100";
                    break;

                case Layer.Protocol.WMTS:
                    url = layer.url;
                    url += "service=WMTS&";
                    url += "version=1.0.0&";
                    url += "request=gettile&";
                    url += "format=image/png&";
                    url += "tileMatrix=" + tile[2] + "&";
                    url += "TileRow=" + tile[1] + "&";
                    url += "TileCol=" + tile[0] + "&";
                    url += "style=default&tileMatrixSet=default028mm";
                    break;
            }

            return url;
        }
    }

});
