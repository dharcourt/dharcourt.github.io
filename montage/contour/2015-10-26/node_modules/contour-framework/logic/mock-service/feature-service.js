/**
 * @module logic/feature-service.js
 */
var ObjectService = require("logic/mock-montage-data/object-service").ObjectService,
    ObjectStream = require("logic/mock-montage-data/object-stream").ObjectStream,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    SRID = require("logic/map/projection-utilities").SRID,
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    ClassBreaksRenderer = require("logic/map/class-breaks-renderer").ClassBreaksRenderer,
    SimpleRenderer = require("logic/map/simple-renderer").SimpleRenderer,
    UniqueValueRenderer = require("logic/map/unique-value-renderer").UniqueValueRenderer,
    Feature = require("logic/mock-model/feature").Feature,
    EsriGeometryType = require("logic/map/esri-geometry-type").EsriGeometryType;

/**
 * @class FeatureService
 * @extends ObjectService
 *
 * Object representing a service that provides feature data from an ArcGIS REST
 * Service. This placeholder version just works with historical earthquake data.
 */
var FeatureService = exports.FeatureService = ObjectService.specialize(/** @lends FeatureService.prototype */ {

    constructor: {
        value: function FeatureService() {
            this.super("featureService");
        }
    },

    query: {

        value: function (selector) {

            if (selector.layer && selector.extent) {

                var stream = new ObjectStream(selector);

                if (selector.layer.configured === true) {
                    this._fetchFeatures(selector, stream);
                } else {
                    this._configure(selector, stream);
                }

                return stream;
            }
        }
    },

    _configure: {
        value: function (selector, stream) {

            var request = new XMLHttpRequest(),
                self = this;

            request.onload = function() {

                if (selector.layer.configured === false) {

                    var layerConfiguration = JSON.parse(this.responseText);

                    selector.layer.geometryType = EsriGeometryType[layerConfiguration.geometryType];
                    selector.layer.renderer = FeatureService.initializeRendererFromConfiguration(
                        layerConfiguration.drawingInfo.renderer, selector.layer.geometryType);

                    // truthy because 0 is returned by the service as do not configure.
                    if (layerConfiguration.minScale) {
                        selector.layer.minScale = GeometryUtilities.zoomLevelForScale(layerConfiguration.minScale);
                    }

                    if (layerConfiguration.maxScale) {
                        selector.layer.maxScale = GeometryUtilities.zoomLevelForScale(layerConfiguration.maxScale);
                    }

                    selector.layer.configured = true;
                }
                self._fetchFeatures(selector, stream);
            };
            request.withCredentials = true;
            request.open("get", selector.layer.url + "/" + selector.layer.mapServiceLayerId + "?f=json");
            request.send();
        }
    },

    _fetchFeatures: {
        value: function (selector, stream) {

            var layer = selector.layer,
                extent = selector.extent,
                projection = selector.projection,
                units = selector.units,
                request = new XMLHttpRequest();

            request.withCredentials = true;
            request.onload = this._onLoad.bind(this, request, stream, layer, projection, units);
            request.open("get", this._url(layer, extent, projection, units), true);
            request.send();
        }
    },

    _onLoad: {
        value: function (request, stream, layer, projection, units) {
            var data = JSON.parse(request.responseText).features,
                feature,
                features = [],
                i, n;

            if (data) {

                for (i = 0, n = data.length; i < n; i++) {

                    var featureData = data[i];
                    featureId = featureData.attributes.OBJECTID || featureData.attributes.objectid;

                    var cachedFeature = layer.features[featureId];
                    if (cachedFeature === undefined) {

                        feature = Feature.initializeFeature(layer, featureData);
                        layer.features[feature.id] = feature;
                    } else {
                        feature = cachedFeature;
                    }

                    features.push(feature);
                    stream.add([feature]);
                }

                stream.resolve(features);
            }
        }
    },

    _url: {

        value: function (layer, extent, projection, units) {

            var url,
                bbox = ProjectionUtilities.bbox(extent, projection, units);

            url = layer.url;
            url += "/";
            url += layer.mapServiceLayerId;
            url += "/query?f=json&geometryType=esriGeometryEnvelope&returnGeometry=true&outSR=";
            url += SRID[projection];
            url += "&geometry=";
            url += "{";

            for (var key in bbox) {
                url += key;
                url += ":";
                url += bbox[key]
                url += ",";
            }

            url += "spatialReference:{wkid:";
            url += projection;
            url += "}}";
            url += "&outFields=*";

            return url;

        }
    }

}, {

    initializeRendererFromConfiguration: {
        value: function (configuration, geometryType) {
            var renderer;
            switch (configuration.type) {
                case "classBreaks":
                    renderer = new ClassBreaksRenderer(
                        configuration.field,
                        configuration.minValue,
                        configuration.classBreakInfos,
                        configuration.transparency
                    );
                    break;
                case "simple":
                    renderer = new SimpleRenderer(configuration.symbol);
                    break;
                case "uniqueValue":
                    renderer = new UniqueValueRenderer(
                        configuration.field1,
                        configuration.field2,
                        configuration.field3,
                        configuration.fieldDelimeter,
                        configuration.uniqueValueInfos,
                        configuration.defaultSymbol
                    );
                    break;
            }
            renderer.geometryType = geometryType;
            return renderer;
        }
    }

});
