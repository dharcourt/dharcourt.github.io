/**
 * @module logic/location-service.js
 */
var ObjectService = require("logic/mock-montage-data/object-service").ObjectService,
    ObjectStream = require("logic/mock-montage-data/object-stream").ObjectStream,
    Location = require("logic/model/location").Location,
    LocationSelector = require("logic/mock-service/location-selector").LocationSelector;


/**
 * @class LocationService
 * @extends ObjectService
 *
 * Object representing a service that provides feature data from PDC's Location
 * Service. This is a mock service used for testing purposes.
 */
var LocationService = exports.LocationService = ObjectService.specialize(/** @lends LocationService.prototype */ {

    constructor: {
        value: function LocationService() {
            this.super("locationService");
        }
    },
    _cache: {
        value: {}
    },
    _prepareGoogleServices: {
        value: function() {
            this._googleServices.autocomplete = new google.maps.places.AutocompleteService();
            this._googleServices.details = new google.maps.places.PlacesService(document.createElement("div"));
            this._googleServices.status = google.maps.places.PlacesServiceStatus;
        }
    },
    _googleServices: {
        value: {
            autocomplete:null,
            details:null,
            status:null
        }
    },
    query: {
        value: function (selector) {
            var stream = new ObjectStream(selector);
            if (this._googleServices.autocomplete) {
                this._fetchLocations(stream, selector.searchText);
            } else if (google) {
                this._prepareGoogleServices();
                this._fetchLocations(stream, selector.searchText);
            } else  {
                var googleScript = document.createElement("script"),
                    self = this;
                googleScript.type = "text\/javascript";
                googleScript.onload = function() {
                    self._prepareGoogleServices();
                    self._fetchLocations(stream, selector.searchText);
                };
                googleScript.src = "http://maps.googleapis.com/maps/api/js?sensor=false&callback=initialize&libraries=places";
            }
            return stream;
        }
    },
    _fetchLocations: {
        value: function(stream, searchText) {
            var service = this;
            this._googleServices.autocomplete.getPlacePredictions({input: searchText, types:['geocode']}, function (results, status) {
                if (status === service._googleServices.status.OK) {
                    var i, n, location, locations = [];
                    for (i = 0, n = results.length; i < n; i ++) {
                        location = service._prepareLocation(results[i]);
                        locations.push(location);
                        stream.add(location);
                    }

                    stream.resolve(locations);
                } else {
                    stream.resolve([]);
                }
            });
        }
    },
    _prepareLocation: {
        value: function (data) {
            var location, service = this;
            if (this._cache[data.place_id]) {
                location = this._cache[data.place_id];
            } else {
                location = Location.initialize(data);
                service._cache[location.placeId] = location;
                Object.defineProperty(location, "coordinates", {
                    get: function() {
                        var stream, self = this;
                        if (this._coordinates) {
                            stream = new ObjectStream(new LocationSelector());
                            setTimeout(function() {
                                stream.add(self._coordinates);
                                stream.resolve([self._coordinates]);
                            },0);
                        } else if (this._coordinateStream) {
                            stream = this._coordinateStream;
                        } else {
                            stream = this._coordinateStream = new ObjectStream(new LocationSelector());
                            service.getCoordinatesForLocation(this, stream);
                        }
                        return stream;
                    }
                });

            }
            return location;
        }
    },
    _coordinateRequestQueue: {
        value: []
    },
    _queuedRequests: {
        value: {}
    },
    getCoordinatesForLocation: {
        value: function(location, stream) {
            if (!this._queuedRequests.hasOwnProperty(location.placeId)) {
                this._coordinateRequestQueue.push({location:location, stream: stream});
                this._queuedRequests[location.placeId] = location;
                if (!this._processing) {
                    this._processQueue();
                }
            }
        }
    },
    _getCoordinatesForLocation: {
        value: function(location, stream, callback) {
            var service = this;
            this._googleServices.details.getDetails({
                placeId: location.placeId
            }, function (result,status) {
                if (status === service._googleServices.status.OVER_QUERY_LIMIT) {
                    setTimeout(function() {
                        service._getCoordinatesForLocation(location, stream, callback);
                    }, 1000);
                } else {
                    var coordinates = [];
                    if (status === service._googleServices.status.OK) {
                        var placeGeometry = result.geometry.location;
                        coordinates = location._coordinates = [placeGeometry.lng(), placeGeometry.lat()];
                        stream.add(coordinates);
                    }
                    stream.resolve([coordinates]);
                    callback();
                }
            })
        }
    },
    _processQueue: {
        value: function() {
            var nextRequest = this._coordinateRequestQueue[0], self = this;
            this._processing = true;
            this._getCoordinatesForLocation(nextRequest.location,nextRequest.stream,function() {
                delete self._queuedRequests[self._coordinateRequestQueue[0].location.placeId];
                self._coordinateRequestQueue.shift();
                if (self._coordinateRequestQueue.length > 0) {
                    setTimeout(function() {
                        self._processQueue();
                    },100);
                } else {
                    self._processing = false;
                }
            });
        }
    }
});
