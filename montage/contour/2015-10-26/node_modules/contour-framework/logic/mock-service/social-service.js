/**
 * @module logic/social-service.js
 */
var ObjectService = require("logic/mock-montage-data/object-service").ObjectService;
var ObjectStream = require("logic/mock-montage-data/object-stream").ObjectStream;
var Tweet = require("logic/model/tweet").Tweet;
var SocialSelector = require("logic/mock-service/social-selector").SocialSelector;

/**
 * @class SocialService
 * @extends ObjectService
 *
 */
var SocialService = exports.SocialService = ObjectService.specialize(/** @lends ProductService.prototype */ {

    constructor: {
        value: function socialService() {
            this.super("socialService");
        }
    },

    _cache: {
        value: {}
    },

    _keywords: {
        value: []
    },

    query: {
        value: function (selector) {
            var stream = new ObjectStream(selector);
                if (!selector.bounds) {
                    var self = this;
                    setTimeout(function () {
                        stream.add(self._keywords);
                        stream.resolve(self._keywords);
                    }, 0);

                } else {
                    var request = new XMLHttpRequest(),
                        url = "http://servicestest.pdc.org/socialng",
                        xmax = selector.bounds.east,
                        xmin = selector.bounds.west,
                        ymax = selector.bounds.north,
                        ymin = selector.bounds.south,
                        queryString = "?xmax=" + xmax + "&xmin=" + xmin + "&ymax=" + ymax + "&ymin=" + ymin + "&type=" + selector.mediaType;


                    //if (selector.getKeywords && false) {
                    //    request.onload = this._onLoadKeywords.bind(this, request, stream, selector);
                    //    url +="/popular-keywords";
                    //} else {
                        request.onload = this._onLoad.bind(this, request, stream, selector);
                        queryString += "&limit=";
                        queryString += selector.limit;
                        url +="/twitter-batches";
                    //}

                    if (selector.keyword) {
                        queryString += "&keywords=";
                        queryString += selector.keyword;
                    }

                    request.open("get", url + queryString);
                    request.withCredentials = true;
                    request.send();
                }



            return stream;
        }
    },

    _onLoad: {
        value: function (request, stream, selector) {

            var data = JSON.parse(request.responseText),
                results = [],
                tweet, rawObject;
            if (selector.cacheKeywords) {
                this._keywords = this._parseKeywords(data.topKeywords);
            }
            for (var i = 0; i < data.points.length; i++) {
                rawObject = data.points[i];
                if (this._cache[rawObject.sys_id] === undefined) {
                    tweet = Tweet.initialize(data.points[i]);
                    tweet.layer = selector.layer;
                    this._cache[rawObject.sys_id] = tweet;
                } else {
                    tweet = this._cache[rawObject.sys_id];
                }
                results.push(tweet);
            }

            var resultData = {};
            resultData.results = results;
            if (selector.getKeywords) {
                resultData.keywords = this._parseKeywords(data.topKeywords);
            }
            stream.add(resultData);
            stream.resolve(resultData);
        }
    },

    _onLoadKeywords: {
        value: function (request, stream, selector) {
            var data = JSON.parse(request.responseText),
            results = this._parseKeywords(data);
            stream.add(results);
            stream.resolve(results);
        }
    },

    _parseKeywords: {
        value: function (array) {
            var i, length, keywords = [], keyword;
            for (i = 0, length = array.length; i < length; i++) {
                keyword = {
                    value: array[i].keyword,
                    weight: array[i].qty
                };
                keywords.push(keyword);
            }
            return keywords;
        }
    }
});
