var Montage = require("montage").Montage,
    application = require("montage/core/application").application,
    moment = require("moment-timezone"),
    CameraIconRenderer = require("logic/map/camera-icon-renderer").CameraIconRenderer,
    Enum = require("montage/core/enum").Enum,
    EsriGeometryType = require("logic/map/esri-geometry-type").EsriGeometryType,
    ImportRenderer = require("logic/map/import-renderer").ImportRenderer,
    ProductRenderer = require("logic/map/product-renderer").ProductRenderer,
    Projections = require("logic/map/projection-utilities").Projections,
    SocialSelector = require("logic/mock-service/social-selector").SocialSelector,
    SocialService = require("logic/mock-service/social-service").SocialService,
    Units = require("logic/map/projection-utilities").Units;

/**
 * A layer of features, corresponding to layers displayed on the map.
 * The functionality of this object will eventually be moved to other classes,
 * most notably /logic/model/layer.js.
 *
 * @class Layer
 * @extends external:Montage
 */
var Layer = exports.Layer = Montage.specialize(/** @lends Layer# */ {

    constructor: {
        // TODO [Charles]: Remove constructor in favor of setting properties
        // independently. Properties should ultimately be set in Montage Data
        // anyways.
        value: function Layer(id, url, depth) {
            this.id = id;
            this.url = url;
            this.depth = depth;
        }
    },

    _allFeatures: {
        value: undefined
    },

    _bounds: {
        value: null
    },

    _keyword: {
        value: null
    },

    _mediaType: {
        value: null
    },

    _parseResponse: {
        value: function (response) {
            switch (this.protocol) {
                case Layer.Protocol.SocialNG:
                    //this.features.splice.apply(this.features, [0, this.features.length].concat(response.results));
                    this.features = response.results;
                    break;
            }
        }
    },

    _requestFeatures: {
        value: function () {
            if (this._selector) {
                application.mockService.query(this._selector)
                    .then(this._parseResponse.bind(this));
            }
        }
    },

    __selector: {
        value: null
    },

    _selector: {
        enumerable: false,
        writeable: false,
        get: function () {
            if (this.__selector === null && this.enabled) {
                switch (this.protocol) {
                    case Layer.Protocol.SocialNG:
                        this.__selector = new SocialSelector(this, this.bounds, this.mediaType);
                        break;
                }
            }
            return this.__selector;
        }
    },

    /**
     * @private
     */
    _symbols: {
        value: null
    },

    allFeatures: {
        get: function () {
            if (this._allFeatures === undefined) {
                this._allFeatures = [];
            }
            return this._allFeatures;
        }
    },

    availableTimes: {
        value: null
    },

    bounds: {
        get: function () {
            return this._bounds;
        },
        set: function (value) {
            if (value && value !== this._bounds) {
                this._bounds = value;
                if (this._selector) {
                    this._selector.bounds = value;
                    this._requestFeatures();
                }
            }
        }
    },

    features: {
        value: undefined
    },

    isVisibleAtZoom: {
        value: function (zoomLevel) {
            var visible = true;

            if (this.minScale && this.minScale >= zoomLevel) {
                visible = false;
            }

            if (visible && this.maxScale && this.maxScale <= zoomLevel) {
                visible = false;
            }
            return visible;
        }
    },

    keyword: {
        get: function () {
            return this._keyword;
        },
        set: function (value) {
            if (value !== this._keyword) {
                this._keyword = value;
                if (this._selector) {
                    this._selector.keyword = value;
                    this._requestFeatures();
                }
            }
        }
    },

    mediaType: {
        get: function () {
            return this._mediaType;
        },
        set: function (value) {
            if (value && value !== this._mediaType) {
                this._mediaType = value;
                if (this._selector) {
                    this._selector.mediaType = value;
                    this._requestFeatures();
                }
            }
        }
    },

    searchTerms: {
        value: {
            // TODO [Charles]: Cache this, making sure to clear the cache when
            // base data is changed.
            // TODO [Charles]: Investigate whether the presumably non-user
            // visible "id" property should be included in the search terms.
            get: function() {
                var strings = [this.id, this.name, this.description],
                    terms = {},
                    string, split, i, j, n, m;
                for (i = 0, n = strings.length; i < n; ++i) {
                    string = strings[i] && strings[i].replace(/[\W_]+/g, " ").trim().toLowerCase();
                    split = string && string.split(" ");
                    for (j = 0, m = split ? split.length : 0; j < m; ++j) {
                        terms[split[j]] = this;
                    }
                }
                return terms;
            }
        }
    },

    /**
     * A dictionary for storing the symbols the engine creates to represent a feature.
     */
    symbols: {
        enumerable: true,
        writeable: false,
        get: function () {
            if (this._symbols === null) {
                this._symbols = {};
            }
            return this._symbols;
        }
    },

    // Shim to match the new (post-mock) API.

    enabled: {
        get: function () {
            return this._enabled || false;
        },
        set: function (enabled) {
            if (enabled != this.enabled) {
                this._enabled = enabled ? true : false;
                this.isEnabled = enabled;
            }
        }
    },

    isEnabled: {
        get: function () {
            return this._isEnabled || false;
        },
        set: function (enabled) {
            if (enabled != this.isEnabled) {
                this._isEnabled = enabled ? true : false;
                this.enabled = enabled;
            }
        }
    },

    name: {
        get: function () {
            return this._name || this.title;
        },
        set: function (name) {
            this._name = name;
        }
    },

    featureFields: {
        get: function () {
            var self = this;
            if (!this._featureFields) {
                this._featureFields = Object.create({}, {
                    all: {
                        get: function () { return self.allFields; }
                    },
                    summary: {
                        get: function () { return self.basicFields; }
                    }
                });
            }
            return this._featureFields;
        }
    }

}, {

    _uniqueId: {
        value: 0
    },

    initializeCameraLayer: {
        value: function (id, url, depth) {
            var layer = new Layer(id, url, depth);
            layer.type = "feature";
            layer.protocol = Layer.Protocol.Camera;
            layer.features = [];
            layer.clustered = true;
            layer.renderer = new CameraIconRenderer();
            return layer;
        }
    },

    initializeSocialLayer: {
        value: function (id, url, depth) {
            var layer = new Layer(id, url, depth);
            layer.type = "heatMap";
            layer.protocol = Layer.Protocol.SocialNG;
            layer.features = [];
            layer.mediaType = "text";
            return layer;
        }
    },

    initializeOSMLayer: {
        value: function (id, url, depth) {
            var layer = new Layer(id, url, depth);
            layer.type = "tile";
            layer.protocol = Layer.Protocol.OSM;
            return layer;
        }
    },

    initializeWMTSTileLayer: {
        value: function (id, url, depth) {
            var layer = new Layer(id, url, depth);
            layer.type = "tile";
            layer.protocol = Layer.Protocol.WMTS;
            return layer;
        }
    },

    initializeWMSTileLayer: {
        value: function (id, url, depth, projection, units, version, timeHelperUrl) {
            var layer = new Layer(id, url, depth);
            layer.type = "tile";
            layer.protocol = Layer.Protocol.WMS;
            layer.projection = Projections[projection];
            layer.units = Units[units];
            layer.version = version;
            if (timeHelperUrl) {
                layer.availableTimes = [];
                var request = new XMLHttpRequest();
                request.withCredentials = true;
                request.onload = function() {

                    var responseText = request.responseText,
                        dataString = responseText.substring(responseText.indexOf("{"), responseText.lastIndexOf(")")),
                        data = JSON.parse(dataString).data,
                        moments = [], i, length;

                    if (data && data.availableTimes) {
                        for (i = 0, length = data.availableTimes.length; i < length; i++) {
                            moments.push(new moment(data.availableTimes[i]));
                        }
                        layer.availableTimes = moments;
                    }
                };
                request.open("get", timeHelperUrl, true);
                request.send();

            }
            return layer;
        }
    },

    initializePDCHazardPointLayer: {
        value: function(id, url, depth) {
            var layer = new Layer(id, url, depth);
            layer.geometryType = EsriGeometryType["esriGeometryPoint"];
            layer.name = "Mock PDC Active Hazards";
            layer.protocol = Layer.Protocol.PDCHP;
            layer.requestGlobalFeatures = true;
            layer.type = "feature";
            layer.features = {};
            layer.fields = [
                {
                    propertyName: "name",
                    alias: "Name",
                    type: "string",
                    formattedValue: function(value) {
                        return value;
                    }
                },
                {
                    propertyName: "creationDate",
                    alias: "Create Date",
                    type: "date",
                    formattedValue: function(value) {
                        return value.format("M.DD.YYYY H\\h:mm\\m");
                    }
                },
                {
                    propertyName: "typeId",
                    alias: "Type",
                    type: "string",
                    formattedValue: function(value) {
                        return value;
                    }
                },
                {
                    propertyName: "categoryId",
                    alias: "Category",
                    type: "string",
                    formattedValue: function(value) {
                        return value;
                    }
                }
            ];
            return layer;
        }
    },

    initializeSocialPointLayer: {
        value: function (id, url, depth) {
            var layer = new Layer(id, url, depth);
            layer.type = "heatMap";
            layer.name = "Social Point Layer";
            layer.protocol = Layer.Protocol.SocialNG;
            return layer;
        }
    },

    initializeAGSLayer: {
        value: function (id, url, depth, type, mapServiceLayerId, projection, units) {
            var layer = new Layer(id, url, depth);
            layer.configured = false;
            layer.type = type;
            layer.protocol = Layer.Protocol.AGS;
            layer.mapServiceLayerId = mapServiceLayerId;
            layer.projection = Projections[projection];
            layer.units = Units[units];
            layer.requestGlobalFeatures = false;
            layer.features = {};
            return layer;
        }
    },

    initializeImportLayer: {
        /**
         * Initialize import layer
         * @param {string} name laeyr name
         * @param {*} data import data
         * @param {string} type import data type
         * @return {Layer} Initialized imported layer
         */
        value: function ( name, data, type ) {
            var layer = new Layer(Layer._uniqueId++);
            layer.name = name;
            layer.enabled = true;
            layer.data = data;
            layer.dataType = type;
            layer.type = "import";
            layer.depth = 1;
            layer.renderer = new ImportRenderer();
            layer.protocol = Layer.Protocol.Import;
            return layer;
        }
    },

    initializeProductsLayer: {
        value: function ( ) {
            var layer = new Layer(Layer._uniqueId++);
            layer.type = "product";
            layer.depth = 10;
            layer.enabled = true;
            layer.renderer = new ProductRenderer();
            layer.protocol = Layer.Protocol.Product;
            layer.data = [];
            return layer;
        }
    },

    Protocol: {
        value: new Enum().initWithMembers("AGS", "OSM", "PDCHP", "WMS", "WMTS", "SocialNG", "Camera", "Import", "Product")
    }

});
