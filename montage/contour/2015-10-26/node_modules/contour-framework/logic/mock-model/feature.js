var Montage = require("montage").Montage,
    EsriGeometryType = require("logic/map/esri-geometry-type").EsriGeometryType,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    Units = require("logic/map/projection-utilities").Units,
    moment = require("moment-timezone");

/**
 * @class Feature
 * @extends Montage
 *
 * Object representing a feature. This may or may not be a placeholder (TBD).
 *
 */
var Feature = exports.Feature = Montage.specialize(/** @lends Feature.prototype */ {

    getCenter: {
        value: function () {
            var center;
            switch (this.geometry.type) {
                case "Point":
                    center = this.geometry.coordinates;
                    break;
                case "MultiPoint":
                    center = GeometryUtilities.getCenter(this.geometry.coordinates[0]);
                    break;
                case "MultiLineString":
                case "MultiPolygon":
                    center = GeometryUtilities.getCenter(this.geometry.coordinates[0]);
                    break;
            }
            return center;
        }
    }

}, {

    initializeFeature: {

        value: function (layer, featureData) {

            var feature = {
                type: "Feature"
            };
            //feature.geometryType = layer.geometryType;
            //feature.overlayId = layer.id;
            feature.id = featureData.attributes.OBJECTID || featureData.attributes.objectid;
            feature.properties = featureData.attributes;
            feature.properties.layerId = layer.id;
            feature.layer = layer;
            //feature.geometry = featureData.geometry;
            //feature.style = layer.renderer.render(feature.attributes);

            // Want to return geographic coordinates to the map engine.
            //if (layer.units === Units["meters"]) {
            // Point feature.
            switch (layer.geometryType) {

                case EsriGeometryType["esriGeometryPoint"]:
                    feature.geometry = {
                        "type": "Point"
                    };
                    if (layer.units === Units["meters"]) {
                        feature.geometry.coordinates = ProjectionUtilities.inverse(layer.projection,
                            [featureData.geometry.x, featureData.geometry.y]);
                    } else {
                        feature.geometry.coordinates = [featureData.geometry.x, featureData.geometry.y];
                    }
                    feature.properties.point = feature.geometry.coordinates;
                    break;

                case EsriGeometryType["esriGeometryMultipoint"]:

                    var points = featureData.geometry.points;
                    feature.geometry = {
                        coordinates: [],
                        "type": "MultiPoint"
                    };

                    for (var j = 0; j < points.length; j++) {
                        var point = points[j];
                        if (layer.units === Units["meters"]) {
                            feature.geometry.coordinates.push(ProjectionUtilities.inverse(layer.projection, point));
                        } else {
                            feature.geometry.coordinates.push(point);
                        }
                    }
                    feature.properties.point = feature.geometry.coordinates[0];
                    break;

                case EsriGeometryType["esriGeometryPolyline"]:

                    var paths = featureData.geometry.paths;
                    feature.geometry = {
                        coordinates: [],
                        type: "MultiLineString"
                    };

                    for (var j = 0, jlength = paths.length; j < jlength; j++) {
                        var path = [];
                        for (var k = 0, kLength = paths[j].length; k < kLength; k++) {
                            if (layer.units === Units["meters"]) {
                                path.push(ProjectionUtilities.inverse(layer.projection, [paths[j][k][0], paths[j][k][1]]));
                            } else {
                                path.push(paths[j][k]);
                            }
                        }
                        feature.geometry.coordinates.push(path);
                    }
                    feature.properties.advisory_date && (feature.properties.advisory_date = new moment(new Date(feature.properties.advisory_date)));

                    Object.defineProperty(feature,"searchTerms",{
                        writeable:false,
                        get: function() {
                            if (!this._searchTerms) {
                                var fields = layer.fields,
                                    terms = {},
                                    string, field, split, i, j, n, m;
                                for (i = 0, n = fields.length; i < n; ++i) {
                                    field = fields[i];
                                    if (field.type === "string" && this.properties[field.propertyName]) {
                                        string = this.properties[field.propertyName] && this.properties[field.propertyName].replace(/[\W_]+/g, " ").trim().toLowerCase();
                                        split = string && string.split(" ");
                                        for (j = 0, m = split ? split.length : 0; j < m; ++j) {
                                            terms[split[j]] = this;
                                        }
                                    }

                                }
                                this._searchTerms = terms;
                            }
                            return this._searchTerms;
                        }
                    });

                    break;

                case EsriGeometryType["esriGeometryPolygon"]:

                    var rings = featureData.geometry.rings;
                    feature.geometry = {
                        coordinates: [],
                        type: "MultiPolygon"
                    };

                    for (var j = 0, jlength = rings.length; j < jlength; j++) {
                        var ring = [];
                        for (var k = 0, kLength = rings[j].length; k < kLength; k++) {
                            if (layer.units === Units["meters"]) {
                                ring.push(ProjectionUtilities.inverse(layer.projection, [rings[j][k][0], rings[j][k][1]]));
                            } else {
                                ring.push(rings[j][k]);
                            }
                        }
                        feature.geometry.coordinates.push(ring);
                    }

                    break;
            }

            //} else if (layer.units === Units["decimal degrees"]) {
            //switch (feature.geometryType) {
            //    case EsriGeometryType["esriGeometryPoint"]:
            //        feature.point = feature.geometry;
            //        break;
            //    case EsriGeometryType["esriGeometryMultipoint"]:
            //        feature.point = feature.geometry.points[0];
            //        break;
            //}
            //}

            return feature;

        }

    }

});
