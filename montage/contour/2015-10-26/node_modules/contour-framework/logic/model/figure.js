/**
 * @module logic/figure.js
 */
var Feature = require("logic/mock-model/feature").Feature,
    Enum = require("montage/core/enum").Enum,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    Uuid = require("montage/core/uuid").Uuid,
    Renderer = require("logic/map/renderer").Renderer;


var FigureType = exports.FigureType = new Enum().initWithMembers(
    "Annotation", "Circle", "Image", "Placemark", "Polygon", "Polyline", "Rectangle"
);

var SupportedImageMimeTypes = ["image/png","image/jpeg","image/gif"]

/**
 * @class Figure
 * @extends Feature
 *
 * An object representing a figure drawn on to the map by the user.
 *
 */
var Figure = exports.Figure = Feature.specialize(/** @lends Figure.prototype */ {

    constructor: {
        value: function Figure() {
            this.id = Uuid.generate();
            this.type = "Feature";
        }
    },

    _id: {
        value: null
    },

    _formattedNumber: {
        value: function (x) {
            x = x.toFixed(3);
            var parts = x.toString().split(".");
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            return parts.join(".");
        }
    },

    _properties: {
        value: null
    },

    _propertyChanged: {
        value: function (property) {
            switch (property) {
                case 'coordinates':
                case 'dataURL':
                case 'displayLabelBorder':
                case 'displayDistanceTotal':
                case 'fillColor':
                case 'fillOpacity':
                case 'fillStyle':
                case 'fontColor':
                case 'fontSize':
                case 'hasLabel':
                case 'imageOpacity':
                case 'labelStrokeColor':
                case 'labelStrokeOpacity':
                case 'labelStrokeWidth':
                case 'labelType':
                case 'mapTip':
                case 'name':
                case 'needsDraw':
                case 'radius':
                case 'strokeColor':
                case 'strokeOpacity':
                case 'strokeWidth':
                case 'textCharacter':
                case 'units':
                case 'zIndex':
                    for (var i = 0, length = this.components.length; i < length; i++) {
                        this.components[i].needsDraw = true;
                    }
                    break;
            }
        }
    },

    addComponent: {
        value: function (component) {
            var index = this.components.indexOf(component);
            if (index === -1) {
                this.components.push(component);
            }
        }
    },

    addCoordinate: {
        value: function (coordinate) {
            this.geometry.coordinates.push(coordinate);
            this._propertyChanged("coordinates");
        }
    },

    aspectRatio: {
        get: function () {
            return this.properties["aspectRatio"];
        },
        set: function (value) {
            this.properties["aspectRatio"] = value;
        }
    },

    bearing: {
        get: function () {
            return this.properties["bearing"];
        },
        set: function (value) {
            this.properties["bearing"] = value;
        }
    },

    bbox: {
        value: null
    },

    cartesian: {
        get: function () {
            return this.properties["cartesian"];
        },
        set: function (value) {
            this.properties["cartesian"] = value;
        }
    },

    center: {
        get: function () {
            return this.getCenter();
        },
        set: function (value) {
            switch (this.properties.type) {
                case FigureType["Circle"]:
                    this.coordinates[0][0] = value;
                    this.coordinates[0][1] = GeometryUtilities.vincentyDirect(value, null, this.radius, this.bearing).point;
                    break;
            }
        }
    },

    component: {
        value: null
    },

    components: {
        value: []
    },

    coordinates: {
        get: function () {
            return this.geometry.coordinates;
        },
        set: function (value) {
            this.geometry.coordinates = value;
            this._propertyChanged("coordinates");
        }
    },

    dataURL: {
        get: function () {
            return this.properties['dataURL'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'dataURL');
        }
    },

    displayLabelBorder: {
        get: function () {
            return this.properties['displayLabelBorder'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'displayLabelBorder');
        }
    },

    displayDistanceLabels: {
        get: function () {
            return this.properties['displayDistanceLabels'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'displayDistanceLabels');
        }
    },

    displayDistanceTotal: {
        get: function () {
            return this.properties['displayDistanceTotal'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'displayDistanceTotal');
        }
    },

    distanceLabels: {
        get: function () {
            return this.properties['distanceLabels'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'distanceLabels');
        }
    },

    fillColor: {
        get: function () {
            return this.properties['fillColor'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'fillColor');
        }
    },

    fillOpacity: {
        get: function () {
            return this.properties['fillOpacity'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'fillOpacity');
        }
    },

    fillStyle: {
        get: function () {
            return this.properties['fillStyle'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'fillStyle');
        }
    },

    fontColor: {
        get: function () {
            return this.properties['fontColor'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'fontColor');
        }
    },

    fontSize: {
        get: function () {
            return this.properties['fontSize'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'fontSize');
        }
    },

    formatLabel: {
        value: function (text, isArea) {
            var suffix;
            if (this.properties.units === "metric") {
                suffix = " km";
            } else {
                suffix = " mi";
            }
            if (isArea && isArea === true) suffix += "\u00B2";
            return this._formattedNumber(text) + suffix;
        }
    },

    geometry: {
        value: null
    },

    getCenter: {
        value: function () {
            var center;
            switch (this.properties.type) {
                case FigureType["Rectangle"]:
                case FigureType["Image"]:
                case FigureType["Polyline"]:
                case FigureType["Polygon"]:
                    center = GeometryUtilities.getCenter(this.coordinates);
                    break;
                case FigureType["Circle"]:
                    center = this.coordinates[0][0];
                    break;
            }
            return center;
        }
    },

    hasLabel: {
        get: function() {
            return this.properties['hasLabel'];
        },
        set: function(value) {
            this.needsLabelUpdate = true;
            this.setValueForProperty(value, 'hasLabel');
            if (value) {
                this.updateLabel();
            }
        }
    },

    id: {
        get: function () {
            return this._id;
        },
        set: function (value) {
            this._id = value;
        }
    },

    imageOpacity: {
        get: function() {
            return this.properties['imageOpacity'];
        },
        set: function(value) {
            this.setValueForProperty(value, 'imageOpacity');
        }
    },

    isHighlighted: {
        value: false
    },

    isNewObject: {
        get: function () {
            return this.properties['isNewObject'];
        },
        set: function (value) {
            this.properties['isNewObject'] = value;
        }
    },

    isValid: {
        value: function () {
            var isValid = false;
            switch (this.properties.type) {
                case FigureType["Annotation"]:
                case FigureType["Placemark"]:
                    isValid = this.coordinates;
                    break;
                case FigureType["Rectangle"]:
                    var coordinates = this.geometry.coordinates;
                    if (coordinates[0][0] !== coordinates[1][0] && coordinates[0][1] !== coordinates[3][1]) {
                        isValid = true;
                    }
                    break;
                case FigureType["Polyline"]:
                    if (this.geometry.coordinates && this.geometry.coordinates.length > 1) {
                        isValid = true;
                    }
                    break;
                case FigureType["Polygon"]:
                    if (this.geometry.coordinates && this.geometry.coordinates.length > 2) {
                        isValid = true;
                    }
                    break;
                case FigureType["Circle"]:
                    if (this.radius && this.radius > 0) {
                        isValid = true;
                    }
                    break;
            }
            return isValid;
        }
    },

    isVisible: {
        value: true
    },

    label: {
        value: ""
    },

    needsLabelUpdate: {
        value: false
    },

    labelStrokeColor: {
        get: function () {
            return this.properties['labelStrokeColor'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'labelStrokeColor');
        }
    },

    labelStrokeOpacity: {
        get: function () {
            return this.properties['labelStrokeOpacity'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'labelStrokeOpacity');
        }
    },

    labelStrokeWidth: {
        get: function () {
            return this.properties['labelStrokeWidth'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'labelStrokeWidth');
        }
    },

    labelType: {
        get: function () {
            return this.properties['labelType'];
        },
        set: function (value) {
            this.needsLabelUpdate = true;
            this.setValueForProperty(value, 'labelType');
            this.updateLabel();
        }
    },

    _labelTypes: {
        value: null
    },

    labelTypes: {
        writeable:false,
        get: function() {
            if (!this._labelTypes) {
                this._labelTypes = [];
                switch (this.type) {
                    case FigureType['Circle']:
                        this._labelTypes.push({label:"Area",value:"area"});
                        this._labelTypes.push({label:"Buffer",value:"buffer"});
                        break;
                    case FigureType['Polygon']:
                        this._labelTypes.push({label:"Area",value:"area"});
                        break;
                    case FigureType['Polyline']:
                        this._labelTypes.push({label:"Distance",value:"distance"});
                        break;
                }
            }
            return this._labelTypes;
        }
    },

    mapTip: {
        get: function () {
            return this.properties['mapTip'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'mapTip');
        }
    },

    name: {
        get: function () {
            return this.properties['name'];
        },
        set: function (value) {
            this.properties['name'] = value;
        }
    },

    needsDraw: {
        get: function () {
            return this.properties['needsDraw'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'needsDraw');
        }
    },

    originalAspectRatio: {
        get: function () {
            return this.properties['originalAspectRatio'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'originalAspectRatio');
        }
    },

    preserveAspectRatio: {
        get: function () {
            return this.properties['preserveAspectRatio'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'preserveAspectRatio');
        }
    },

    properties: {
        get: function () {
            if (this._properties === null) {
                this._properties = {};
            }
            return this._properties;
            return this._properties;
        },
        set: function (value) {
            this._properties = value;
        }
    },

    radius: {
        get: function () {
            return this.properties["radius"];
        },
        set: function (value) {
            this.setValueForProperty(value, "radius");
            this.updateLabel();
        }
    },

    removeComponent: {
        value: function (component) {
            var index = this.components.indexOf(component);
            if (index > -1) {
                this.components.splice(index, 1);
            }
        }
    },

    setValueForProperty: {
        value: function (value, property) {
            this.properties[property] = value;
            this._propertyChanged(property);
        }
    },

    strokeColor: {
        get: function () {
            return this.properties['strokeColor'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'strokeColor');
        }
    },

    strokeOpacity: {
        get: function () {
            return this.properties['strokeOpacity'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'strokeOpacity');
        }
    },

    strokeStyle: {
        get: function () {
            return this.properties['strokeStyle'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'strokeStyle');
        }
    },

    strokeWidth: {
        get: function () {
            return this.properties['strokeWidth'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'strokeWidth');
        }
    },

    textCharacter: {
        get: function () {
            return this.properties['textCharacter'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'textCharacter');
        }
    },

    type: {
        get: function () {
            return this.properties.type;
        },
        set: function (value) {
            this.setValueForProperty(value, 'type');
        }
    },

    updateLabel: {
        value: function () {

            if (this.hasLabel) {
                var labelText,
                    isArea = false;

                switch (this.properties.type) {
                    case FigureType["Circle"]:

                        if (this.properties.units === "metric") {
                            labelText = this.radius / 1000;
                        } else {
                            labelText = this.radius / 1609.34;
                        }

                        if (this.properties.labelType === "area") {
                            labelText = Math.PI * Math.pow(labelText, 2);
                            isArea = true;
                        }

                        break;

                    case FigureType["Polygon"]:
                        labelText = GeometryUtilities.calculateAreaOfPolygonFigure(this);
                        isArea = true;
                        if (this.properties.units === "imperial") {
                            labelText = labelText * 0.386102;
                        }
                        break;
                }
                if (labelText) {
                    this.label = this.formatLabel(labelText, isArea);
                }
            }
        }
    },

    units: {
        get: function () {
            return this.properties['units'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'units');
            this.updateLabel();
        }
    },

    zIndex: {
        get: function () {
            return this.properties['zIndex'];
        },
        set: function (value) {
            this.setValueForProperty(value, 'zIndex');
        }
    }

}, {

    clone: {
        value: function (object) {
            var target = {};
            for (var i in object) {
                if (object.hasOwnProperty(i)) {
                    target[i] = object[i];
                }
            }
            return target;
        }
    },

    defaultProperties: {
        value: {
            dataURL:"",
            displayLabelBorder: true,
            displayDistanceLabels: false,
            displayDistanceTotal: false,
            fillColor: "#000000",
            fillOpacity: 0.5,
            fontColor: "#000000",
            fontSize: 14,
            hasLabel: false,
            imageOpacity: 1,
            isFreeHand: false,
            isNewObject: true,
            labelStrokeColor: "#000000",
            labelStrokeOpacity: 1.0,
            labelStrokeWidth: 1,
            labelType: "buffer",
            preserveAspectRatio: false,
            radius: 0,
            strokeColor: "#000000",
            strokeOpacity: 1.0,
            strokeWidth: 2,
            textCharacter: "\ue65a",
            units: "metric"
        }
    },

    figureIndex: {
        value: 0
    },

    figureGeometryType: {
        value: function (type) {
            var geometryType;
            switch (type) {
                case FigureType["Annotation"]:
                case FigureType["Placemark"]:
                    geometryType = "Point";
                    break;
                case FigureType["Circle"]:
                    geometryType = "MultiPoint";
                    break;
                case FigureType["Polyline"]:
                    geometryType = "LineString";
                    break;
                case FigureType["Image"]:
                case FigureType["Rectangle"]:
                case FigureType["Polygon"]:
                    geometryType = "Polygon";
                    break;
            }
            return type;
        }
    },

    _initializeFigure: {
        value: function (type, coordinates, properties) {
            var figure = new Figure();
            figure.figureIndex = Figure.figureIndex;
            Figure.figureIndex++;
            figure.geometry = {
                coordinates: coordinates,
                type: Figure.figureGeometryType(type)
            };
            figure.properties = Figure.clone(Figure.defaultProperties);
            for (var key in properties) {
                if (Figure.defaultProperties.hasOwnProperty(key)) {
                    figure.properties[key] = properties[key];
                }
            }
            figure.type = type;
            figure.cartesian = {
                bounds: {
                    xMin: 0,
                    yMin: 0,
                    xMax: 0,
                    yMax: 0
                },
                center: {x:0,y:0},
                points: []
            };

            Object.defineProperties(figure.cartesian,{
                "width": {
                    writeable: false,
                    get: function () {
                        return this.bounds.xMax - this.bounds.xMin;
                    }
                },
                "height": {
                    writeable: false,
                    get: function () {
                        return this.bounds.yMax - this.bounds.yMin;
                    }
                }
            });
            return figure;
        }
    },

    initializeFigureWithType: {
        value: function (type, coordinates, properties) {

            var figure = Figure._initializeFigure(type, coordinates, properties);
            switch (type) {
                case FigureType["Annotation"]:
                    figure.name = "Annotation";
                    figure.mapTip = "Default Text";
                    figure.fillColor = "#FFFFFF";
                    figure.fillOpacity = 1.0;
                    break;
                case FigureType["Circle"]:
                    figure.name = "Circle";
                    figure.mapTip = "Circle Figure";
                    figure.radius = properties.radius;
                    break;
                case FigureType["Image"]:
                    figure.name = "Image";
                    figure.mapTip = "Image";
                    figure.preserveAspectRatio = true;
                    var image = new Image();
                    image.src = figure.dataURL;
                    image.onload = function () {
                        figure.cartesian.bounds.xMax = this.width;
                        figure.cartesian.bounds.yMax = this.height;
                        figure.aspectRatio = figure.originalAspectRatio = this.width/this.height;

                    };
                    break;
                case FigureType["Placemark"]:
                    figure.name = "Placemark";
                    figure.mapTip = "Placemark Figure";
                    figure.fontColor = "#0000FF";
                    figure.fontSize = 40;
                    break;
                case FigureType["Polyline"]:
                    figure.name = "Polyline";
                    figure.mapTip = "Polyline Figure";
                    break;
                case FigureType["Polygon"]:
                    figure.name = "Polygon";
                    figure.mapTip = "Polygon Figure";
                    break;
                case FigureType["Rectangle"]:
                    figure.name = "Rectangle";
                    figure.mapTip = "Rectangle Figure";
                    break;
            }
            return figure;
        }
    },


    isSupportedImageMimeType: {
        value: function(type) {
            return type ? SupportedImageMimeTypes.indexOf(type) !== -1 : false;
        }
    }

});
