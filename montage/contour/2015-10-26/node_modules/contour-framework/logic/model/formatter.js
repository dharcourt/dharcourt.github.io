var Montage = require("montage").Montage;

/**
 * @class
 * @extends external:Montage
 */
var Formatter = exports.Formatter = Montage.specialize(/** @lends Formatter# */ {

    /**
     * The child formatters of thie formatter.
     * @private
     * @type {array}
     */
    _children: {
        get: function () {
            return this.__children;
        },
        set: function (value) {
            this.__children = value;
        }
    },

    /**
     * @method
     * @argument {Object} value - The value to format.
     * @returns {string}        - The formatted value.
     */
    format: {
        value: function (value) {
            var i, n;
            for (i = 0, n = this._children.length; i < n; ++i) {
                value = this._children[i].format(value);
            }
            return value;
        }
    }

}, {

    /**
     * @memberof Formatter
     * @argument {external:Element} xml - A XML DOM element defining the
     *                                    formatter.
     * @returns {Formatter}
     */
    withXml: {
        value: function (xml) {
            var formatter = new this(),
                i, n, childElement, childFormatter;
            formatter._children = [];
            for (i = 0, n = xml.childNodes.length; i < n; ++i) {
                childElement = xml.childNodes[i];
                if (childElement.nodeType === 1) {
                    switch (childElement.tagName) {
                        case "DateFormatter":
                            childFormatter = DateFormatter.withXml(childElement);
                            break;
                        case "MathFormatter":
                            childFormatter = MathFormatter.withXml(childElement);
                            break;
                        case "RegExpFormatter":
                            childFormatter = RegExpFormatter.withXml(childElement);
                            break;
                        case "UrlFormatter":
                            childFormatter = UrlFormatter.withXml(childElement);
                            break;
                        case "ImageArrayFormatter":
                            childFormatter = ImageArrayFormatter.withXml(childElement);
                            break;
                        default:
                            console.warn("----------------------------");
                            console.warn("Unsupported formatter type (", childElement.tagName, ")");
                            childFormatter = undefined;
                            break;
                    }
                    if (childFormatter) {
                        formatter._children.push(childFormatter);
                    }
                }

            }
            return formatter;
        }
    },

    /**
     * @memberof Formatter
     * @method
     * @argument {char} value - The character to test to see if it is a whitespace character.
     * @returns {boolean}       - Returns true if the character is a white space character.
     */
    isWhiteSpaceCharacter: {
        value: function (char) {
            return Formatter.WhiteSpaceCharacters.indexOf(char) !== -1;
        }
    },

    /**
     * @memberof Formatter
     * @method
     * @argument {string} value - The string to trim for white space.
     * @argument {string} value - The trim white space rule e.g. left, right, both, all
     * @returns {string}       - The trimmed string.
     */
    trimWhiteSpace: {
        value: function (value, rule) {

            switch (rule) {
                case "left":
                    while (Formatter.isWhiteSpaceCharacter(value.charAt(0))) {
                        value = value.substring(1);
                    }
                    break;
                case "right" :
                    while (Formatter.isWhiteSpaceCharacter(value.charAt(value.length - 1))) {
                        value = value.substring(0, value.length - 1);
                    }
                    break;
                case "both":
                    value = Formatter.trimWhiteSpace(value, "left");
                    value = Formatter.trimWhiteSpace(value, "right");
                    break;
                case "all":
                    var i = 0;
                    while (i < value.length) {
                        if (Formatter.isWhiteSpaceCharacter(value.charAt(i))) {
                            value = value.substring(0, i) + value.substring(i + 1);
                        } else {
                            i++;
                        }
                    }
                    break;
            }
            return value;
        }
    },

    /**
     * @memberof Formatter
     * @const
     * Various white space characters.
     */
    WhiteSpaceCharacters: {
        value: [" ","\n","\r","\t","\f","\x0b","\xa0","\u2000","\u2001","\u2002",
            "\u2003","\u2004","\u2005","\u2006","\u2007","\u2008","\u2009","\u200a",
            "\u200b","\u2028","\u2029","\u3000"]
    },

    forQueryWithType: {
        value: {
            number: function (propertyName, filter) {
                var sql = "";
                if (typeof filter.minimum === "number") {
                    sql += propertyName + " >= " + filter.minimum;
                }
                if (typeof filter.maximum === "number") {
                    if (sql.length) {
                        sql += " AND ";
                    }
                    sql += propertyName + " <= " + filter.maximum;
                }
                return sql;
            },
            date: function (propertyName, filter) {
                var sql = "",
                    f = "YYYY-MM-DD HH:mm:ss";
                //(INCIDENT_TIME > date '2015-09-08 10:00:00' and INCIDENT_TIME < date '2015-09-11 09:59:00')
                if (filter.minimum) {
                    sql += propertyName + " >= date '" + filter.minimum.format(f)+"'";
                }
                if (filter.maximum) {
                    if (sql.length) {
                        sql += " AND ";
                    }
                    sql += propertyName + " <= date '" + filter.maximum.format(f)+"'";
                }
                return sql;
            },
            string: function (propertyName, filter) {
                var sql = "", e = encodeURI("%");
                if (filter.string) {
                    sql += "UPPER(" + propertyName + ") LIKE '" +e+ filter.string.toUpperCase() +e+"'";
                }
                return sql;
            }

        }
    }


});

/**
 * @class DateFormatter
 * @extends external:Formatter
 */
var DateFormatter = Formatter.specialize({

    /**
     * @private
     * @type {string}
     */
    _inputType: {
        value: undefined
    },

    /**
     * @private
     * @type {string}
     */
    _dateFormat: {
        value: undefined
    },

    _doubleDigit: {
        value: function (digit) {
            return digit < 10 ? "0" + digit : digit;
        }
    },

    /**
     * @method
     * @argument {Object} value - The value to format.
     */
    format: {
        value: function (value) {

            var date = new Date(value),
                year = date.getFullYear().toString(),
                month = date.getMonth(),
                dayOfTheMonth = date.getDate(),
                day = date.getDay(),
                hour = date.getHours(),
                minute = date.getMinutes(),
                second = date.getSeconds(),
                dateValues = {
                    YYYY: year,
                    YYY: year.substring(1, 4),
                    YY: year.substring(2, 4),
                    Y: year.substring(3, 4),
                    MM: this._doubleDigit(month + 1),
                    MON: DateFormatter.Constants.abbreviatedMonthNames[month],
                    MONTH: DateFormatter.Constants.paddedMonthNames[month],
                    RM: DateFormatter.Constants.abbreviatedMonthNames[month],
                    D: day + 1,
                    DAY: DateFormatter.Constants.dayNames[day],
                    DD: this._doubleDigit(dayOfTheMonth),
                    HH: hour,
                    HH12: hour,
                    HH24: this._doubleDigit(hour),
                    MI: this._doubleDigit(minute),
                    SS: this._doubleDigit(second),
                    AM: hour < 12 ? "AM" : "PM"
                },
                result = "",
                token = "",
                i, n, char;

            for (i = 0, n = this._dateFormat.length; i < n; i++) {
                char = this._dateFormat.charAt(i);
                if (DateFormatter.Constants.plSqlSymbols.indexOf(char) !== -1) {
                    token += char;
                } else {
                    result += dateValues[token] !== null ? dateValues[token] : token;
                    result += char;
                    token = "";
                }
            }
            if (token !== "") {
                result += dateValues[token] !== null ? dateValues[token] : token;
            }
            return result;
        }
    }


}, {

    /**
     * @memberof DateFormatter
     * @const
     * Various arrays used to support formatting dates.
     */
    Constants: {
        value: {
            plSqlSymbols: ["A", "D", "E", "F", "H", "I", "J", "M", "N", "O", "P", "Q", "R", "S", "T", "W", "Y", "1", "2", "4"],
            paddedMonthNames: [
                '  January', ' February', '    March', '    April', '      May', '     June', '     July',
                '   August', 'September', '  October', ' November', ' December'
            ],
            abbreviatedMonthNames: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
        }
    },

    /**
     * @memberof DateFormatter
     * @argument {external:Element} xml - A XML DOM element defining the
     *                                    date formatter.
     * @returns {DateFormatter}
     */
    withXml: {
        value: function (xml) {
            var formatter;
            if (xml.hasAttribute("InputType") && xml.hasAttribute("DateFormat")) {
                formatter = new this();
                formatter._inputType = xml.getAttribute("InputType");
                formatter._dateFormat = xml.getAttribute("DateFormat");
            } else {
                console.warn("----------------------------");
                console.warn("Invalid date formatter configuration");
                console.warn("Missing required attributes.");
            }
            return formatter;
        }
    }
});

/**
 * @class MathFormatter
 * @extends external:Formatter
 */
var MathFormatter = Formatter.specialize({

    /**
     * @private
     * @type {boolean}
     */
    _ignoreNaN: {
        value: undefined
    },

    /**
     * @private
     * @type {string}
     */
    _operand: {
        value: undefined
    },

    /**
     * @private
     * @type {string}
     */
    _operation: {
        value: undefined
    },

    /**
     * @private
     * @type {string}
     */
    _trim: {
        value: undefined
    },

    /**
     * @method
     * @argument {Object} value - The value to format.
     * @returns {string}        - The formatted value.
     */
    format: {
        value: function (value) {

            switch (this._operation) {
                case MathFormatter.Operation.ADD:
                    value += this._operand;
                    break;
                case MathFormatter.Operation.SUBTRACT:
                    value -= this._operand;
                    break;
                case MathFormatter.Operation.MULTIPLY:
                    value *= this._operand;
                    break;
                case MathFormatter.Operation.DIVIDE:
                    value /= this._operand;
                    break;
                case MathFormatter.Operation.POWER:
                    value = Math.pow(value, this._operand);
                    break;
                case MathFormatter.Operation.ROUND:
                    value = parseFloat(value.toFixed(this._operand));
                    break;
                default:
                    console.warn("----------------------------");
                    console.warn("Unable to format value (", value, ")");
                    console.warn("Unsupported operation (", this._operation, ")");
            }

        }
    }

}, {

    /**
     * @memberof MathFormatter
     * @const
     * Various arrays used to support formatting dates.
     */
    Operation: {
        value: {
            ADD: "+",
            SUBTRACT: "-",
            MULTIPLY: "*",
            DIVIDE: "/",
            POWER: "^",
            ROUND: "round"
        }
    },

    /**
     * @memberof MathFormatter
     * @argument {external:Element} xml - A XML DOM element defining the
     *                                    math formatter.
     * @returns {MathFormatter}
     */
    withXml: {
        value: function (xml) {
            var formatter;
            if (xml.hasAttribute("Operation") && xml.hasAttribute("Operand")) {
                formatter = new this();
                formatter._operation = xml.getAttribute("Operation");
                formatter._operand = xml.getAttribute("Operand");
                formatter._ignoreNaN = xml.getAttribute("IgnoreNaN") || true;
                formatter._trim = xml.getAttribute("Trim") || "none";
            } else {
                console.warn("----------------------------");
                console.warn("Invalid math formatter configuration");
                console.warn("Missing required attributes.");
            }
            return formatter;
        }
    }

});

/**
 * @class RegExpFormatter
 * @extends external:Formatter
 */
var RegExpFormatter = Formatter.specialize({

    /**
     * @private
     * @type {string}
     */
    _regExp: {
        value: undefined
    },

    /**
     * @private
     * @type {string}
     */
    _replace: {
        value: undefined
    },

    /**
     * @private
     * @type {string}
     */
    _regExpFlags: {
        value: undefined
    },

    /**
     * @private
     * @type {string}
     */
    _trim: {
        value: undefined
    },

    /**
     * @method
     * @argument {Object} value - The value to format.
     * @returns {string}        - The formatted value.
     */
    format: {
        value: function (value) {

            var regExp;
            if (typeof value === "number") {
                value = value.toString();
            }
            if (this._replace && typeof value === "string") {
                if (this._regExFlags) {
                    regExp = new RegExp(this._regExp, this._regExpFlags);
                } else {
                    regExp = new RegExp(this._regExp);
                }
            }
            value = value.replace(regExp, this._replace);
            if (this._trim) {
                value = Formatter.trimWhiteSpace(value, this._trim);
            }
            return value;
        }
    }

}, {

    /**
     * @memberof RegExpFormatter
     * @argument {external:Element} xml - A XML DOM element defining the
     *                                    regular expression formatter.
     * @returns {RegExpFormatter}
     */
    withXml: {
        value: function (xml) {
            var formatter;
            if (xml.hasAttribute("RegExp") && xml.hasAttribute("Replace")) {
                formatter = new this();
                formatter._regExp = xml.getAttribute("RegExp");
                formatter._replace = xml.getAttribute("Replace");
                formatter._regExpFlags = xml.getAttribute("RegExpFlags");
                formatter._trim = xml.getAttribute("Trim") || "none";
            } else {
                console.warn("----------------------------");
                console.warn("Invalid regular expression formatter configuration");
                console.warn("Missing required attributes.");
            }
            return formatter;
        }
    }
});

/**
 * @class UrlFormatter
 * @extends external:Formatter
 */
var UrlFormatter = Formatter.specialize({

    /**
     * @private
     * @type {RegExpFormatter}
     */
    _linkFormatter: {
        value: undefined
    },

    /**
     * @private
     * @type {RegExpFormatter}
     */
    _labelFormatter: {
        value: undefined
    },

    /**
     * @method
     * @argument {Object} value - The value to format.
     * @returns {string}        - The formatted value.
     */
    format: {
        value: function (value) {
            return {
                url: this._linkFormatter.format(value),
                label: this._labelFormatter.format(value),
                type: "hyperlink"
            }
        }
    }

}, {

    /**
     * @memberof UrlFormatter
     * @argument {external:Element} xml - A XML DOM element defining the
     *                                    url formatter.
     * @returns {UrlFormatter}
     */
    withXml: {
        value: function (xml) {
            var formatter,
                linkFormatterElement = xml.querySelector("UrlFormatterLink RegExpFormatter"),
                labelFormatterElement = xml.querySelector("UrlFormatterDisplay RegExpFormatter"),
                linkFormatter, labelFormatter;

            if (linkFormatterElement) {
                linkFormatter = RegExpFormatter.withXml(linkFormatterElement);
            }

            if (labelFormatterElement) {
                labelFormatter = RegExpFormatter.withXml(labelFormatterElement);
            }

            if (linkFormatter && linkFormatter instanceof RegExpFormatter &&
                labelFormatter && labelFormatter instanceof RegExpFormatter
            ) {
               formatter = new this();
                formatter._labelFormatter = labelFormatter;
                formatter._linkFormatter = linkFormatter;
            } else {
                console.warn("----------------------------");
                console.warn("Invalid regular expression formatter configuration");
                console.warn("Missing required attributes.");
            }
            return formatter;
        }
    }
});

/**
 * @class ImageArrayFormatter
 * @extends external:Formatter
 */
var ImageArrayFormatter = exports.ImageArrayFormatter = Formatter.specialize({

    _regExpFormatter: {
        value: undefined
    },

    _parseJson: {
        value: function (value) {
            var data;
            try {
                data = JSON.parse(value)
            } catch (e) {
                console.error(e)
            }
            return data;
        }
    },

    format: {
        value: function (value) {
            var images = [], i, n;
            if (typeof value === "string") {
                value = this._parseJson(value);
            }
            if (value && value instanceof Array) {
                for (i = 0, n = value.length; i < n; ++i) {
                    images.push(this._regExpFormatter.format(value[i]));
                }
            } else {
                console.warn("----------------------------");
                console.warn("Supplied invalid parameter.");
                console.warn("Cannot format value (", value, ")");
            }
            return images;
        }
    }

}, {

    /**
     * @memberof ImageArrayFormatter
     * @argument {external:Element} xml - A XML DOM element defining the
     *                                    image array formatter.
     * @returns {ImageArrayFormatter}
     */
    withXml: {
        value: function (xml) {
            var formatter, regExFormatter,
                regExpFormatterElement = xml.querySelector("RegExpFormatter");

            if (regExpFormatterElement) {
                regExFormatter = RegExpFormatter.withXml(regExpFormatterElement);
            }

            if (regExFormatter && regExFormatter instanceof RegExpFormatter) {
                formatter = new this();
                formatter._regExpFormatter = regExFormatter;
            } else {
                console.warn("----------------------------");
                console.warn("Invalid regular expression formatter configuration");
                console.warn("Missing required attributes.");
            }
            return formatter;
        }
    }
});
