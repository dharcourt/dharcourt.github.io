var Montage = require("montage").Montage,
    application = require("montage/core/application").application,
    Bounds = require("logic/model/bounds").Bounds,
    DataService = require("montage-data/logic/service/data-service").DataService,
    Enumeration = require("montage-data/logic/model/enumeration").Enumeration,
    Feature = require("logic/model/feature").Feature,
    FeatureCriteria = require("logic/model/feature-criteria").FeatureCriteria,
    GeometryType = require("logic/model/geometry-type").GeometryType,
    ObjectDescriptor = require("montage-data/logic/model/object-descriptor").ObjectDescriptor,
    Protocol = require("logic/model/protocol").Protocol;

/**
 * A layer of features, corresponding to a layer displayed on the map. Note
 * that what is displayed in layer lists and layer trees are not Layers but
 * [LayerReferences]{@linkplain LayerReference}.
 *
 * @class
 * @extends external:Montage
 */
var Layer = exports.Layer = Montage.specialize(/** @lends Layer.prototype */ {

    /***************************************************************************
     * Map service
     */

    mapService: {
        value: undefined
    },

    mapServiceLayerId: {
        value: undefined
    },

    /***************************************************************************
     * Basic information
     */

    id: {
        value: undefined
    },

    name: {
        value: ""
    },

    opacity: {
        value: 1
    },

    description: {
        value: ""
    },

    depth: {
        value: 0
    },

    initialBounds: {
        value: undefined
    },

    availableTimes: {
        value: undefined
    },

    clusterBehavior: {
        value: undefined
    },

    group: {
        value: undefined
    },

    url: {
        value: undefined
    },

    legendUrl: {
        value: undefined
    },

    timeServiceUrl: {
        value: undefined
    },

    /***************************************************************************
     * Type information
     */

    geometryType: {
        get: function () {
            return this._geometryType;
        },
        set: function (type) {
            if (type !== this._geometryType) {
                this.dispatchBeforeOwnPropertyChange("canCluster", this.canCluster);
                this.dispatchBeforeOwnPropertyChange("canSetTransparency", this.canSetTransparency);
                this.dispatchBeforeOwnPropertyChange("type", this.type);
                this._geometryType = type;
                this.dispatchOwnPropertyChange("canCluster", this.canCluster);
                this.dispatchOwnPropertyChange("canSetTransparency", this.canSetTransparency);
                this.dispatchOwnPropertyChange("type", this.type);
            }
        }
    },

    isBackground: {
        value: false
    },

    /***************************************************************************
     * State information
     */

    /**
     * When not explicitly set, the type will be derived from the layer's
     * geometry type, its current zoom level, and its map service prototol.
     *
     * @type {Layer.Type}
     */
    type: {
        get: function () {
            return  this._type ?                                                     this._type :
                    this.geometryType === GeometryType.RASTER ?                     Layer.Type.RASTER :
                    this.mapService && this.mapService.protocol === Protocol.WMS ?  Layer.Type.RASTER :
                    this.mapService && this.mapService.protocol === Protocol.WMTS ? Layer.Type.RASTER :
                    this._zoom < this.featureMinZoom ?                              Layer.Type.RASTER :
                                                                                    Layer.Type.FEATURE;
        },
        set: function (type) {
            if (type instanceof Layer.Type || !type) {
                this._type = type || undefined;
            }
        }
    },

    canAnimate: {
        get: function () {
            return this.timeServiceUrl !== undefined;
        }
    },

    canCluster: {
        get: function () {
            // TODO: removing logic for cluster behavior until we figure out why it's getting reset to undefined.
            //return this.geometryType === GeometryType.POINT || this.geometryType === GeometryType.MULTI_POINT && this.clusterBehavior === Layer.ClusteringBehavior.CHANGEABLE;
            return this.geometryType === GeometryType.POINT || this.geometryType === GeometryType.MULTI_POINT;
        }
    },

    canSetTransparency: {
        get: function () {
            // TODO: removing logic for cluster behavior until we figure out why it's getting reset to undefined.
            //return this.geometryType === GeometryType.POINT || this.geometryType === GeometryType.MULTI_POINT && this.clusterBehavior === Layer.ClusteringBehavior.CHANGEABLE;
            return this.geometryType === GeometryType.RASTER || this.geometryType === GeometryType.MULTI_LINE_STRING || this.geometryType === GeometryType.POLYGON;
        }
    },

    isClustering: {
        value: false
    },

    isEnabled: {
        get: function () {
            return this._isEnabled || false;
        },
        set: function (enabled) {
            var self = this;
            if (!enabled && this.isEnabled) {
                this._isEnabled = false;
                this.map = null;
            } else if (enabled && !this.isEnabled) {
                DataService.mainService.getObjectData(this, "geometryType").then(function () {
                    if (!self.isEnabled) {
                        self.dispatchBeforeOwnPropertyChange("isEnabled", false);
                        self._isEnabled = true;
                        self.dispatchOwnPropertyChange("isEnabled", true);
                        self.map = application.delegate && application.delegate.map;
                    }
                });
            }
        }
    },

    /***************************************************************************
     * Zoom information
     */

    minZoom: {
        value: undefined
    },

    maxZoom: {
        value: undefined
    },

    isVisibleAtZoom: {
        value: function (zoom) {
            return !this.minZoom || zoom >= this.minZoom && !this.maxZoom || zoom <= this.maxZoom;
        }
    },

    /***************************************************************************
     * Feature information
     */

    areFeaturesGlobal: {
        get: function () {
            return this._areFeaturesGlobal || false;
        },
        set: function (areGlobal) {
            if (areGlobal != this.areFeaturesGlobal) {
                this._areFeaturesGlobal = areGlobal ? true : false;
                // TODO: Update bounds and visible features accordingly.
            }
        }
    },

    featureMinZoom: {
        value: 0
    },

    featureFields: {
        get: function () {
            var layer = this;
            if (!this._featureFields) {
                this._featureFields = Object.create({}, {
                    all: {
                        get: function () { return layer._featureFields_all; }
                    },
                    detail: {
                        get: function () { return layer._featureFields_detail; }
                    },
                    filter: {
                        get: function () { return layer._featureFields_filter; }
                    },
                    summary: {
                        get: function () { return layer._featureFields_summary; }
                    }
                });
            }
            return this._featureFields;
        }
    },

    _featureFields_all: {
        get: function () {
            if (!this.__featureFields_all) {
                this.__featureFields_all = [];
            }
            return this.__featureFields_all;
        }
    },

    _featureFields_detail: {
        get: function () {
            if (!this.__featureFields_detail) {
                this.__featureFields_detail = [];
            }
            return this.__featureFields_detail;
        }
    },

    _featureFields_filter: {
        get: function () {
            if (!this.__featureFields_filter) {
                this.__featureFields_filter = [];
            }
            return this.__featureFields_filter;
        }
    },

    _featureFields_summary: {
        get: function () {
            if (!this.__featureFields_summary) {
                this.__featureFields_summary = [];
            }
            return this.__featureFields_summary;
        }
    },

    featureFieldConfiguration: {
        get: function () {
            if (!this._featureFieldConfiguration) {
                this._featureFieldConfiguration = {};
            }
            return this._featureFieldConfiguration;
        }
    },

    featureCriteria: {
        get: function () {
            if (!this._featureCriteria) {
                this._featureCriteria = FeatureCriteria.withLayerBoundsAndFilters(this, this.bounds);
            }
            return this._featureCriteria;
        },
        set: function (criteria) {
            if (criteria !== this._featureCriteria) {
                this._featureCriteria = criteria;
                 //if (this.__features_all) {
                 //    DataService.mainService.getChildService(Layer.TYPE).getPropertyData(this, "_features_all");
                 //}
                 //if (this.__features_visible) {
                 //    DataService.mainService.getChildService(Layer.TYPE).getPropertyData(this, "_features_visible");
                 //}
                if (this.areFeaturesGlobal) {
                    DataService.mainService.getChildService(Layer.TYPE).getPropertyData(this, "_features_all");
                } else {
                    DataService.mainService.getChildService(Layer.TYPE).getPropertyData(this, "_features_visible");
                }
            }
        }
    },

    features: {
        get: function () {
            var layer = this;
            if (!this._features) {
                this._features = Object.create({}, {
                    all: {
                        get: function () { return layer._features_all; }
                    },
                    visible: {
                        get: function () { return layer._features_visible; }
                    }
                });
            }
            return this._features;
        }
    },

    _features_all: {
        get: function () {
            if (!this.__features_all) {
                this.__features_all = [];
            }
            return this.__features_all;
        }
    },

    _features_visible: {
        get: function () {
            if (!this.__features_visible) {
                this.__features_visible = [];
            }
            return this.__features_visible;
        }
    },

    /***************************************************************************
     * Map state
     */

    map: {
        get: function () {
            return this._map;
        },
        set: function (map) {
            if (map !== this._map) {
                this._map = map;
                if (this.getBinding("bounds")) {
                    this.cancelBinding("bounds");
                }
                if (this.getBinding("_zoom")) {
                    this.cancelBinding("_zoom");
                }
                if (map) {
                    this._bounds = undefined;
                    if (this.areFeaturesGlobal) {
                        DataService.mainService.getChildService(Layer.TYPE).getPropertyData(this, "_features_all");
                    } else {
                        this.defineBinding("bounds", {"<-": "bounds", "source": map});
                    }
                    this.defineBinding("_zoom", {"<-": "currentZoom", "source": map});
                }
            }
        }
    },

    bounds: {
        get: function () {
            return this._bounds || Bounds.EARTH;
        },
        set: function (bounds) {
            if (bounds && !(bounds instanceof Bounds)) {
                // TODO [Charles]: Remove when map's currentBounds are Bounds.
                bounds = Bounds.withCoordinates(bounds.west, bounds.south, bounds.east, bounds.north);
            }
            if (bounds instanceof Bounds && !bounds.equals(this.bounds) || !bounds && this._bounds) {
                // TODO [Charles]: Fix & use
                // DataService.mainService.updateObjectData() instead of
                // DataService.mainService.getChildService(Layer.TYPE)... Layers
                // shouldn't need to know about any service other than
                // DataService.mainService.
                this._bounds = bounds && !bounds.equals(Bounds.EARTH) ? bounds : undefined;
                //DataService.mainService.getChildService(Layer.TYPE).getPropertyData(this, "_features_visible");
                this.featureCriteria = FeatureCriteria.withLayerBoundsAndFilters(this, this._bounds, this.featureCriteria.filters);
            }
        }
    },

    _zoom: {
        get: function () {
            return this.isEnabled ? this.__zoom : 0;
        },
        set: function (zoom) {
            if (zoom !== this.__zoom) {
                this.dispatchBeforeOwnPropertyChange("type", this.type);
                this.__zoom = zoom;
                this.dispatchOwnPropertyChange("type", this.type);
            }
        }
    },

    /***************************************************************************
     * Rendering
     */

    /**
     * A dictionary for the symbols the engine creates to represent a feature.
     */
    symbols: {
        get: function () {
            if (!this._symbols) {
                this._symbols = {};
            }
            return this._symbols;
        }
    },

    toGeojson: {
        value: function () {
            var features = this.features.all,
                geoJsonFeatures = [],
                i, len;

            if (this.geometryType === GeometryType.RASTER) {
                return null;
            }

            for (i = 0, len = features.length; i < len; i++) {
                geoJsonFeatures.push(features[i].toGeojson());
            }

            return {
                type: "FeatureCollection",
                properties: {
                    name: this.name,
                    description: this.description
                },
                features: geoJsonFeatures
            };
        }
    }

}, /** @lends Layer */ {

    /***************************************************************************
     * Montage data
     */

    /**
     * The Montage Data type of layers.
     *
     * @type {external:ObjectDescriptor}
     */
    TYPE: {
        get: ObjectDescriptor.getterFor(exports, "Layer", {
            "_features_all": {destinationType: Feature.TYPE},
            "_features_visible": {destinationType: Feature.TYPE},
            "_featureFields_all": {destinationType: null},
            "_featureFields_detail": {destinationType: null},
            "_featureFields_summary": {destinationType: null},
            "availableTimes": {destinationType: null},
            "canCluster": {destinationType: null},
            "canSetTransparency": {destinationType: null},
            "geometryType": {destinationType: null},
            "initialBounds": {destinationType: null},
            "renderer": {destinationType: null},
            "type": {destinationType: null},
            "url": {destinationType: null}
        })
    },

    /***************************************************************************
     * Types
     */

    /**
     * @class
     */
    Type: {
        get: Enumeration.getterFor("_Type", "", "name", {
            FEATURE: ["Feature"],
            HAZARD: ["Hazard"],
            HEAT_MAP: ["Heat Map"],
            IMPORT: ["Import"],
            PRODUCT: ["Product"],
            RASTER: ["Raster"]
        })
    },

    /**
     * @class
     */
    ClusteringBehavior: {
        get: Enumeration.getterFor("_ClusteringBehavior", "", "name", {
            ALWAYS_ON: ["always"],
            ALWAYS_OFF: ["never"],
            CHANGEABLE: ["changeable"]
        })
    }

});
