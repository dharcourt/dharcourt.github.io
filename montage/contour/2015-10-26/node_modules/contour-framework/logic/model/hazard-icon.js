var Montage = require("montage").Montage,
    application = require("montage/core/application").application,
    DataService = require("montage-data/logic/service/data-service").DataService,
    Hazard = require("logic/model/hazard").Hazard;

/**
 * A hazard icon.
 *
 * @class
 * @extends external:Montage
 */
exports.HazardIcon = Montage.specialize( /** @lends HazardIcon.prototype */ {

    /** @type {string} */
    url: {
        value: undefined
    },

    /** @type {number} */
    size: {
        value: undefined
    }

}, /** @lends HazardIcon */ {

    /** @method */
    get: {
        value: function (category, severity, type) {
            var map = this._icons;
            map = map && map.get(category);
            map = map && map.get(severity);
            return map && map.get(type);
        }
    },

    /** @method */
    generateAllIcons: {
        value: function (hazardLayer) {
            var self = this;
            DataService.mainService.getObjectData(hazardLayer, "hazardCategories", "hazardSeverities", "hazardTypes").then(function () {
                var canvas = document.createElement("canvas"),
                    context = canvas.getContext("2d"),
                    category, severity, type, icon, i, j, k, l, m, n;
                for (i = 0, n = hazardLayer.hazardTypes.length; i < n; i += 1) {
                    type = hazardLayer.hazardTypes[i];
                    for (j = 0, m = hazardLayer.hazardCategories.length; j < m; j += 1) {
                        category = hazardLayer.hazardCategories[j];
                        for (k = 0, l = hazardLayer.hazardSeverities.length; k < l; k += 1) {
                            severity = hazardLayer.hazardSeverities[k];
                            icon = self._generateIcon(canvas, context, category, severity, type);
                            self._setIcon(category, severity, type, icon);
                        }
                    }
                }
            });
        }
    },

    /** @private @method */
    _generateIcon: {
        value: function (canvas, context, category, severity, type) {
            var size = Math.max(type.iconImage.width, type.iconImage.height),
                radius = Math.floor(size / 2) + category.padding,
                icon;
            this._drawBackground(canvas, context, category, severity, radius);
            this._drawCenteredImage(canvas, context, type.iconImage);
            icon = this._createIcon(canvas.toDataURL('image/png'), radius * 2);
            context.clearRect(0, 0, canvas.width, canvas.height);
            return icon;
        }
    },

    /** @private @method */
    _drawBackground: {
        value: function (canvas, context, category, severity, radius) {
            context.save();
            canvas.width = radius * 2;
            canvas.height = radius * 2;
            context.lineWidth = 2;
            context.strokeStyle = "rgb(" + severity.color + ")";
            context.fillStyle = "rgba(" + severity.color + ", 0.5)";
            if (category === Hazard.Category.EVENT) {
                this._drawCircle(context, radius);
            } else if (category === Hazard.Category.EXERCISE) {
                this._drawPolygon(context, radius, 3, -(Math.PI / 2));
            } else if (category === Hazard.Category.OTHER) {
                this._drawPolygon(context, radius, 6);
            } else if (category === Hazard.Category.RESPONSE) {
                this._drawStar(context, radius);
            }
            context.fill();
            context.stroke();
            context.restore();
        }
    },

    /** @private @method */
    _drawCircle: {
        value: function (context, radius) {
            context.arc(radius, radius, radius - 1, 0, 2 * Math.PI, false);
        }
    },

    /** @private @method */
    _drawPolygon: {
        value: function (context, radius, sides, startAngle) {
            var angle = (Math.PI * 2) / sides,
                i, n;
            context.translate(radius, radius);
            context.rotate(startAngle || 0);
            for (i = 0, n = sides; i <= n; ++i) {
                context.lineTo(radius * Math.cos(i * angle), radius * Math.sin(i * angle));
            }
            context.closePath();
            context.setTransform(1, 0, 0, 1, 0, 0);
        }
    },

    /** @private @method */
    _drawStar: {
        value: function (context, radius) {
            var i, n;
            context.beginPath();
            context.translate(radius, radius);
            context.moveTo(0, 0 - radius);
            for (i = 0, n = 5; i < n; ++i) {
                context.rotate(Math.PI / 5);
                context.lineTo(0, 0 - (radius * 0.6));
                context.rotate(Math.PI / 5);
                context.lineTo(0, 0 - 5);
            }
            context.closePath();
            context.setTransform(1, 0, 0, 1, 0, 0);
        }
    },

    /** @private @method */
    _drawCenteredImage: {
        value: function (canvas, context, image) {
            var offsetX = Math.floor((canvas.width - image.width) / 2),
                offsetY = Math.floor((canvas.height - image.height) / 2);
            context.drawImage(image, offsetX, offsetY);
        }
    },

    /** @private @method */
    _createIcon: {
        value: function (url, size) {
            var icon = new this();
            icon.url = url;
            icon.size = size;
            return icon;
        }
    },

    /** @private @method */
    _setIcon: {
        value: function (category, severity, type, icon) {
            if (!this._icons) {
                this._icons = new Map();
            }
            if (!this._icons.get(category)) {
                this._icons.set(category, new Map());
            }
            if (!this._icons.get(category).get(severity)) {
                this._icons.get(category).set(severity, new Map());
            }
            this._icons.get(category).get(severity).set(type, icon);
        }
    }

});
