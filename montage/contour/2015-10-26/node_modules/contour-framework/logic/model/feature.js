var Montage = require("montage").Montage,
    Enumeration = require("montage-data/logic/model/enumeration").Enumeration,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    ObjectDescriptor = require("montage-data/logic/model/object-descriptor").ObjectDescriptor;

/**
 * Layer feature.
 *
 * @class Feature
 * @extends external:Montage
 */
exports.Feature = Montage.specialize(/** @lends Feature.prototype */ {

    /***************************************************************************
     * Basic information
     */

    /**
     * @type {Layer}
     */
    layer: {
        value: undefined
    },

    /**
     * @type {Number}
     */
    id: {
        value: undefined
    },

    type: {
        get: function () {
            return this._type || exports.Feature.Type.FEATURE;
        },
        set: function (type) {
            this._type = type;
        }
    },

    /**
     * The GeoJSON properties of this feature.
     *
     * @type {Object}
     */
    properties: {
        value: {}
    },

    /**
     * The GeoJSON geometry of this feature.
     *
     * @type {Object}
     */
    geometry: {
        value: undefined
    },

    /***************************************************************************
     * Derived property information
     */

    /**
     * @method
     * @argument {Object<Field>}  The layer field to lookup the value for in the feature's properties.
     * @returns                 - The feature's formatted value for the passed in field.
     */
    valueForField: {
        value: function (field) {
            var value = this._rawValueForField(field);
            if (value && field.formatter) {
                value = field.formatter.format(value);
            }
            return value;
        }
    },

    _rawValueForField: {
        value: function (field) {
            var rawValue = this.properties[field.propertyName];
            if (rawValue === undefined) {
                rawValue = this.properties[field.propertyName.toLowerCase()];
            }
            if (rawValue === undefined) {
                rawValue = this.properties[field.propertyName.toUpperCase()];
            }
            return rawValue;
        }
    },

    /***************************************************************************
     * Derived geometry information
     */

    getCenter: {
        value: function () {
            var center;
            switch (this.geometry.type) {
                case "Point":
                    center = this.geometry.coordinates;
                    break;
                case "MultiPoint":
                    center = GeometryUtilities.getCenter(this.geometry.coordinates);
                    break;
                case "MultiLineString":
                case "MultiPolygon":
                case "Polygon":
                    center = GeometryUtilities.getCenter(this.geometry.coordinates[0]);
                    break;
            }
            return center;
        }
    },

    toGeojson: {
        value: function () {
            var properties = {},
                fields = this.layer.featureFields.summary,
                len = fields.length;

            for (var i = 0; i < len; i++) {
                properties[fields[i].name] = this.valueForField(fields[i]);
            }

            if (this.layer.renderer) {
                properties.style = Object.clone(this.layer.renderer.export(this.properties));
                if (properties.style.symbolUrl) {
                    properties.style.url = this.layer.url + "/images/" + properties.style.symbolUrl;
                }
            }

            return {
                type: this.type.name,
                geometry: this.geometry,
                properties: properties
            };
        }
    }
}, {

    /***************************************************************************
     * Montage data
     */

    /**
     * The Montage Data type of features.
     *
     * @type {external:ObjectDescriptor}
     */
    TYPE: {
        get: ObjectDescriptor.getterFor(exports, "Feature")
    },

    /***************************************************************************
     * Types
     */

    /**
     * Feature type enumeration.
     *
     * @class
     */
    Type: {
        get: Enumeration.getterFor("_Type", "", "id", "name", /** @lends Feature.Type */ {
            FEATURE: ["FEATURE", "Feature"],
            HAZARD: ["HAZARD", "Hazard"],
            PRODUCT: ["PRODUCT", "Product"],
            IMPORTED: ["IMPORTED", "Imported"]
        })
    }

});
