/**
 * @module logic/bookmark.js
 */
var Montage = require("montage").Montage,
    moment = require("moment-timezone"),
    Figure = require("logic/model/figure").Figure,
    FigureType = require("logic/model/figure").FigureType,
    ObjectStream = require("logic/mock-montage-data/object-stream").ObjectStream,
    BookmarkSelector = require("logic/mock-service/bookmark-selector").BookmarkSelector,
    BookmarkService = require("logic/mock-service/bookmark-service");

var AttributeMap = {
    "bookmark_name": "name",
    "bookmark_data": "data",
    "bookmark_id": "id",
    "m_create_date": "mCreateDate",
    "create_date": "creationDate",
    "startup_flag":"isDefault",
    "status_flag": "status",
    "user_id": "user"
};


/**
 * @class product
 * @extends Montage
 *
 * Object representing a feature. This may or may not be a placehoder (TBD).
 *
 */
var Bookmark = exports.Bookmark = Montage.specialize(/** @lends Bookmark.prototype */ {

    constructor: {
        value: function Bookmark() {
            if (BookmarkService.BookmarkService) {
                BookmarkService = BookmarkService.BookmarkService;
            }
        }
    },

    _data: { value: null },

    _searchTerms: { value: null },

    _type: { value: null },

    data: {
        get: function () {
            var selector = new BookmarkSelector(this.id),
                dataStream = new ObjectStream(selector),
                self = this,
                service = BookmarkService.getInstance();
            if (!this._data) {
                service.query(selector).then(function (bookmarkArray) {
                    self._data = JSON.parse(bookmarkArray[0].bookmark_data);
                    self._type = 0;
                    //layers and extent == 2, layers = 1, extent = 0

                    if (self._data.layers ) {
                        self._data.layers = Bookmark._parseLayers(self._data.layers);
                    }

                    if (self._data.figures) {
                        self._data.figures = Bookmark._parseFigures(self._data.figures);
                    }

                    (self._data.layers || self._data.figures) && self._type++;

                    if (self._data.center) {
                        self._data.extent = {
                            center: [self._data.center.lng,self._data.center.lat],
                            zoom: self._data.zoom
                        };
                        delete self._data.center;
                        delete self._data.zoom;
                        self._type === 1 && self._type++;
                    }
                    dataStream.add(self._data);
                    dataStream.resolve([self._data]);
                });
            }  else {
                setTimeout(function() {
                    dataStream.add(self._data);
                    dataStream.resolve([self._data]);
                }, 0);

            }

            return dataStream;
        }
    },

    creationDate: { value: null },

    extent: {
        get: function() {
            var extentStream = new ObjectStream(new BookmarkSelector()),
                self = this;
            if (this._data) {
                setTimeout(function() {
                    extentStream.add(self._data.extent);
                    extentStream.resolve([self._data.extent]);
                }, 0);
            } else {
                this.data.then(function () {
                    extentStream.add(self._data._extent);
                    extentStream.resolve([self._data._extent]);
                });
            }
            return extentStream;
        }
    },

    figures: {
        get: function() {
            var figureStream = new ObjectStream(new BookmarkSelector()),
                self = this;
            if (this._data) {
                setTimeout(function() {
                    figureStream.add(self._data.figures);
                    figureStream.resolve([self._data.figures]);
                },0);
            } else {
                this.data.then(function () {
                    figureStream.add(self._data.figures);
                    figureStream.resolve([self._data.figures]);
                });
            }
            return figureStream;
        }
    },


    isDefault: { value: false },

    link: { value: null },


    layers: {
        get: function() {
            var layerStream = new ObjectStream(new BookmarkSelector()),
                self = this;
            if (this._data) {
                setTimeout(function() {
                    layerStream.add(self._data.layers);
                    layerStream.resolve([self._data.layers]);
                },0);
            } else {
                this.data.then(function () {
                    layerStream.add(self._data.layers);
                    layerStream.resolve([self._data.layers]);
                });
            }
            return layerStream;
        }
    },

    mCreateDate: { value: null },

    name: { value: "" },

    searchTerms: {
        get: function () {
            if (!this._searchTerms) {
                var terms = {},
                    string = this.name,
                    split, j, m;
                string = string.replace(/[\W_]+/g, " ").trim().toLowerCase();
                split = string && string.split(" ");
                for (j = 0, m = split ? split.length : 0; j < m; ++j) {
                    terms[split[j]] = this;
                }
                this._searchTerms = terms;
            }
            return this._searchTerms;
        }
    },

    type: {
        get: function() {
            var typeStream = new ObjectStream(new BookmarkSelector()),
                self = this;
            if (this._data) {
                setTimeout(function() {
                    typeStream.add(self._type);
                    typeStream.resolve([self._type]);
                },0);
            } else {
                this.data.then(function () {
                    typeStream.add(self._type);
                    typeStream.resolve([self._type]);
                });
            }
            return typeStream;
        }
    }

}, {

    createBookmark: {
        value: function (data) {
            var bookmark = new Bookmark();

            for (var key in data) {
                if (AttributeMap[key]) {
                    bookmark[AttributeMap[key]] = data[key];
                } else {
                    bookmark[key] = data[key];
                }
            }

            bookmark.mCreateDate = bookmark.mCreateDate ? new moment(parseInt(bookmark.mCreateDate)) : new moment();
            bookmark.creationDate = bookmark.creationDate ? new moment(parseInt(bookmark.creationDate)) : new moment();
            bookmark.isDefault = (bookmark.isDefault === 1);
            bookmark.link = window.location.host + window.location.pathname + "?bookmark_id="+(bookmark.id ? bookmark.id : 99999);
            bookmark.isNewObject = true;
            return bookmark;
        }
    },

    initialize: {
        value: function (data) {
            var bookmark = Bookmark.createBookmark(data);
            return bookmark;
        }
    },

    save: {
        value: function (bookmark, bookmarkData) {
            bookmark._data = {};
            if (bookmark._type == 2) {
                bookmark._data == bookmarkData;
            } else if (bookmark._type == 1) {
                bookmark._data.layers = bookmarkData.layers;
                bookmark._data.figures = bookmarkData.figures;
            } else {
                bookmark._data.extent = bookmarkData.extent;
            }
            BookmarkService.save(bookmark);
        }
    },

    _onLoadBookmark: {
        value: function (request, stream) {
            var data = JSON.parse(request.responseText);
            stream.add(data[0]);
            stream.resolve(data);
            return stream;
        }
    },
    _parseFigures: {
        value: function (figuresArray) {
            var i, length, figures = [], figure;
            for (i = 0, length = figuresArray.length; i < length; i++) {
                figure = this._parseFigure(figuresArray[i]);
                if (figure) {
                    figures.push(figure);
                }
            }
            return figures;
        }
    },
    _parseFigure: {
        value: function (jsonFigure) {

            //TODO: When bookmark creation from contour is complete, this method will
            //need to determine the format of the returned figure and redirect as necessary
            var figure = this._parseLegacyFigure(jsonFigure);
            return figure;
        }
    },
    _parseLegacyFigure: {
        value: function (legacyFigure) {
            var contourFigure,
                coordinates,
                properties,
                type;
            type = this._parseLegacyFigureType(legacyFigure);
            if (typeof type !== "undefined") {
                properties = this._parseLegacyFigureProperties(legacyFigure);
                coordinates = this._parseLegacyFigureCoordinates(legacyFigure);

                contourFigure = Figure.initializeFigureWithType(type, coordinates, properties);
                if (contourFigure.type === FigureType["Annotation"]) {
                    contourFigure.fillOpacity = legacyFigure.fillOpacity;
                    contourFigure.mapTip = legacyFigure.maptip;
                    contourFigure.strokeColor = legacyFigure.borderColor;
                    properties.strokeOpacity = legacyFigure.borderOpacity;
                }
            }
            return contourFigure;
        }
    },
    _parseLegacyFigureCoordinates: {
        value: function (legacyFigure) {
            var coordinates, i, length, path, pathItem;
            switch  (legacyFigure.title) {
                case "Point":
                case "Placemark":
                case "Annotation":
                    coordinates = [legacyFigure.position.lng,legacyFigure.position.lat];
                    break;
                case "Image":
                    coordinates = [[legacyFigure.position.lng, legacyFigure.position.lat]];
                    break;
                case "Rectangle":
                    coordinates = [];
                    var tmpNe = legacyFigure.bounds.ne,
                        tmpSw = legacyFigure.bounds.sw;//nw, ne, se, sw, nw
                    coordinates.push([tmpSw.lng, tmpNe.lat]);
                    coordinates.push([tmpNe.lng, tmpNe.lat]);
                    coordinates.push([tmpNe.lng, tmpSw.lat]);
                    coordinates.push([tmpSw.lng, tmpSw.lat]);
                    coordinates.push([tmpSw.lng, tmpNe.lat]);
                    break;
                case "Line":
                case "Free Line":
                case "Polygon":
                case "Free Polygon":
                case "Polygon Area Tool":
                case "Buffer Tool":
                    coordinates = [];
                    path = legacyFigure.path || legacyFigure.paths;
                    for (i = 0, length = path.length; i < length; i++) {
                        pathItem = path[i];
                        coordinates.push([pathItem.lng,pathItem.lat]);
                    }
                    if (legacyFigure.title === "Buffer Tool") {
                        coordinates = [coordinates];
                    }
                    break;
                case "Circle Area Tool":
                    coordinates = [[[legacyFigure.center.lng, legacyFigure.center.lat]]];
                    break;
            }
            return coordinates;
        }
    },
    _parseLegacyFigureProperties: {
        value: function (legacyFigure) {
            var properties = {
                strokeColor: legacyFigure.strokeColor,
                strokeOpacity: legacyFigure.strokeOpacity,
                strokeWidth: parseInt(legacyFigure.strokeWeight),
                fillColor: legacyFigure.fillColor,
                fillOpacity: legacyFigure.fillOpacity,
                fontColor: legacyFigure.textColor,
                fontSize: legacyFigure.fontSize || 14,
                mapTip: legacyFigure.maptip,
                name: legacyFigure.name,
                isNewObject: false
            };
            switch (legacyFigure.title) {
                case "Image":
                    properties.dataURL = legacyFigure.imageSrc;
                    break;
                case "Buffer Tool":
                    properties.hasLabel = true;
                    properties.labelType = "buffer";
                    properties.radius = legacyFigure.radius;
                    break;
                case "Circle Area Tool":
                    properties.hasLabel = true;
                    properties.labelType = "area";
                    properties.radius = legacyFigure.radius;
                    break;
                case "Polygon Area Tool":
                    properties.hasLabel = true;
                    break;
                case "Annotation":
                    properties.hasLabel = true;
                    break;
            }
            return properties;
        }
    },
    _parseLegacyFigureType: {
        value: function (legacyFigure) {
            var type;
            switch  (legacyFigure.title) {
                case "Point":
                case "Placemark":
                    type = FigureType["Placemark"];
                    break;
                case "Image":
                    type = FigureType["Image"];
                    break;
                case "Rectangle":
                    type = FigureType["Rectangle"];
                    break;
                case "Line":
                case "Free Line":
                    type = FigureType["Polyline"];
                    break;
                case "Polygon":
                case "Free Polygon":
                case "Polygon Area Tool":
                    type = FigureType["Polygon"];
                    break;
                case "Buffer Tool":
                case "Circle Area Tool":
                    type = FigureType["Circle"];
                    break;
                case "Annotation":
                    type = FigureType["Annotation"];
                    break;
            }
            return type;
        }
    },
    _parseLayers: {
        value: function (layersArray) {
            var layers = {
                all: [],
                byId: {}
            },
            i, length, layer;
            for (i = 0, length = layersArray.length; i < length; i++) {
                layer = Bookmark._parseLayer(layersArray[i]);
                layers.all.push(layer);
                layers.byId[layer.id] = layer;
            }
            return layers;
        }
    },
    _parseLayer: {
        value: function (jsonLayer) {
            var layer = {
                opacity: jsonLayer.alpha,
                id: jsonLayer.id
            };
            return layer;
        }
    }
});
