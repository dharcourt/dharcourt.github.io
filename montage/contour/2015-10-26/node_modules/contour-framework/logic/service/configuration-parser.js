var Montage = require("montage").Montage,
    Authority = require("logic/model/authority").Authority,
    Configuration = require("logic/model/configuration").Configuration,
    DataService = require("montage-data/logic/service/data-service").DataService,
    Field = require("logic/model/field").Field,
    Formatter = require("logic/model/formatter").Formatter,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    HazardLayer = require("logic/model/hazard-layer").HazardLayer,
    Layer = require("logic/model/layer").Layer,
    LayerFolder = require("logic/model/layer-folder").LayerFolder,
    LayerReference = require("logic/model/layer-reference").LayerReference,
    MapService = require("logic/model/map-service").MapService,
    Projection = require("logic/model/projection").Projection,
    Protocol = require("logic/model/protocol").Protocol,
    Set = require("collections/set"),
    Units = require("logic/model/units").Units;

/**
 * Handles all parsing of configuration data.
 *
 * @class
 * @extends external:Montage
 */
var ConfigurationParser = exports.ConfigurationParser = Montage.specialize(/** @lends ConfigurationParser# */{

    parseAuthorities: {
        value: function (xml) {
            var authorities = {},
                nodes = xml.querySelectorAll("AuthServices > AuthService"),
                i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                authorities[nodes[i].getAttribute("Id")] = new Authority();
            }
            return {byId: authorities};
        }
    },

    parseConfiguration: {
        value: function (xml, authorities, user) {
            // The order of the parsing and tree creation below ensures that
            // the needed data is available at each step of the process. The
            // set of background layers is hard coded for now to the content
            // of a particular group... need to work with PDC to come up with a
            // configuration for specifying the background layers.
            var urlPrefixes = this._parseUrlPrefixes(xml),
                projections = this._parseProjections(xml),
                mapServers = this._parseMapServers(xml, urlPrefixes),
                mapServices = this._parseMapServices(xml, authorities, user, mapServers, projections),
                layerGroups = this._parseLayerGroups(xml),
                realLayers = this._parseRealLayers(xml, urlPrefixes, mapServices, layerGroups),
                virtualLayers = this._parseVirtualLayers(xml, realLayers),
                tableOfContents = this._parseTableOfContent(xml, realLayers, virtualLayers),
                folders = this._parseLayerFolders(xml),
                layerTree = this._buildLayerTrees(xml, folders, tableOfContents),
                formatters = this._parseFormatters(xml);
            this._parseLayerFields(xml, realLayers, formatters);
            return {
                application: {
                    ids: this._parseAppIds(xml)
                },
                featureFields: {
                    defaultSummaryCount: this._parseDefaultSummaryFieldCount(xml),
                    ignored: this._parseIgnoredFields(xml).byName
                },
                capabilities: this._parseAppLinkages(xml, urlPrefixes),
                layers: {
                    all: realLayers.list,
                    byId: realLayers.byId,
                    background: layerGroups.byId[ConfigurationParser.BACKGROUND_GROUP_ID].layers,
                    hazard: realLayers.hazard,
                    tree: layerTree,
                    list: this._getLayerTreeReferences(layerTree)
                },
                products: {
                    previewUrl: urlPrefixes.byId["Services Root"] + "prodview/html/proddisplay.jsp"
                }
            };
        }
    },

    _parseProjections: {
        value: function (xml) {
            var projections = {},
                nodes = xml.querySelectorAll("CoordSystems > EpsgCoordSys"),
                id, srid, units, i, n;
            // Get the projections using existing projection objects if possible
            // but creating new ones if necessary.
            for (i = 0, n = nodes.length; i < n; ++i) {
                id = nodes[i].getAttribute("Id");
                srid = nodes[i].getAttribute("EpsgId");
                units = Units.forId(nodes[i].getAttribute("Units"));
                if (!srid) {
                    console.warn("Missing SRID for projection " + id);
                } else if (!units) {
                    console.warn("Unknown units for projection " + id + " -", nodes[i].getAttribute("Units"));
                } else {
                    projections[id] = Projection.forSridAndUnits(srid, units) ||
                                      Projection.withSridAndUnits(srid, units);
                }
            }
            // Returns a map of the projections by projection ID.
            return {byId: projections};
        }
    },

    _parseUrlPrefixes: {
        value: function (xml) {
            var prefixUrls = {},
                prependIds = {},
                nodes = xml.querySelectorAll("UrlPrefixes > UrlPrefix"),
                id, i, n;
            // Get the URL prefixes, and the IDs of prefixes to prepend to them.
            for (i = 0, n = nodes.length; i < n; ++i) {
                id = nodes[i].getAttribute("Id");
                prefixUrls[id] = nodes[i].getAttribute("Prefix");
                prependIds[id] = nodes[i].getAttribute("PrependUrlPrefixId");
            }
            // Recursively prepend prefixes for each URL prefix that needs it.
            for (id in prependIds) {
                prefixUrls[id] = this._prependPrefix(prefixUrls, prependIds, id);
            }
            // Returns a map of the URL prefixes by prefix ID.
            return {byId: prefixUrls};
        }
    },

    _prependPrefix: {
        value: function (prefixUrls, prependIds, prefixId) {
            var prependId = prependIds[prefixId];
            if (prependId) {
                delete prependIds[prefixId];
                prefixUrls[prependId] = this._prependPrefix(prefixUrls, prependIds, prependId);
            }
            return prependId ? prefixUrls[prependId] + prefixUrls[prefixId] : prefixUrls[prefixId];
        }
    },

    _parseLayerGroups: {
        value: function (xml) {
            var groups = {},
                nodes = xml.querySelectorAll("Layer01Groups > Layer01Group"),
                group, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                group = {};
                group.id = nodes[i].getAttribute("Id");
                group.layers = [];
                groups[group.id] = group;
            }
            return {byId: groups};
        }
    },

    _parseMapServers: {
        value: function (xml, urlPrefixes) {
            var servers = {},
                nodes = xml.querySelectorAll("MapServers > MapServer"),
                server, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                server = {};
                server.id = nodes[i].getAttribute("Id");
                server.url = urlPrefixes.byId[nodes[i].getAttribute("UrlPrefixId")];
                server.protocol = nodes[i].getAttribute("Protocol");
                server.protocolVersion = nodes[i].getAttribute("ProtocolVersion");
                server.softwareName = nodes[i].getAttribute("Software");
                servers[server.id] = server;
            }
            return {byId: servers};
        }
    },

    _parseMapServices: {
        value: function (xml, authorities, user, servers, projections) {
            // Returns only the map services accessible by the specified user.
            var services = {},
                nodes = xml.querySelectorAll("MapServices > MapService"),
                restrictions = this._parseRestrictions(xml, authorities, user),
                id, server, service, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                id = nodes[i].getAttribute("Id");
                server = !restrictions.byMapServiceId[id] && servers.byId[nodes[i].getAttribute("MapServerId")];
                if (server) {
                    service = DataService.mainService.createDataObject(MapService.TYPE);
                    service.url = server.url + nodes[i].getAttribute("Name");
                    service.protocol = server.protocol;
                    service.protocolVersion = server.protocolVersion;
                    service.softwareName = server.softwareName;
                    service.projection = projections.byId[nodes[i].getAttribute("CoordSysId")];
                    services[id] = service;
                    if (server.protocol && !service.protocol) {
                        console.warn("Unknown protocol - " + server.protocol);
                    }
                    if (!service.projection) {
                        console.warn("Unknown projection - " + nodes[i].getAttribute("CoordSysId"));
                    }
                }
            }
            return {byId: services};
        }
    },

    _parseRestrictions: {
        value: function (xml, authorities, user) {
            // Flags the map services not accessible by the specified user.
            var restrictions = {byMapServiceId: {}},
                nodes = xml.querySelectorAll("MapServices > MapService > AuthRestriction"),
                authority, role, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                authority = authorities.byId[nodes[i].getAttribute("AuthServiceId")];
                role = nodes[i].getAttribute("Role");
                if (user.authority !== authority || !user.roles[role]) {
                    restrictions.byMapServiceId[nodes[i].parentNode.getAttribute("Id")] = true;
                }
            }
            return restrictions;
        }
    },

    _parseRealLayers: {
        value: function (xml, urlPrefixes, mapServices, layerGroups) {
            // Returns both a map of the layers accessible through the specified
            // map services and a list of them.
            var layers = {byId: {}, list: []},
                nodes = xml.querySelectorAll("MapLayers > *"),
                layer, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                layer = this._parseRealLayer(nodes[i], mapServices, urlPrefixes, layerGroups);
                if (layer) {
                    layers.byId[layer.id] = layer;
                    layers.list.push(layer);
                    layer.depth = i;
                    if (layer.mapService.protocol === Protocol.HAZARD) {
                        layers.hazard = layer;
                    } else if (layer.mapService.protocol === Protocol.SOCIAL) {
                        layers.social = layer;
                    } else if (layer.mapService.protocol === Protocol.CAMERA) {
                        layers.camera = layer;
                    }
                }
            }
            return layers;
        }
    },

    _parseRealLayer: {
        value: function (node, mapServices, urlPrefixes, layerGroups) {
            // Create a layer only if it's not virtual and if its map service
            // is one of those accessible by the current user.
            var type, layer, service, scale, swatch;
            if (node.nodeName !== "VirtualLayer") {
                service = mapServices.byId[node.getAttribute("MapServiceId")];
                if (service) {
                    type = (service.protocol === Protocol.HAZARD) ? HazardLayer.TYPE : Layer.TYPE;
                    layer = DataService.mainService.createDataObject(type);
                    layer.mapService = service;
                    layer.mapServiceLayerId = node.getAttribute("MapServiceLayerId");
                    layer.id = node.getAttribute("Id");
                    layer.group = layerGroups.byId[node.getAttribute("Layer01GroupId")];
                    if (layer.group) {
                        layer.group.layers.push(layer);
                        layer.isBackground = layer.group.id === ConfigurationParser.BACKGROUND_LAYERS_ID;
                    }
                    layer.name = node.getAttribute("Name");
                    if (node.hasAttribute("DefaultTransparency")) {
                        layer.opacity = 1 - Number(node.getAttribute("DefaultTransparency")) / 100;
                    }
                    if (node.hasAttribute("ClusterBehavior")) {
                        layer.clusterBehavior = this._parseClusteringBehavior(node.getAttribute("ClusterBehavior"));
                    } else if (node.tagName === "AgsLayer" || node.tagName === "CamsPointLayer" || node.tagName === "WfsPointLayer" || node.tagName === "WfsLineLayer" || node.tagName === "WfsPolygonLayer") {
                        layer.clusterBehavior = Layer.ClusteringBehavior.CHANGEABLE;
                    }
                    layer.description = node.getAttribute("Description");
                    scale = node.getAttribute("FeatureScaleLimit");
                    layer.featureMinZoom = String(scale) === "0" ? Infinity : GeometryUtilities.zoomLevelForScale(Number(scale));
                    layer.areFeaturesGlobal = node.getAttribute("RequestGlobalFeatures") === "true";
                    swatch = node.getAttribute("Swatch");
                    if (swatch && swatch !== "not applicable") {
                        layer.legendUrl = urlPrefixes.byId[node.getAttribute("SwatchUrlPrefixId")] + swatch;
                    }
                    if (node.hasAttribute("TimeHelperServiceUrl") && node.hasAttribute("TimeHelperServiceUrlPrefixId")) {
                        layer.timeServiceUrl = urlPrefixes.byId[node.getAttribute("TimeHelperServiceUrlPrefixId")] + node.getAttribute("TimeHelperServiceUrl");
                    }
                    service.layers[layer.mapServiceLayerId || layer.name] = layer;
                }
            }
            return layer;
        }
    },

    _parseClusteringBehavior: {
        value: function (string) {
            return string === "on" || string === "off" ? Layer.ClusteringBehavior.CHANGEABLE :
                   string === "never" ?                  Layer.ClusteringBehavior.ALWAYS_OFF :
                   string === "always" ?                 Layer.ClusteringBehavior.ALWAYS_ON :
                                                         console.warn("Unknown cluster behavior -", string);
        }
    },

    _parseVirtualLayers: {
        value: function (xml, realLayers) {
            // Returns references for all virtual layer that have at least one
            // reference to one of the specified real layers.
            var layers = {referenceById: {}},
                nodes = xml.querySelectorAll("MapLayers > VirtualLayer > MapLayerRef"),
                layer, parent, reference, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                layer = realLayers.byId[nodes[i].getAttribute("MapLayerId")];
                if (layer) {
                    if (nodes[i].parentNode !== parent) {
                        parent = nodes[i].parentNode;
                        reference = new LayerReference();
                        reference.name = parent.getAttribute("Name");
                        layers.referenceById[parent.getAttribute("Id")] = reference;
                    }
                    reference.layers.push(layer);
                }
            }
            return layers;
        }
    },

    _parseTableOfContent: {
        value: function (xml, realLayers, virtualLayers) {
            // Returns references for all the specified real or virtual layers
            // that are in a table of contents.
            var tableOfContents = {referenceById: {}},
                nodes = xml.querySelectorAll("TocLayers > TocLayer"),
                 layer, reference, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                layer = realLayers.byId[nodes[i].getAttribute("MapLayerId")];
                if (layer) {
                    reference = new LayerReference();
                    reference.layers.push(layer);
                } else {
                    reference = virtualLayers.referenceById[nodes[i].getAttribute("MapLayerId")];
                }
                if (reference) {
                    reference.isEnabled = nodes[i].getAttribute("DefaultVisible") === "true";
                    tableOfContents.referenceById[nodes[i].getAttribute("Id")] = reference;
                }
            }
            return tableOfContents;
        }
    },

    _parseLayerFolders: {
        value: function (xml) {
            // Returns both a map and a list of the folders, with the folders
            // empty and not loaded with their subfolders or layer references.
            var folders = {byId: {}, list: []},
                nodes = xml.querySelectorAll("TocFolders > TocFolder"),
                folder, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                folder = new LayerFolder();
                folder.name = nodes[i].getAttribute("Caption");
                folder.isExpanded = nodes[i].getAttribute("DefaultOpen") || false;
                folder.isSelectable = nodes[i].getAttribute("DisplayFolderCheckbox") || false;
                folders.byId[nodes[i].getAttribute("Id")] = folder;
                folders.list.push(folder);
            }
            return folders;
        }
    },

    _parseFormatters: {
        value: function (xml) {
            var formatters = {},
                nodes = xml.querySelectorAll("ValueFormatters > ValueFormatter"),
                formatter, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                formatter = Formatter.withXml(nodes[i]);
                if (formatter) {
                    formatters[nodes[i].getAttribute("Id")] = formatter;
                } else {
                    console.warn("Unknown value formatter type -", nodes[i]);
                }
            }
            return {byId: formatters};
        }
    },

    _parseLayerFields: {
        value: function (xml, layers, formatters) {
            var nodes = xml.querySelectorAll("MapLayers > * > Fields > Field"),
                layer, name, alias, field, i, n, fieldFilter;
            for (i = 0, n = nodes.length; i < n; ++i) {
                layer = layers.byId[nodes[i].parentNode.parentNode.getAttribute("Id")];
                name = layer && nodes[i].getAttribute("FieldName");
                alias = name && nodes[i].getAttribute("FieldAlias") || name;
                if (name) {
                    field = new Field();
                    field.name = alias || name;
                    field.propertyName = name;
                    field.formatter = formatters.byId[nodes[i].getAttribute("ValueFormatterId")];
                    fieldFilter = nodes[i].querySelector("FieldFilter");
                    layer.featureFieldConfiguration[name] = {
                        field: field,
                        isDetail: nodes[i].getAttribute("DisplayWithAttributes") !== "false",
                        isSummary: nodes[i].getAttribute("DisplayWithMapTips") === "true",
                        isFilter: fieldFilter !== null
                    };
                    if (layer.featureFieldConfiguration[name].isFilter) {
                        // TODO: Add support for Starting and Ending.
                        layer.featureFieldConfiguration[name].filter = {
                            minimum: fieldFilter.getAttribute("Minimum"),
                            maximum: fieldFilter.getAttribute("Maximum"),
                            string: fieldFilter.getAttribute("String")
                        }
                    }

                }
            }
        }
    },

    _buildLayerTrees: {
        value: function (xml, folders, tableOfContents) {
            // Returns the tree to be shown in the layers panel. There will be
            // several trees and some folders (most notably those used to hold
            // the list of layers associated with each hazard type) will not be
            // in the layers panel tree.
            this._addLayerFolderChildren(xml, folders, tableOfContents);
            this._reorderLayerFolderChildren(folders);
            this._cloneDuplicateLayerFolderChildren(folders);
            this._removeEmptyLayerFolders(folders);
            return this._getLayerTreeRoot(xml, folders);
        }
    },

    _addLayerFolderChildren: {
        value: function (xml, folders, tableOfContents) {
            // Add subfolders and layer references to each folder. The parent
            // pointer of folder children are not set because a given child may
            // end up in several parent folders. This will be cleaned up in
            // _cloneDuplicateLayerFolderChildren().
            var nodes = xml.querySelectorAll("TocFolders > TocFolder > TocFolderEntry, TocFolders > TocFolder > TocLayerEntry"),
                folder, child, i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                folder = folders.byId[nodes[i].parentNode.getAttribute("Id")];
                if (folder) {
                    if (nodes[i].nodeName === "TocFolderEntry") {
                        child = folders.byId[nodes[i].getAttribute("TocFolderId")];
                    } else if (nodes[i].nodeName === "TocLayerEntry") {
                        child = tableOfContents.referenceById[nodes[i].getAttribute("TocLayerId")];
                    }
                    if (child) {
                        folder.children.push(child);
                    }
                }
            }
        }
    },

    _reorderLayerFolderChildren: {
        value: function (folders) {
            // Folder children are listed in reverse order in the configuration
            // file so they must be reversed. Instead of reversing the children
            // here they could have been inserted in the right order in
            // _addLayerFolderChildren() by using splice(0, 0, child) instead of
            // push(child), but that would yield O(n^2) performance. The push()
            // + reverse() approach yields a more acceptable O(n) performance.
            var i, n;
            for (i = 0, n = folders.list.length; i < n; ++i) {
                folders.list[i].children.reverse();
            }
        }
    },

    _cloneDuplicateLayerFolderChildren: {
        value: function (folders) {
            // Clone all entries that ended up in several parent folders. Also
            // sets the parent pointer of all folder children.
            var folder, child, i, j, m, n;
            for (i = 0, n = folders.list.length; i < n; ++i) {
                folder = folders.list[i];
                for (j = 0, m = folder.children.length; j < m; ++j) {
                    child = folder.children[j];
                    if (child.parent) {
                        child = folder.children[j] = this._cloneDuplicateLayerFolderChild(child);
                    }
                    child.parent = folder;
                }
            }
        }
    },

    _cloneDuplicateLayerFolderChild: {
        value: function (child) {
            // Clone either a folder or a layer reference.
            var clone;
            if (child.children) {
                clone = new LayerFolder();
                clone.name = child.name;
                clone.isExpanded = child.isExpanded;
                clone.isSelectable = child.isSelectable;
                clone.children.push.apply(clone.children, child.children);
            } else if (child.parent) {
                clone = new LayerReference();
                clone.name = child.name;
                clone.layers.push.apply(clone.layers, child.layers);
            }
            return clone;
        }
    },

    _removeEmptyLayerFolders: {
        value: function (folders) {
            // This potentially has O(n^2) performance but that shouldn't be an
            // issue for the small number of empty folders encountered.
            var folder, parent, i, n;
            for (i = 0, n = folders.list.length; i < n; ++i) {
                folder = folders.list[i];
                while (!folder.children.length && folder.parent) {
                    parent = folder.parent;
                    parent.children.splice(parent.children.indexOf(folder), 1);
                    folder.parent = null;
                    folder = parent;
                }
            }
        }
    },

    _getLayerTreeRoot: {
        value: function (xml, folders) {
            var tocs = xml.querySelector("Tocs");
                toc = xml.querySelector("Tocs > Toc[Id=\"" + tocs.getAttribute("DefaultTocId") + "\"]");
            return folders.byId[toc.getAttribute("TocRootFolderId")];
        }
    },

    _getLayerTreeReferences: {
        value: function (node, array, set) {
            // Build a list of references recursively, ignoring duplicate
            // references.
            var i, n;
            array = array || [];
            set = set || new Set();
            if (node.layers && !this._isLayerReferenceRecorded(set, node)) {
                this._recordLayerReference(set, node);
                array.push(node);
            }
            for (i = 0, n = node.children ? node.children.length : 0; i < n; ++i) {
                this._getLayerTreeReferences(node.children[i], array, set);
            }
            return array;
        }
    },

    _isLayerReferenceRecorded: {
        value: function (set, reference) {
            // A reference is recorded if all of its layers are in the set.
            var i = reference.layers.length - 1;
            while (i >= 0) {
                i = set.has(reference.layers[i]) ? i - 1 : -2;
            }
            return i !== -2;
        }
    },

    _recordLayerReference: {
        value: function (set, reference) {
            // Add all of the layers of the reference to the set.
            var i = reference.layers.length - 1;
            while (i >= 0) {
                set.add(reference.layers[i--]);
            }
        }
    },

    _parseAppIds: {
        value: function (xml) {
            var node = xml.querySelector("AppLinkages");
            return node.getAttribute("AppIds");
        }
    },

    _parseDefaultSummaryFieldCount: {
        value: function (xml) {
            var node = xml.querySelector("Map > FieldDisplay");
            return Number(node.getAttribute("MapTipDefaultFieldCount"));
        }
    },

    _parseIgnoredFields: {
        value: function (xml) {
            var ignored = {},
                nodes = xml.querySelectorAll("Map > FieldDisplay > IgnoredField"),
                i, n;
            for (i = 0, n = nodes.length; i < n; ++i) {
                ignored[nodes[i].getAttribute("FieldName")] = true;
            }
            return {byName: ignored};
        }
    },

    _parseAppLinkages: {
        value: function (xml, urlPrefixes) {
            var linkages = xml.querySelector("AppLinkages");
            return {
                areaBrief: {
                    url: this._parseNodeUrl(linkages, "RRAppLinkage", urlPrefixes),
                    toolTip: this._parseNodeValue(linkages, "RRAppLinkage", "ToolTip")
                },
                icons: {
                    url: this._parseNodeUrl(linkages, "CommonIconLargeRepository", urlPrefixes)
                }
            };
        }
    },

    _parseNodeUrl: {
        value: function (root, selector, urlPrefixes) {
            var node = root.querySelector(selector);
            return urlPrefixes.byId[node.getAttribute("UrlPrefixId")] + node.getAttribute("Url");
        }
    },

    _parseNodeValue: {
        value: function (root, selector, key) {
            var node = root.querySelector(selector);
            return node.getAttribute(key);
        }
    }

}, {

    BACKGROUND_GROUP_ID: {
        value: "Background Layers"
    }

});
