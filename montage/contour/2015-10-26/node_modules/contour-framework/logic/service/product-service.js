var RestService = require("montage-data/logic/service/rest-service").RestService,
    Product = require("logic/model/product").Product,
    moment = require("moment-timezone");

/**
 * Provides product data.
 *
 * @class
 * @extends external:RestService
 */
exports.ProductService = RestService.specialize(/** @lends ProductService.prototype */{

    /***************************************************************************
     * Basic property
     */

    type: {
        value: Product.TYPE
    },

    /***************************************************************************
     * Entry points
     */

    fetchRawData: {
        value: function (stream) {
            var self = this,
                hazard = stream.selector.criteria.hazard,
                url = hazard.layer.mapService.url + "services/products/1/json/get_product_list",
                body = "app_ids=18&hazard_id=" + hazard.id;
            this.fetchRestData(url, this.FORM_URL_ENCODED_CONTENT_TYPE_HEADER, body).then(function (data) {
                self.addRawData(stream, data, hazard);
                self.rawDataDone(stream, hazard);
                return null;
            });
        }
    },

    mapRawData: {
        value: function (product, data, hazard) {
            // Properties (ordered alphabetically).
            // TODO:
            //     - Replace product.type string with an Enumeration.
            //     - Replace product.securityFlag string with an Enumeration.
            //     - Replace product.user string with a User object.
            //     - Make product.isHidden a boolean rather than a string.
            product.comment = data.comment_Text;
            product.creationDate = new moment(Number(data.create_Date));
            product.fileName = data.filename;
            product.geolocations = data.geo_Locations;
            product.hazard = hazard;
            product.id = data.product_ID;
            product.isHidden = data.is_Hidden;
            product.name = data.title;
            product.organizationAcronym = data.organization_acronym;
            product.parentId = data.parent_ID;
            product.securityFlag = data.security_Flag;
            product.timelineDate = new moment(Number(data.timeline_Date));
            product.type = type = Product.Type.forId(data.product_Type);
            product.updateDate = new moment(Number(data.update_Date));
            product.updateUser = data.update_User;
            product.user = data.user_ID;
            // Possibly unused properties (ordered alphabetically).
            // TODO: Investigate and remove them if possible.
            product.appId = data.app_ID;
            product.appIds = data.app_IDs;
            product.organizationId = data.org_ID;
            product.organizationIds = data.org_IDs;
            // Legacy properties (ordered alphabetically).
            // TODO: Remove their use in code and then remove them here.
            product.commentText = data.comment_Text;
            product.geoLocations = data.geo_Locations;
            product.orgAcronym = data.organization_acronym;
            product.orgId = data.org_ID;
            product.orgIds = data.org_IDs;
            // Derived properties (ordered alphabetically).
            if (product.type.id === "FOLDER_PRODUCT") {
                product.children = product.children || [];
                product.children.length = 0;
            } else if (product.type.id === "TEXT_PRODUCT") {
                product.text = data.data;
                delete product.children;
            } else if (product.type.id === "URL_PRODUCT") {
                product.url = data.data;
                delete product.children;
            } else {
                delete product.children;
            }
            // Unused data (ordered alphabetically).
            // TODO: Determine whether any of these should be used.
            //     filename: null
            //     suffix: "url"
        }
    },

    rawDataDone: {
        value: function (stream, hazard) {
            var products = {list: stream.data, byId: {}},
                i, n;
            for (i = 0, n = products.list.length; i < n; i += 1) {
                products.byId[products.list[i].id] = products.list[i];
            }
            for (i = 0, n = products.list.length; i < n; i += 1) {
                parent = products.list[i].parentId && products.byId[products.list[i].parentId];
                delete products.list[i].parentId;
                if (parent && parent.children) {
                    products.list[i].parent = parent;
                    parent.children.push(products.list[i]);
                }
            }
            RestService.prototype.rawDataDone.call(this, stream);
        }
    }

});
