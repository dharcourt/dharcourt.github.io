var DataService = require("montage-data/logic/service/data-service").DataService,
    DataSelector = require("montage-data/logic/service/data-selector").DataSelector,
    Tile = require("logic/model/tile").Tile,
    moment = require("moment-timezone");

/**
 * Provides layer tile data.
 *
 * @class
 * @extends external:DataService
 */
exports.TileService = DataService.specialize(/** @lends TileService.prototype */{

    /***************************************************************************
     * Basic property
     */

    type: {
        value: Tile.TYPE
    },

    /***************************************************************************
     * Entry points
     */

    fetchRawData: {
        value: function (stream) {
            var tile = stream.selector.criteria.tile,
                self, layer, cache, cached;
            if (!tile.image) {
                self = this;
                layer = stream.selector.criteria.layer;
                cache = this._getFetchCache(layer, tile.id);
                this._getImageLoadPromise(cache, tile, layer).then(function () {
                    tile.image = cache.image;
                    tile.src = cache.image.src;
                    self.rawDataDone(stream);
                });
            }
        }
    },

    /***************************************************************************
     * Images
     */

    _getImageLoadPromise: {
        value: function (cache, tile, layer) {
            var self = this;
            if (!cache.promise && !cache.image) {
                cache.promise = this._getImageUrlPromise(tile, layer).then(function (url) {
                    cache.image = new Image();
                    return self._makeImageLoadPromise(cache.image, url);
                }).then(function () {
                    delete cache.promise;
                    return null;
                });
            }
            return cache.promise || this.nullPromise;
        }
    },

    _getImageUrlPromise: {
        value: function (tile, layer) {
            return DataService.mainService.getObjectData(layer, "geometryType").then(function () {
                var url;
                if (layer.mapService.protocol.makeUrlWithTileAndLayer) {
                    url = layer.mapService.protocol.makeUrlWithTileAndLayer(tile, layer);
                } else {
                    console.warn("-------------------------");
                    console.warn("Unable to request tile for this protocol (", layer.mapService.protocol, ")");
                    console.warn("Method makeUrlWithTileAndLayer is not supported.");
                }
                return url || Promise.reject(null);
            });
        }
    },

    _makeImageLoadPromise: {
        value: function (image, src) {
            return new Promise(function (resolve, reject) {
                image.onload = function () { resolve(null); };
                image.setAttribute('crossOrigin', 'anonymous');
                image.src = src;
            });
        }
    },

    /***************************************************************************
     * Caching
     */

    _getFetchCache: {
        value: function (layer, tileId) {
            var cache = this._fetchCaches && this._fetchCaches.get(layer) || {};
            if (!cache[tileId]) {
                this._fetchCaches = this._fetchCaches || new Map();
                this._fetchCaches.set(layer, cache);
                cache[tileId] = cache[tileId] || {};
            }
            return cache[tileId];
        }
    }

}, {

    /***************************************************************************
     * Class method
     */

    /**
     * @returns {external:Promise} - A promise fulfilled when the tile's image
     * has been fetched.
     */
    fetchTileImage: {
        value: function (tile, layer) {
            return DataService.mainService.fetchData(DataSelector.withTypeAndCriteria(Tile.TYPE, {
                tile: tile,
                layer: layer
            }));
        }
    }

});
