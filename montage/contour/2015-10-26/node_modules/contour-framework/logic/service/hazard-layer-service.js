var RestService = require("montage-data/logic/service/rest-service").RestService,
    DataSelector = require("montage-data/logic/service/data-selector").DataSelector,
    Enumeration = require("montage-data/logic/model/enumeration").Enumeration,
    Field = require("logic/model/field").Field,
    Hazard = require("logic/model/hazard").Hazard,
    HazardLayer = require("logic/model/hazard-layer").HazardLayer;

/**
 * Provides hazard layer configuration data.
 *
 * @class
 * @extends external:RestService
 */
exports.HazardLayerService = RestService.specialize(/** @lends HazardLayerService.prototype */{

    /***************************************************************************
     * Configuration
     */

    iconUrl: {
        value: undefined
    },

    bundledTypesUrl: {
        value: undefined
    },

    /***************************************************************************
     * Basic property
     */

    type: {
        value: HazardLayer.TYPE
    },

    /***************************************************************************
     * Entry points
     */

    getPropertyData: {
        value: function (layer, propertyName) {
            var getFields = this._fieldsPropertyNames[propertyName],
                getHazards = this._hazardsPropertyNames[propertyName],
                getTypes = this.constructor._TypeType.forPropertyName(propertyName),
                getUrl = propertyName === "url";
            return getFields ?     this._getFields(layer) :
                   getHazards ?    this._getHazards(layer) :
                   getTypes ?      this._getTypes(layer, propertyName) :
                   getUrl ?        this._getUrl(layer) :
                                   this.nullPromise;
        }
    },

    fetchRawData: {
        value: function (stream) {
            var criteria = stream.selector.criteria;
            if (criteria.isForType && criteria.layer.url) {
                this._fetchTypes(stream, criteria.layer, criteria.propertyName);
            }
        }
    },

    /***************************************************************************
     * Categories/severities/types
     */

    _getTypes: {
        value: function (layer, propertyName) {
            return this.fetchPropertyData(HazardLayer.TYPE, layer, propertyName, "url", {
                isForType: true,
                layer: layer,
                propertyName: propertyName
            });
        }
    },

    _fetchTypes: {
        value: function (stream, layer, propertyName) {
            var type = this.constructor._TypeType.forPropertyName(propertyName);
            return this.bundledTypesUrl ? this._fetchBundledTypes(stream, layer, type) :
                                          this._fetchSeparateTypes(stream, layer, type);
        }
    },

    _fetchBundledTypes: {
        value: function (stream, layer, type) {
            var self = this;
            return new Promise(function (resolve, reject) {
                resolve(self._bundledTypesData || self.fetchRestDataWithoutCredentials(self.bundledTypesUrl));
            }).then(function (data) {
                return data || {hazardCategories: [], hazardSeverities: [], hazardTypes: []};
            }).then(function (data) {
                var promises, types, id, name, i, n;
                self._bundledTypesData = data;
                types = data[type.propertyName];
                for (i = 0, n = types.length; i < n; ++i) {
                    id = types[i].id;
                    name = types[i].name;
                    layer[type.propertyName].push(type.constructor.forId(id) || type.constructor.create(id, name));
                    if (type.fetchIcons) {
                        promises = promises || [];
                        promises.push(self._fetchBundledTypeIcon(layer[type.propertyName][i], types[i].iconSrc));
                    }
                }
                return promises ? Promise.all(promises) : self.nullPromise;
            }).then(function () {
                self.rawDataDone(stream);
            });
        }
    },

    _fetchBundledTypeIcon: {
        value: function (type, src) {
            return new Promise(function (resolve, reject) {
                type.iconImage = new Image();
                type.iconImage.onload = function () {
                    resolve(null);
                };
                type.iconImage.src = src;
            });
        }
    },

    _generateBundledData: {
        value: function (hazardLayer) {
            var names = ["hazardCategories", "hazardSeverities", "hazardTypes"];
            this.rootService.getObjectData(hazardLayer, names[0], names[1], names[2]).then(function () {
                // Generate the data.
                var data = {hazardCategories: [], hazardSeverities: [], hazardTypes: []},
                    i, j, m, n;
                for (i = 0, n = names.length; i < n; i += 1) {
                    types = hazardLayer[names[i]];
                    for (j = 0, m = types.length; j < m; j += 1) {
                        data[names[i]].push({
                            id: types[j].id,
                            name: types[j].name,
                            iconSrc: types[j].iconImage && types[j].iconImage.src
                        });
                    }
                }
                // Get the data somewhere where it can be copied and pasted.
                window.setTimeout(function () {
                    document.body.textContent = "";
                    for (i = 0, n = document.styleSheets.length; i < n; i += 1) {
                        for (j = document.styleSheets[i].cssRules.length - 1; j >= 0; j -= 1) {
                            document.styleSheets[i].deleteRule(j);
                        }
                    }
                    document.body.textContent = JSON.stringify(data);
                }, 1000);
            });
        }
    },

    _fetchSeparateTypes: {
        value: function (stream, layer, type) {
            var self = this;
            return this.fetchRestData(layer.url + type.url).then(function (data) {
                return data || [];
            }).then(function (data) {
                var promises, id, name, i, n;
                for (i = 0, n = data.length; i < n; ++i) {
                    id = data[i][type.name + "_id"];
                    name = data[i][type.name + "_name"];
                    layer[type.propertyName].push(type.constructor.forId(id) || type.constructor.create(id, name));
                    if (type.fetchIcons) {
                        promises = promises || [];
                        promises.push(self._fetchSeparateTypeIcon(layer[type.propertyName][i], data[i][type.name + "_icon"]));
                    }
                }
                return promises ? Promise.all(promises) : self.nullPromise;
            }).then(function () {
                self.rawDataDone(stream);
            });
        }
    },

    _fetchSeparateTypeIcon: {
        value: function (type, iconName) {
            var self = this;
            return new Promise(function (resolve, reject) {
                var request = new XMLHttpRequest();
                request.open("get", self.iconUrl + iconName, true);
                request.responseType = "arraybuffer";
                request.onload = function () {
                    var string = String.fromCharCode.apply(null, new Uint8Array(request.response));
                    type.iconImage.src = "data:image/png;base64," + window.btoa(string);
                };
                type.iconImage = new Image();
                type.iconImage.onload = function () {
                    resolve(null);
                };
                request.send()
            });
        }
    },

    /***************************************************************************
     * Fields
     */

    _fieldsPropertyNames: {
        value: {
            _featureFields_all: true,
            _featureFields_detail: true,
            _featureFields_summary: true
        }
    },

    //[TJ] (10/20) Hack formatter to support the fields created in
    // the _getFields() function below so the application can interact
    // with hazard fields in the usual way. Eventually hazard layer fields
    // will be prepared from the configuration.
    _hazardFieldFormatter: {
        value: {
            format: function (value) {
                return value ? value.name ? value.name : value.format ? value.format("M.DD.YYYY H\\h:mm\\m") : value : value;
            }
        }
    },

    _getFields: {
        value: function (layer) {
            if (layer.featureFields.all.length === 0) {
                var fields = [
                    Field.create("Name", "name"),
                    Field.create("Type", "type"),
                    Field.create("Severity", "severity"),
                    Field.create("Status", "status"),
                    Field.create("Category", "category"),
                    Field.create("Reported", "reportDate"),
                    Field.create("Updated", "updateDate"),
                    Field.create("Number of Products", "productCount"),
                    Field.create("Latitude", "latitude"),
                    Field.create("Longitude", "longitude")
                ], i, len;
                for (i = 0, len = fields.length; i < len; ++i) {
                    fields[i].formatter = this._hazardFieldFormatter;
                }
                Array.prototype.push.apply(layer.featureFields.all, fields);
                Array.prototype.push.apply(layer.featureFields.detail, fields);
                Array.prototype.push.apply(layer.featureFields.summary, fields);
            }
            return this.nullPromise;
        }
    },

    /***************************************************************************
     * Hazards
     */

    _hazardsPropertyNames: {
        value: {
            _features_all: true,
            _features_visible: true,
            hazards: true
        }
    },

    _getHazards: {
        value: function (layer) {
            var self = this;
            return this.rootService.fetchData(DataSelector.withTypeAndCriteria(Hazard.TYPE, {
                layer: layer
            })).then(function (hazards) {
                self.spliceWithArray(layer.features.all, hazards);
                return null;
            });
        }
    },

    /***************************************************************************
     * URL
     */

    _getUrl: {
        value: function (layer) {
            layer.url = layer.mapService.url + "services/hazards/1/json/";
            return this.nullPromise;
        }
    }

}, {

    /***************************************************************************
     * Categories/severities/types
     */

    _TypeType: {
        get: Enumeration.getterFor("__TypeType", "propertyName", "name", "url", "constructor", "fetchIcons", {
            CATEGORIES: ["hazardCategories", "category", "get_hazard_categories", Hazard.Category, false],
            SEVERITIES: ["hazardSeverities", "severity", "get_hazard_severities", Hazard.Severity, false],
            TYPES: ["hazardTypes", "type", "get_hazard_types", Hazard.Type, true]
        })
    }

});
