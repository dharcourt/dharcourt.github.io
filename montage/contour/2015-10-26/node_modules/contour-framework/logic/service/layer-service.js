var RestService = require("montage-data/logic/service/rest-service").RestService,
    Bounds = require("logic/model/bounds").Bounds,
    ClassBreaksRenderer = require("logic/map/class-breaks-renderer").ClassBreaksRenderer,
    DataService = require("montage-data/logic/service/data-service").DataService,
    EsriGeometryType = require("logic/map/esri-geometry-type").EsriGeometryType,
    Feature = require("logic/model/feature").Feature,
    Field = require("logic/model/field").Field,
    GeometryType = require("logic/model/geometry-type").GeometryType,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    Layer = require("logic/model/layer").Layer,
    Protocol = require("logic/model/protocol").Protocol,
    Renderer = require("logic/map/renderer").Renderer,
    SimpleRenderer = require("logic/map/simple-renderer").SimpleRenderer,
    UniqueValueRenderer = require("logic/map/unique-value-renderer").UniqueValueRenderer,
    moment = require("moment-timezone");

/**
 * Provides layer configuration data.
 *
 * @class
 * @extends external:RestService
 */
exports.LayerService = RestService.specialize(/** @lends LayerService.prototype */{

    /***************************************************************************
     * Configuration
     */

    ignoredFeatureFields: {
        value: {}
    },

    defaultSummaryFeatureFieldCount: {
        value: 3
    },

    /***************************************************************************
     * Basic property
     */

    type: {
        value: Layer.TYPE
    },

    /***************************************************************************
     * Entry points
     */

    getPropertyData: {
        value: function (layer, propertyName) {
            // TODO [Charles]: Remove this method when the parent class'
            // implementation is changed to do all this based entirely on the
            // corresponding relationship descriptors.
            var isArcgis = layer.mapService.protocol === Protocol.ARCGIS,
                getAdditionalProperties = isArcgis && this._additionalPropertiesPropertyNames[propertyName],
                getAllFeatures = isArcgis && propertyName === "_features_all",
                getVisibleFeatures = isArcgis && propertyName === "_features_visible",
                getAvailableTimes = propertyName === "availableTimes",
                getUrl = isArcgis && propertyName === "url";
            return getAdditionalProperties ? this._getAdditionalProperties(layer) :
                getAllFeatures ?          this._getAllFeatures(layer) :
                getVisibleFeatures ?      this._getVisibleFeatures(layer) :
                getAvailableTimes ?       this._getAvailableTimes(layer) :
                getUrl ?                  this._getUrls(layer.mapService) :
                                             this.nullPromise;
        }
    },

    fetchRawData: {
        value: function (stream) {
            var criteria = stream.selector.criteria;
            if (criteria.isForProperties && criteria.layer.url) {
                this._fetchAdditionalProperties(stream, criteria.layer);
            } else if (criteria.isForUrl && criteria.mapService.url) {
                this._fetchUrls(stream, criteria.mapService);
            } else if (criteria.isForAvailableTimes) {
                this._fetchAvailableTimes(stream, criteria.layer);
            }
        }
    },

    /***************************************************************************
     * Additional properties
     */

    _additionalPropertiesPropertyNames: {
        value: {
            _featureFields_all: true,
            _featureFields_detail: true,
            _featureFields_summary: true,
            canCluster: true,
            canSetTransparency: true,
            geometryType: true,
            initialBounds: true,
            renderer: true,
            type: true
        }
    },

    _getAdditionalProperties: {
        value: function (layer) {
            return this.fetchPropertyData(Layer.TYPE, layer, "additionalProperties", "url", {
                layer: layer,
                isForProperties: true
            });
        }
    },

    _fetchAdditionalProperties: {
        value: function (stream, layer) {
            var self = this;
            this.fetchRestData(layer.url && layer.url + "?f=json").then(function (data) {
                var rendererData = data.drawingInfo && data.drawingInfo.renderer;
                if (data) {
                    self._defineFeatureFields(layer, data.fields);
                    self._defineGeometryType(layer, data.type, data.geometryType);
                    self._defineRenderer(layer, rendererData && rendererData.type, rendererData);
                    self._defineZoomAndInitialBounds(layer, data.minScale, data.maxScale, data.extent);
                }
                self.rawDataDone(stream);
                return null;
            }).catch(function (error) {
                console.error(error.stack);
                self.rawDataDone(stream);
                return null;
            });
        }
    },

    _defineFeatureFields: {
        value: function (layer, fieldData) {
            var configuration, fields, i, n, filters;
            if (!layer.featureFields.all.length && fieldData) {
                for (i = 0, n = fieldData.length; i < n; ++i) {
                    configuration = this._getFeatureFieldConfiguration(layer, fieldData[i].name, fieldData[i].alias);
                    if (configuration.isFilter) {
                        if (!filters) {
                            filters = {};
                        }
                        // TODO [Charles]: Refactor to avoid switch.
                        switch (fieldData[i].type) {
                            case "esriFieldTypeDate":
                                filters[configuration.field.propertyName] = configuration.filter;
                                filters[configuration.field.propertyName].type = "date";
                                delete filters[configuration.field.propertyName].string;
                                break;
                            case "esriFieldTypeDouble":
                            case "esriFieldTypeFloat":
                            case "esriFieldTypeInteger":
                            case "esriFieldTypeSmallInteger":
                            case "esriFieldTypeSingle":
                                // TODO: Distinguish decimal from integer.
                                filters[configuration.field.propertyName] = configuration.filter;
                                filters[configuration.field.propertyName].type = "number";
                                if (filters[configuration.field.propertyName].minimum && !isNaN(filters[configuration.field.propertyName].minimum)) {
                                    filters[configuration.field.propertyName].minimum = parseFloat(filters[configuration.field.propertyName].minimum);
                                }
                                if (filters[configuration.field.propertyName].maximum && !isNaN(filters[configuration.field.propertyName].maximum)) {
                                    filters[configuration.field.propertyName].maximum = parseFloat(filters[configuration.field.propertyName].maximum);
                                }
                                delete filters[configuration.field.propertyName].string;
                                break;
                            case "esriFieldTypeString":
                                filters[configuration.field.propertyName] = configuration.filter;
                                filters[configuration.field.propertyName].type = "string";
                                delete filters[configuration.field.propertyName].minimum;
                                delete filters[configuration.field.propertyName].maximum;
                                break;
                            default:
                                // Prevent configuration.fields with
                                // unfilterable type from entering
                                // featureFields.filter. esriFieldTypeOID,
                                // esriFieldTypeGeometry, esriFieldTypeBlob,
                                // esriFieldTypeRaster, esriFieldTypeGUID,
                                // esriFieldTypeGlobalID.
                                configuration.isFilter = false;
                                break;
                        }
                        layer.featureCriteria._filters = filters;
                    }
                    this._pushIf(layer.featureFields.all, configuration.field, configuration.field);
                    this._pushIf(layer.featureFields.detail, configuration.isDetail, configuration.field);
                    this._pushIf(layer.featureFields.summary, configuration.isSummary, configuration.field);
                    this._pushIf(layer.featureFields.filter, configuration.isFilter, configuration.field);
                }
                if (!layer.featureFields.summary.length) {
                    fields = layer.featureFields.all.slice(0, this.defaultSummaryFeatureFieldCount);
                    this.spliceWithArray(layer.featureFields.summary, fields);
                }
            }
        }
    },

    _getFeatureFieldConfiguration: {
        value: function (layer, name, alias) {
            return this.ignoredFeatureFields[name] && {} ||
                   alias && this.ignoredFeatureFields[alias] && {} ||
                   layer.featureFieldConfiguration[name] ||
                   layer.featureFieldConfiguration[name.toUpperCase()] ||
                   layer.featureFieldConfiguration[name.toLowerCase()] ||
                   alias && layer.featureFieldConfiguration[alias] ||
                   alias && layer.featureFieldConfiguration[alias.toUpperCase()] ||
                   alias && layer.featureFieldConfiguration[alias.toLowerCase()] ||
                   this._makeDefaultFeatureFieldConfiguration(name, alias);
        }
    },

    _makeDefaultFeatureFieldConfiguration: {
        value: function (name, alias) {
            var configuration = {field: new Field(), isDetail: true};
            configuration.field.name = alias || name;
            configuration.field.propertyName = name;
            return configuration;
        }
    },

    _pushIf: {
        value: function (array, condition, item) {
            if (condition) {
                array.push(item);
            }
        }
    },

    _defineGeometryType: {
        value: function (layer, layerTypeData, geometryTypeData) {
            var type = layerTypeData === "Raster Layer" ?         GeometryType.RASTER :
                       layerTypeData === "Raster Catalog Layer" ? GeometryType.RASTER :
                       layerTypeData === "Feature Layer" ?        GeometryType.forEsriId(geometryTypeData) :
                                                                  null;
            if (type) {
                layer.geometryType = layer.geometryType || type;
            } else if (type === null) {
                console.warn("Unknown layer type -", layerTypeData);
            } else if (geometryTypeData) {
                console.warn("Unknown ESRI geometry type -", geometryTypeData);
            }
        }
    },

    _defineRenderer: {
        value: function (layer, typeData, rendererData) {
            var constructor = typeData === "simple" ?      SimpleRenderer :
                              typeData === "classBreaks" ? ClassBreaksRenderer :
                              typeData === "uniqueValue" ? UniqueValueRenderer :
                                                           null;
            if (constructor) {
                layer.renderer = layer.renderer || constructor.forDefinition(rendererData);
            } else if (typeData) {
                console.warn("Unknown renderer type -", typeData);
            }
            if (layer.renderer && layer.geometryType && !layer.renderer.geometryType) {
                layer.renderer.geometryType = EsriGeometryType[layer.geometryType.esriId];
            }
        }
    },

    _defineZoomAndInitialBounds: {
        value: function (layer, minScaleData, maxScaleData, extentData) {
            layer.minZoom = !layer.minZoom && maxScaleData && GeometryUtilities.zoomLevelForScale(maxScaleData);
            layer.maxZoom = !layer.maxZoom && minScaleData && GeometryUtilities.zoomLevelForScale(minScaleData);
            if (!layer.initialBounds && extentData && layer.mapService.projection) {
                layer.initialBounds = Bounds.withCoordinates(
                    extentData.xmin, extentData.ymin,
                    extentData.xmax, extentData.ymax,
                    layer.mapService.projection);
            }
        }
    },

    /***************************************************************************
     * Features
     */

    _getAllFeatures: {
        value: function (layer) {
            var self = this;
            return this.fetchPropertyData(Feature.TYPE, layer, "allFeatures", "url", "geometryType", {
                layer: layer,
                bounds: Bounds.EARTH
            }).then(function (features) {
                self.spliceWithArray(layer.features.all, features);
                return null;
            });
        }
    },

    _getVisibleFeatures: {
        value: function (layer) {
            var self = this;
            return this.fetchPropertyData(Feature.TYPE, layer, "visibleFeatures", "url", "geometryType", {
                layer: layer,
                bounds: layer.bounds
            }).then(function (features) {
                self.spliceWithArray(layer.features.visible, features);
                return null;
            });
        }
    },

    /***************************************************************************
     * Time Service
     */
    _getAvailableTimes: {
        value: function (layer) {
            return layer.canAnimate ? this.fetchPropertyData(Layer.TYPE, layer, "availableTimes", {
                layer: layer,
                isForAvailableTimes: true
            }) : undefined;
        }
    },

    _fetchAvailableTimes: {
        value: function (stream, layer) {
            var self = this;
            this.fetchRestData(RestService.DataType.JSONP, layer.timeServiceUrl).then(function (data) {
                var moments = [], i, n;
                for (i = 0, n = data.data.availableTimes.length; i < n; ++i) {
                    moments.push(new moment(data.data.availableTimes[i]));
                }
                layer.availableTimes = moments;
                self.rawDataDone(stream);
                return null;
            });
        }
    },

    /***************************************************************************
     * URL
     */

    _getUrls: {
        value: function (mapService) {
            return this.fetchPropertyData(Layer.TYPE, mapService, "layerUrls", null, {
                mapService: mapService,
                isForUrl: true
            });
        }
    },

    _fetchUrls: {
        value: function (stream, mapService) {
            var self = this;
            this.fetchRestData(mapService.url && mapService.url + "?f=json").then(function (data) {
                var layers, layer, i, n;
                if (data) {
                    // Extract layers URLs from the map service description.
                    for (i = 0, n = data.layers ? data.layers.length: 0; i < n; ++i) {
                        layer = mapService.layers[data.layers[i].name];
                        if (layer) {
                            layer.mapServiceLayerIndex = data.layers[i].id;
                            layer.url = mapService.url + "/" + data.layers[i].id;
                        }
                    }
                }
                self.rawDataDone(stream);
                return null;
            });
        }
    }

});
