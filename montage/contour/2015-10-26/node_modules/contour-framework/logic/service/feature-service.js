var RestService = require("montage-data/logic/service/rest-service").RestService,
    Feature = require("logic/model/feature").Feature,
    GeometryType = require("logic/model/geometry-type").GeometryType,
    moment = require("moment-timezone"),
    Formatter = require("logic/model/formatter").Formatter;

/**
 * Provides layer feature data.
 *
 * @class
 * @extends external:RestService
 */
exports.FeatureService = RestService.specialize(/** @lends FeatureService.prototype */{

    /***************************************************************************
     * Basic properties
     */

    type: {
        value: Feature.TYPE
    },

    /***************************************************************************
     * Entry points
     */

    fetchRawData: {
        value: function (stream) {
            var self = this,
                layer = stream.selector.criteria.layer,
                bounds = stream.selector.criteria.bounds;
            if (layer.url) {
                Promise.all(bounds.splitAlongAntimeridian().map(function (bounds) {
                    return self.fetchRestData(self._makeUrl(layer, bounds));
                })).then(function (data) {
                    data.forEach(function (datum) {
                        if (datum) {
                            self.addRawData(stream, datum.features, layer);
                        }
                    });
                }).then(function () {
                    self.rawDataDone(stream);
                });
            }
        }
    },

    mapRawData: {
        value: function (feature, featureData, layer) {
            // TODO [Charles]: Replace ifs with polymorphic calls to Geometry
            // objects and move much of this code to those objects.
            // TODO [Charles]: Map data attributes to feature properties so we
            // don't have names like "advisory_date".
            var self = this,
                projection = layer.mapService.projection,
                geometryData = featureData.geometry,
                path, ring, name, i, j, m, n;

            feature.geometry = {coordinates: []};
            feature.properties = featureData.attributes;
            feature.layer = layer;
            feature.id = featureData.attributes.OBJECTID || featureData.attributes.objectid;
            Object.defineProperty(feature, "searchTerms", {get: function() { return self._getSearchTerms(this); }});

            if (layer.geometryType == GeometryType.POINT) {

                feature.geometry.type = "Point";
                feature.geometry.coordinates = projection.inverseProjectPoint([geometryData.x, geometryData.y]);
                feature.properties.point = feature.geometry.coordinates;

            } else if (layer.geometryType == GeometryType.MULTI_POINT && geometryData.points) {

                feature.geometry.type = "MultiPoint";
                for (i = 0, n = geometryData.points.length; i < n; ++i) {
                    feature.geometry.coordinates.push(projection.inverseProjectPoint(geometryData.points[i]));
                }
                feature.properties.point = feature.geometry.coordinates[0];

            } else if (layer.geometryType == GeometryType.MULTI_LINE_STRING && geometryData.paths) {

                feature.geometry.type = "MultiLineString";
                for (i = 0, n = geometryData.paths.length; i < n; ++i) {
                    feature.geometry.coordinates.push(path = []);
                    for (j = 0, m = geometryData.paths[i].length; j < m; ++j) {
                        path.push(projection.inverseProjectPoint(geometryData.paths[i][j]));
                    }
                }
                feature.properties.advisory_date = feature.properties.advisory_date && new moment(new Date(feature.properties.advisory_date));


            } else if (layer.geometryType == GeometryType.POLYGON && geometryData.rings) {

                feature.geometry.type = "Polygon";
                for (i = 0, n = geometryData.rings.length; i < n; ++i) {
                    feature.geometry.coordinates.push(ring = []);
                    for (j = 0, m = geometryData.rings[i].length; j < m; ++j) {
                        ring.push(projection.inverseProjectPoint(geometryData.rings[i][j]));
                    }
                }

            } else {

                name = String(layer.geometryType && layer.geometryType.name.toLowerCase());
                console.warn("Invalid geometry data for geometry type " + name + " -", geometryData);

            }
        }
    },

    /***************************************************************************
     * URL
     */

    _makeUrl: {
        value: function (layer, bounds) {
            var projected = layer.mapService.projection.projectBounds(bounds),
                url = layer.url;
            url += "/query";
            url += "?f=json";
            url += "&geometryType=esriGeometryEnvelope";
            url += "&returnGeometry=true";
            url += "&outSR=";
            url += layer.mapService.projection.srid;
            url += "&geometry=";
            url += "{xmin:";
            url += projected.xMin;
            url += ",ymin:";
            url += projected.yMin;
            url += ",xmax:";
            url += projected.xMax;
            url += ",ymax:";
            url += projected.yMax;
            url += ",spatialReference:{wkid:";
            url += layer.mapService.projection.srid;
            url += "}}";
            url += "&outFields=*";
            //Generate where clause for each filtered field based on
            //it's type and values. If more than one field is filtered,
            //join them with AND
            url += this._makeWhereClause(layer);
            return url;
        }
    },

    _makeWhereClause: {
        value: function (layer) {
            var url = "",
                key, filter, query, sql;
            if (layer.featureFields.filter.length) {

                url = "&where=";
                query = [];
                for (key in layer.featureCriteria.filters) {
                    filter = layer.featureCriteria.filters[key];
                    sql = Formatter.forQueryWithType[filter.type](key, filter);
                    if (sql && sql.length) {
                        sql = "(" + sql + ")";
                        query.push(sql);
                    }
                }
                if (query.length) {
                    url += query.join(" AND ");
                } else {
                    url=""
                }
            }
            return url;
        }
    },

    /***************************************************************************
     * Search
     */

    _getSearchTerms: {
        value: function (feature) {
            var fields, string, split, i, j, n, m;
            if (!feature._searchTerms) {
                feature._searchTerms = {};
                fields = feature.layer.featureFields.all;
                for (i = 0, n = fields.length; i < n; ++i) {
                    string = String(feature.valueForField(fields[i]));
                    if (string !== "undefined") {
                        string = string && string.replace(/[\W_]+/g, " ").trim().toLowerCase();
                        split = string && string.split(" ");
                        for (j = 0, m = split ? split.length : 0; j < m; ++j) {
                            feature._searchTerms[split[j]] = feature;
                        }
                    }
                }
            }
            return feature._searchTerms;
        }
    }

});
