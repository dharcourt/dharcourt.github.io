var DataService = require("montage-data/logic/service/data-service").DataService,
    application = require("montage/core/application").application,
    Configuration = require("logic/model/configuration").Configuration,
    ConfigurationParser = require("logic/service/configuration-parser").ConfigurationParser,
    Promise = require("bluebird"),
    User = require("logic/model/user").User;

/**
 * Provides configuration data for Contour applications.
 *
 * @class
 * @extends external:DataService
 */
exports.ConfigurationService = DataService.specialize(/** @lends ConfigurationService.prototype */{

    /***************************************************************************
     * Configuration
     */

    _configuration_url: {
        value: "config/ServerConfig.xml"
    },

    _user_authority_id: {
        value: "PDC AuthStar"
    },

    /***************************************************************************
     * Basic properties
     */

    type: {
        value: Configuration.TYPE
    },

    userService: { // Set by ContourController.
        value: undefined
    },

    _parser: { // Used in _getConfiguration().
        value: new ConfigurationParser()
    },

    _configuration: { // Set and used in fetchRawData().
        value: undefined
    },

    _streams: { // Set and used in fetchRawData().
        value: undefined
    },

    /***************************************************************************
     * Entry points
     */

    fetchRawData: {
        value: function (stream) {
            var self = this;
            // Add the configuration to the stream if possible, otherwise record
            // the stream so the configuration can be added to it later.
            if (this._configuration) {
                this.addRawData(stream, [this._configuration]);
                this.rawDataDone(stream);
            } else {
                this._streams = this._streams || [];
                this._streams.push(stream);
            }
            // The first time only, kick off an asynchronously reading and
            // parsing of the configuration, then record the results and pass it
            // along to any waiting streams.
            if (!this._isFetchingConfiguration) {
                this._isFetchingConfiguration = true;
                this._getConfiguration().then(function (configuration) {
                    self._configuration = configuration;
                    while (self._configuration && self._streams.length) {
                        self.fetchRawData(self._streams.pop());
                    }
                });
            }
        }
    },

    mapRawData: {
        value: function (configuration, data) {
            // Copy to each of the configuration's property the value of the
            // corresponding data property if that exists.
            var i, j;
            if (data) {
                for (i in configuration) {
                    if (i in data) {
                        for (j in data[i]) {
                            configuration[i][j] = data[i][j];
                        }
                    }
                }
            }
        }
    },

    /***************************************************************************
     * Configuration
     */

    /**
     * Initiates the process of reading and parsing the configuration and
     * returns a promise for that configuration.
     *
     * @private
     * @method
     */
    _getConfiguration: {
        value: function () {
            var self = this,
                context = {xml: undefined, authorities: undefined};
            return new Promise(function (resolve, reject) {
                // Read the XML configuration file.
                request = new XMLHttpRequest();
                request.onload = function () { resolve(request.responseXML); };
                request.open("GET", self._configuration_url, true);
                request.withCredentials = true;
                request.send();
            }).then(function (xml) {
                // Parse the autorization services from the configuration
                // XML, then use the appropriate autorization service to
                // asynchronously get the current user.
                context.xml = xml;
                context.authorities = self._parser.parseAuthorities(xml);
                self.userService.authority = context.authorities.byId[self._user_authority_id];
                return self.userService.fetchData(User.TYPE);
            }).then(function (users) {
                // Parse the rest of the configuration XML.
                return self._parser.parseConfiguration(context.xml, context.authorities, users[0]);
            });
        }
    }

});
