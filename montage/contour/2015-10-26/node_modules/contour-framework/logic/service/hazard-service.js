var RestService = require("montage-data/logic/service/rest-service").RestService,
    DataSelector = require("montage-data/logic/service/data-selector").DataSelector,
    Hazard = require("logic/model/hazard").Hazard,
    moment = require("moment-timezone"),
    Product = require("logic/model/product").Product,
    HazardIcon = require("logic/model/hazard-icon").HazardIcon;

/**
 * Provides hazard data.
 *
 * @class
 * @extends external:RestService
 */
exports.HazardService = RestService.specialize(/** @lends HazardService.prototype */{

    /***************************************************************************
     * Configuration
     */

    applicationIds: {
        value: undefined
    },

    /***************************************************************************
     * Basic property
     */

    type: {
        value: Hazard.TYPE
    },

    /***************************************************************************
     * Entry points
     */

    getPropertyData: {
        value: function (hazard, propertyName) {
            return this._productsPropertyNames[propertyName] ? this._getProducts(hazard) :
                                                               this.nullPromise;
        }
    },

    fetchRawData: {
        value: function (stream) {
            var self = this,
                layer = stream.selector.criteria.layer,
                url = layer.url + "get_hazards",
                body = "app_ids=" + this.constructor.applicationIds + "&" +
                       "where=(status%3D'A')&" +
                       "orderby=update_date+asc";
            this.rootService.getObjectData(layer, "hazardCategories", "hazardSeverities", "hazardTypes").then(function () {
                return self.fetchRestData(url, self.FORM_URL_ENCODED_CONTENT_TYPE_HEADER, body);
            }).then(function (data) {
                self.addRawData(stream, data, layer);
                self.rawDataDone(stream);
            });
        }
    },

    mapRawData: {
        value: function (feature, data, layer) {
            var category = Hazard.Category.forId(data.category_ID),
                severity = Hazard.Severity.forId(data.severity_ID),
                type = Hazard.Type.forId(data.type_ID);
            // Basics.
            feature.id = data.hazard_ID;
            feature.layer = layer;
            feature.geometry = {
                type: "Point",
                coordinates: [data.longitude, data.latitude]
            };
            // Properties (ordered alphabetically).
            // TODO here and in the code that uses these values:
            //     - Replace the icon url with a HazardIcon object.
            //     - Replace the status string with a Hazard.Status enumeration.
            feature.properties = {hazard: feature};
            feature.properties.autoExpire = data.autoexpire === "Y";
            feature.properties.category = category;
            feature.properties.charterUri = data.charter_Uri;
            feature.properties.comment = data.comment_Text;
            feature.properties.creationDate = new moment(Number(data.create_Date));
            feature.properties.description = data.description;
            feature.properties.displayInDashboard = data.in_Dashboard === "1";
            feature.properties.endDate = new moment(Number(data.end_Date));
            feature.properties.glideUri = data.glide_Uri;
            feature.properties.icon = HazardIcon.get(category, severity, type).url;
            feature.properties.updateDate = new moment(Number(data.last_Update));
            feature.properties.latitude = data.latitude;
            feature.properties.longitude = data.longitude;
            feature.properties.name = data.hazard_Name;
            feature.properties.point = feature.geometry.coordinates;
            feature.properties.productCount = data.product_total;
            feature.properties.severity = severity;
            feature.properties.startDate = new moment(Number(data.start_Date));
            feature.properties.status = data.status;
            feature.properties.status = data.status;
            feature.properties.type = type;
            // Possibly unused roperties (ordered alphabetically).
            // TODO: Investigate and remove them if possible.
            feature.properties.appId = data.app_ID;
            feature.properties.appIds = data.app_IDs;
            // Legacy properties (ordered alphabetically).
            // TODO: Remove their use in code and then remove them here.
            feature.properties.categoryId = data.category_ID;
            feature.properties.severityId = data.severity_ID;
            feature.properties.typeId = data.type_ID;
            // Unused data (ordered alphabetically).
            // TODO: Determine whether any of these should be used.
            //     creator: "D2P2"
            //     master_Incident_ID: "55.1424376069961.1"
            //     message_ID: "55.1424376069961"
            //     org_ID: -1
            //     product_total: "30"
            //     snc_url: "http://dynamic.pdc.org/snc/test/54404"
            //     update_Date: "1429873715000"
            //     update_User: "akryeziu"
        }
    },

    /***************************************************************************
     * Products
     */

    _productsPropertyNames: {
        value: {
            "_products_list": true,
            "_products_tree": true,
            "legacyProducts": true,
            "products.list": true,
            "products.tree": true
        }
    },

    _getProducts: {
        value: function (hazard) {
            var self = this;
            return this.rootService.fetchData(DataSelector.withTypeAndCriteria(Product.TYPE, {
                hazard: hazard
            })).then(function (products) {
                self.spliceWithArray(hazard.products.list, products);
                self.spliceWithArray(hazard.products.tree.children, self._getRootProducts(products));
                return null;
            });
        }
    },

    _getRootProducts: {
        value: function (products) {
            var roots = [],
                i, n;
            for (i = 0, n = products.length; i < n; ++i) {
                if (!products[i].parent) {
                    roots.push(products[i]);
                }
            }
            return roots;
        }
    }

});
