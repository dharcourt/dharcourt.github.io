/**
 * @module ui/control/animation-controller.js
 * @requires montage/ui/component
 */
var Component = require("montage/ui/component").Component,
    Enum = require("montage/core/enum").Enum,
    AnimationStatus = exports.AnimationStatus = new Enum().initWithMembers("Stopped", "Paused", "Playing", "NeedsRestart"),
    Set = require("collections/set");

var DEFAULT_SPEED = 2000;
var LOCK_RELEASE_COUNT = 3;

/**
 * @class AnimationController
 * @extends Component
 */
var AnimationController = exports.AnimationController = Component.specialize(/** @lends AnimationController.prototype */{

    constructor: {
        value: function AnimationController() {
        }
    },

    _allTimes: {
        value: []
    },

    _animationInterval: {
        value: null
    },

    _availableTimes: {
        value: null
    },

    _lockReleaseCounter: {
        value: LOCK_RELEASE_COUNT
    },

    __locks: {
        value: null
    },

    _locks: {
        get: function () {
            if (this.__locks === null) {
                this.__locks = new Set();
            }
            return this.__locks;
        }
    },

    _nextTime: {
        value: null
    },

    _speed: {
        value: null
    },

    _step: {
        value: function () {
            this._lockReleaseCounter--;
            if (this.status !== AnimationStatus["Paused"] && (this._locks.length === 0 || this._lockReleaseCounter === 0)) {
                var nextStep = this.timestamps.indexOf(this.currentTime) + 1;
                if (nextStep === this.timestamps.length) {
                    nextStep = 0;
                }
                this.currentTime = this.timestamps[nextStep];
                nextStep++;
                if (nextStep === this.timestamps.length) {
                    nextStep = 0;
                }
                this._locks.clear();
                this.nextTime = this.timestamps[nextStep];
                //console.log("At step: ", nextStep, " of ", this.timestamps.length);
            }
        }
    },

    _timestamps: {
        value: null
    },

    _updateAvailableTimes: {
        value: function () {
            var uniqueMoments = [], timestamps = [],
                moment, previousMoment, i, length,
                currentTimestamps = this.timestamps;

            this._allTimes.sort(function (a, b) {
                return a.unix() - b.unix();
            });
            for (i = 0, length = this._allTimes.length; i < length; i++) {
                moment = this._allTimes[i];
                if (i === 0) {
                    previousMoment = moment;
                    uniqueMoments.push(moment);
                    timestamps.push(moment.unix());
                    continue;
                }
                if (moment.unix() !== previousMoment.unix()) {
                    uniqueMoments.push(moment);
                    timestamps.push(moment.unix());
                }
                previousMoment = moment;
            }

            this.availableTimes = uniqueMoments;
            this.timestamps = timestamps;

            // All times have been removed.  Stop the animation interval.
            if (currentTimestamps.length > 0 && this.timestamps.length === 0) {
                this.stopAnimation();
            // There were no times but some were added.  Start the animation interval.
            } else if (currentTimestamps.length === 0 && this.timestamps.length > 0) {
                this.currentTime = this.timestamps[this.timestamps.length - 1];
                this.nextTime = this.timestamps[0];
            // There were timestamps and timestamps were added or removed (but not all of them).
            // Update next time.
            } else if (currentTimestamps.length > 0 && this.timestamps.length > 0) {
                var currentTimeIndex = this.timestamps.indexOf(this.currentTime),
                    nextTimeIndex;
                // current time was removed.
                if (currentTimeIndex === -1) {
                    currentTimeIndex = this.timestamps.length - 1;
                    while (this.timestamps[currentTimeIndex] > this.currentTime) {
                        currentTimeIndex--;
                        if (currentTimeIndex === 0) break;
                    }
                    this.currentTime = this.timestamps[currentTimeIndex];
                }
                nextTimeIndex = currentTimeIndex + 1;
                if (nextTimeIndex === this.timestamps.length) {
                    nextTimeIndex = 0;
                }
                this.nextTime = this.timestamps[nextTimeIndex];
            }
        }
    },

    /**
     * Add time slices to the available times array.
     * @param {array<moment>}
     */
    addAvailableTimes: {
        value: function (values) {
            this._allTimes = this._allTimes.concat(values);
            this._updateAvailableTimes();
        }
    },

    // holds the available times for all layers
    // who can animate.  To add time slices to
    // this array, use the add/remove available
    // times methods.
    availableTimes: {
        enumerable: true,
        get: function () {
            if (this._availableTimes === null) {
                this._availableTimes = [];
            }
            return this._availableTimes;
        },
        set: function (values) {
            if (values) {
                this._availableTimes = values;
            }
        }
    },

    /**
     * The current step in the animation
     */
    currentTime: {
        value: null
    },

    /**
     * The next step in the animation
     */
    nextTime: {
        get: function () {
            return this._nextTime;
        },
        set: function (value) {
            if (value && value !== this._nextTime) {
                this._nextTime = value;
                this._lockReleaseCounter = LOCK_RELEASE_COUNT;
            }
        }
    },

    /**
     * Allows a component to lock the animation.
     * Used to allow each component to pause the animation
     * while it's buffering.
     */
    lock: {
        value: function (component) {
            if (this._locks.has(component) === false) {
                this._locks.add(component);
            }
        }
    },

    /**
     * Pause the current animation.
     */
    pauseAnimation: {
        value: function () {
            this.status = AnimationStatus["Paused"];
        }
    },

    /**
     * Play the current animation.  If the animation
     * is paused it will start again.
     */
    playAnimation: {
        value: function () {
            this.status = AnimationStatus["Playing"];
        }
    },

    release: {
        value: function (component) {
            if (this._locks.has(component)) {
                this._locks.delete(component);
            }
        }
    },

    /**
     * Remove time slices from the available times array.
     * @param {array<moment>}
     */
    removeAvailableTimes: {
        value: function (values) {
            var result = [], availableTime, found,
                i, length = this._availableTimes.length,
                j, jLength = values.length;
            for (i = 0; i < length; i++) {
                availableTime = this._availableTimes[i];
                found = false;
                for (j = 0; j < jLength; j++) {
                    if (availableTime === values[j]) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    result.push(availableTime);
                }
            }
            this._allTimes = result;
            this._updateAvailableTimes();
        }
    },

    /**
     * Speed of the animation in milliseconds.
     */
    speed: {
        get: function () {
            if (this._speed === null) {
                this._speed = DEFAULT_SPEED;
            }
            return this._speed;
        },
        set: function (value) {
            if (value && this._speed !== value) {
                this._speed = value;
                if (this.status !== AnimationStatus["Stopped"]) {
                    this.stopAnimation();
                    this.startAnimation();
                }
            }
        }
    },

    status: {
        value: AnimationStatus["Stopped"]
    },

    /**
     * Starts the animation.  Returns false if the animation is already running or there are no available times.
     */
    startAnimation: {
        value: function () {
            if (this._animationInterval || this.availableTimes.length === 0) {
                return false;
            }
            clearInterval(this._animationInterval);
            this._lockReleaseCounter = LOCK_RELEASE_COUNT;
            this._animationInterval = setInterval(this._step.bind(this), this.speed);
            this.status = AnimationStatus["Playing"];
        }
    },

    /**
     * Starts the animation.  Returns false if the animation is not running.
     */
    stopAnimation: {
        value: function () {
            if (! this._animationInterval) {
                return false;
            }
            clearInterval(this._animationInterval);
            this._animationInterval = null;
            this.status = AnimationStatus["Stopped"];
        }
    },

    timestamps: {
        get: function () {
            if (this._timestamps === null) {
                this._timestamps = [];
            }
            return this._timestamps;
        },
        set: function (values) {
            this._timestamps = values;
        }
    }

});
