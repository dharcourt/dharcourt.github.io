/**
 * @module logic/controller/post-message-interface.js
 */
var Montage = require("montage").Montage,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities;

var SUPPORTED_FORMATS = ["kml", "json"];

    /**
     * @class PostMessageInterface
     * @extends Montage
     */
    var PostMessageInterface = exports.PostMessageInterface = Montage.specialize(/** @lends PostMessageInterface# */ {

    constructor: {
        value: function PostMessageInterface() {
            window.addEventListener("message", this.receiveMessage.bind(this), false);
            if (window.parent !== window) {
                window.parent.postMessage({
                    title: "com.disasteraware.didLoad",
                    properties: {
                        didLoad: true
                    }
                }, window.location.href);
            }
        }
    },

    _channelCommunicationPartners: {
        value: []
    },

    _bounds: {
        value: null
    },

    _sendAboutStatus: {
        value: function () {
            this.sendMessage("map.status.about", {
                version: "1.2.0",
                type: "2-D",
                widgetName: "DisasterAWARE Version 6 (Contour)",
                extensions: []
            });
        }
    },

    _sendAllStatuses: {
        value: function () {
            this._sendAboutStatus();
            this._sendSupportedFormatsStatus();
            this._sendViewStatus();
        }
    },

    _sendSupportedFormatsStatus: {
        value: function () {
            this.sendMessage("map.status.format", {
                formats: SUPPORTED_FORMATS
            });
        }
    },

    _sendViewStatus: {
        value: function () {
            var center = this.controller.getCenter(),
                zoom = this.controller.getZoom(),
                formattedBounds = {
                    southWest: {
                        lat: this._bounds.south,
                        lon: this._bounds.west
                    },
                    northEast: {
                        lat: this._bounds.north,
                        lon: this._bounds.east
                    }
                };
            this.sendMessage("map.status.view", {
                bounds: formattedBounds,
                center: {
                    lat: center[1],
                    lon: center[0]
                },
                zoom: GeometryUtilities.rangeForZoomLevel(zoom)
            });

        }
    },

    bounds: {
        get: function () {
            return this._center;
        },
        set: function (value) {
            if (value && value !== this._position) {
                // This is messy?  Might want to change the map's bounds property to be
                // an array of coordinates (where each coordinate is an array of two points)
                // instead of an object.  Would be more consistent with the GeoJson specification.
                this._bounds = value;
                this._sendViewStatus();
            }
        }
    },

    handleMapClickAction: {
        value: function (event) {
            var detail = event.detail,
                data = {
                    lat: detail.coordinate[1],
                    lon: detail.coordinate[0],
                    button: detail.button,
                    type: detail.type,
                    keys: detail.keys
                };
            this.sendMessage("map.view.clicked", data);
        }
    },

    processMessage: {
        value: function (data) {
            switch (data.title) {
                case "com.disasteraware.provisionPartner":
                    this.provisionPartner(event.source);
                    break;

                /*** DisasterAware Channels ***/
                case "gpsp.localeChannel":
                    break;
                case "layer.filter.add":
                    break;
                case "layer.filter.toggle":
                    break
                case "org.pdc.bookmark.load":
                    break;
                case "map.animation.time":
                    break;

                /*** Overlay Channels ***/
                case "map.overlay.create":
                    break;
                case "map.overlay.hide": // overlayId property is optional
                    this.controller.hideMapOverlay(data.properties.overlayId);
                    break;
                case "map.overlay.remove":
                    break
                case "map.overlay.show":// overlayId property is optional
                    this.controller.showMapOverlay(data.properties.overlayId);
                    break;
                case "map.overlay.update":
                    break;

                /*** Feature Channels ***/
                case "map.feature.plot":
                    break;
                case "map.feature.plot.url":
                    break;
                case "map.feature.unplot":
                    break;
                case "map.feature.hide":
                    break;
                case "map.feature.show":
                    break;
                case "map.feature.selected":
                    break;
                case "map.feature.deselected":
                    break;
                case "map.feature.update":
                    break;
                case "map.feature.edit":
                    break;

                /*** Map View Channels ***/
                case "map.view.zoom":
                    if (data.properties.range && typeof data.properties.range === "number") {
                        this.controller.setMapZoomWithRange(data.properties.range);
                    }
                    break;
                case "map.view.center.overlay":
                    //
                    break;
                case "map.view.center.feature":
                    //
                    break;
                case "map.view.center.mgrs":
                    if (data.properties.mgrs && typeof data.properties.mgrs === "string") {
                        this.controller.setCenterOnMgrs(data.properties.mgrs);
                    }
                    break;
                case "map.view.center.location":
                    if (data.properties.location) {
                        var coordinate = [data.properties.location.lon, data.properties.location.lat],
                            zoom;
                        if (data.properties.zoom) {
                            if (typeof data.properties.zoom === "string" && data.properties.zoom === "auto") {
                                var self = this;
                                this.controller.maxZoomLevelAtCoordinate(coordinate, function (maxZoom) {
                                    self.controller.setCenterAndZoom(coordinate, maxZoom);
                                });
                            } else if (typeof data.properties.zoom === "number") {
                                zoom = GeometryUtilities.zoomLevelForRange(data.properties.zoom);
                                this.controller.setCenterAndZoom(coordinate, zoom);
                            } else {
                                console.warn("An unsupported zoom level was supplied.  Zoom Level: ", data.properties.zoom);
                                this.controller.setCenter(coordinate);
                            }
                        } else {
                            this.controller.setCenter(coordinate);
                        }
                    }
                    break;
                case "map.view.center.bounds":
                    var bounds = data.properties.bounds;
                    if (bounds && typeof bounds === "object") {
                        this.controller.fitToBounds([
                            [bounds.southWest.lon, bounds.southWest.lat],
                            [bounds.northEast.lon, bounds.northEast.lat]
                        ]);
                        if (data.properties.zoom && typeof data.properties.zoom === "number") {
                            zoom = GeometryUtilities.zoomLevelForRange(data.properties.zoom);
                            this.controller.setZoom(zoom);
                        }
                    }
                    break;

                /*** Map Status Channels***/
                case "map.status.request":
                    var types = data.properties.types;
                    if (types && Array.isArray(types)) {
                        var i, length;
                        for (i = 0, length = types.length; i < length; i++) {
                            switch (types[i]) {
                                case "about":
                                    this._sendAboutStatus();
                                    break;
                                case "format":
                                    this._sendSupportedFormatsStatus();
                                    break;
                                case "selected":
                                    break;
                                case "view":
                                    this._sendViewStatus();
                                    break;
                            }
                        }
                    } else if (types === undefined) {
                        this._sendAllStatuses();
                    }

                    break;

                default:
                    break;
            }
        }
    },

    provisionPartner: {
        value: function (partner) {
            if (this._channelCommunicationPartners.indexOf(partner) === -1) {
                this._channelCommunicationPartners.push(partner);
            }
        }
    },

    receiveMessage: {
        value: function (event) {
            var data = event.data,
                origin = event.origin;

            // some kind of check to ensure that this is a valid origin
            // perhaps we can extend the configuration to include a white
            // list of permitted domains?
            if (! origin) return false;
            this.processMessage(data);
        }
    },

    sendMessage: {
        value: function (name, data) {
            for (var i = 0, length = this._channelCommunicationPartners.length; i < length; i++) {
                this._channelCommunicationPartners[i].postMessage({title: name, properties: data}, window.location.href);
            }
        }
    }

});
