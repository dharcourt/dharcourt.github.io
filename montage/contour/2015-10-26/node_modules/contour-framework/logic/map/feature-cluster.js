/**
 * @module logic/feature-cluster.js
 */
var Montage = require("montage").Montage;

/**
 * @class FeatureCluster
 * @extends Montage
 *
 * Object representing a feature cluster. Used by the map engine to
 * associate a set of features into a group based upon their proximity for a
 * given zoom level.  Based on the Google Marker Clusterer:
 * http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/
 *
 */
/**
 * @class FeatureCluster
 * @extends Montage
 */
var FeatureCluster = exports.FeatureCluster = Montage.specialize(/** @lends FeatureCluster# */ {

    constructor: {
        value: function FeatureCluster(clusterer) {

            this._clusterer = clusterer;
            this._engine = clusterer.engine;
            this._gridSize = clusterer._gridSize;
            this._center = null;
            this._features = [];
            this._bounds = null;
        }
    },

    _bounds: {
        value: null
    },

    /**
     * Calculated the extended bounds of the cluster with the grid.
     *
     * @private
     */
    _calculateBounds: {
        value: function () {
            this._bounds = this.clusterer.padCluster(this._pixelCenter);
        }
    },

    _engine: {
        value: null
    },

    _feature: {
        value: null
    },

    _point: {
        value: null
    },

    /**
     * Adds a feature to the cluster.
     *
     * @param {Feature} feature The feature to add.
     * @return {boolean} True if the feature was added.
     */
    addFeature: {
        value: function (feature, offset) {

            if (this.hasFeature(feature)) {
                return false;
            }

            offset = offset || 0;

            if (! feature.properties.mercatorPoint) {
                feature.properties.mercatorPoint = this.engine.coordinateToMercatorPoint(feature.properties.point);
            }

            var geometry = {
                x: feature.properties.mercatorPoint.x * this.clusterer.zoomLevelCoefficient,
                y: feature.properties.mercatorPoint.y * this.clusterer.zoomLevelCoefficient
            };

            geometry.x += offset;

            if (! this._center) {
                this._pixelCenter = geometry;
            } else {
                var length = this._features.length + 1,
                    y = (this._pixelCenter.y * (length - 1) + geometry.y) / length,
                    x = (this._pixelCenter.x * (length - 1) + geometry.x) / length;
                this._pixelCenter = {x: x, y: y};
            }

            if (this._pixelCenter.x < 0) {
                this._pixelCenter.x = Math.abs(offset) - Math.abs(this._pixelCenter.x);
            } else if (offset > 0 && this._pixelCenter.x > offset) {
                this._pixelCenter.x = this._pixelCenter.x - offset;
            }

            this._point = {
                x: this._pixelCenter.x /  Math.pow(2, this.engine.position.zoom),
                y: this._pixelCenter.y / Math.pow(2, this.engine.position.zoom)
            };

            this._center = this.engine.mercatorPointToCoordinate(this._point);

            feature.properties.isAdded = true;
            this._features.push(feature);
            this._calculateBounds();

            return true;
        }
    },

    /**
     * Returns the bounds of the cluster.
     *
     * @return the cluster bounds.
     */
    bounds: {
        writeable: false,
        get: function () {
            return this._bounds;
        }
    },

    geographicBounds: {
        value: function () {

            var pixelBounds = this.bounds,
                mapSize = Math.pow(2, this.engine.position.zoom),
                west = pixelBounds[0].x / mapSize,
                east = pixelBounds[1].x / mapSize,
                southWest,
                northEast;

            while (west < 0) {
                west += 256;
            }

            while (east > 256) {
                east -= 256;
            }

            southWest = this.engine.mercatorPointToCoordinate({
                x: west,
                y: pixelBounds[0].y / mapSize
            });
            northEast = this.engine.mercatorPointToCoordinate({
                x: east,
                y: pixelBounds[1].y / mapSize
            });

            return [southWest, northEast];
        }
    },

    center: {
        writeable: false,
        get: function () {
            return this._center;
        }
    },

    clusterer: {
        get: function () {
            return this._clusterer;
        }
    },

    distanceToFeature: {
        value: function (feature, offset) {
            offset = offset || 0;
            return Math.sqrt(
                Math.pow(feature.properties.mercatorPoint.x - (this._point.x + offset), 2) +
                Math.pow(feature.properties.mercatorPoint.y - this._point.y, 2)
            );
        }
    },

    /**
     * Methods for retrieving and setting the cluster's
     * map engine.
     */
    engine: {
        get: function () {
            return this._engine;
        },
        set: function (value) {
            this._engine = value;
        }
    },

    feature: {
        get: function () {
            return this._feature;
        },
        set: function (value) {
            this._feature = value;
        }
    },

    featureWithinBounds: {
        value: function (feature, mapSize) {

            var featurePoint = this.engine.coordinateToPixels(feature.properties.point),
                inBounds = false;

            if (this.bounds[0].y > featurePoint.y && this.bounds[1].y < featurePoint.y) {
                if (this.bounds[0].x < 0 || this.bounds[1].x > mapSize) {
                    if (this.bounds[0].x < 0) {
                        inBounds = featurePoint.x < this.bounds[1].x || mapSize - Math.abs(this.bounds[0].x) < featurePoint.x;
                    } else if (this.bounds[1].x > mapSize) {
                        inBounds = featurePoint.x > this.bounds[0].x || this.bounds[1].x - mapSize > featurePoint.x;
                    }
                } else {
                    inBounds = this.bounds[0].x < featurePoint.x && featurePoint.x < this.bounds[1].x;
                }

            }
            return inBounds;
        }
    },

    features: {
        writeable: false,
        get: function () {
            if (this._features === undefined) {
                this._features = [];
            }
            return this._features;
        }
    },

    /**
     * Determines if a feature is already added to the cluster.
     *
     * @param {Object} feature The feature to check.
     * @return {boolean} True if the feature is already added.
     */
    hasFeature: {
        value: function (feature) {
            return this.features.indexOf(feature) !== -1;
        }
    },

    point: {
        get: function () {
            return this._point;
        }
    },

    remove: {
        value: function () {
            this._features.length = 0;
            delete this._features;
        }
    },

    size: {
        get: function () {
            return this.features.length;
        }
    }
});
