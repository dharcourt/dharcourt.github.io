/**
 * @module logic/cluster-icon-renderer.js
 */
var Renderer = require("logic/map/renderer").Renderer,
    Layer = require("logic/mock-model/layer").Layer,
    EsriGeometryType = require("logic/map/esri-geometry-type").EsriGeometryType,
    Protocol = require("logic/model/protocol").Protocol;

var GAP = 6;
var LINE_WIDTH = 5;
var SCALE_NUMBER_LIMIT = 2048;
var MIN_FONT_SIZE = 13;
var SPACE_WIDTH = 2;

/**
 * @class ClusterIconRenderer
 * @extends Renderer
 *
 * This object is used by a cluster to render their icons.
 */
exports.ClusterIconRenderer = Renderer.specialize(/** @lends ClusterIconRenderer.prototype */ {

    color: {
        value: null
    },

    getColor: {
       value: function( protocol ) {
           if ( this.color ) { return this.color; }
           switch (protocol) {
               case Protocol.ARCGIS:
               case Layer.Protocol.AGS:
                   return"#0075D9";
               case Layer.Protocol.Camera:
                   return"#FFA500";
           }
       }
    },

    constructor: {
        value: function ClusterIconRenderer() {
            this.geometryType = EsriGeometryType["esriGeometryPoint"];
        }
    },

    _renderPoint: {
        value: function (cluster) {

            var quantity = cluster.size,
                protocol = cluster.clusterer.protocol,
                iconIdentifier = "ClusterIcon:" + protocol + ":" + quantity,
                iconData;

            if (window.sessionStorage[iconIdentifier] !== undefined) {
                iconData = JSON.parse(sessionStorage[iconIdentifier]);
            } else {
                var fontSize = MIN_FONT_SIZE,
                    charNum = quantity.toString().split("").length,
                    charWidth = /*~~*/(fontSize / 2) - 1,
                    spaceNum = charNum > 1 ? charNum - 1 : 0,
                    textWidth = spaceNum * SPACE_WIDTH + charNum * charWidth,
                    diameter = textWidth + 4 * GAP,
                    radius = diameter / 2,
                    center = { x: radius + LINE_WIDTH, y: radius + LINE_WIDTH },
                    fillColor = this.getColor(protocol),
                    rgbColor = Renderer.hexToRGB(fillColor),
                    canvas = document.createElement("canvas"),
                    context = canvas.getContext("2d");

                canvas.width = canvas.height = diameter + 2 * LINE_WIDTH;

                //context.strokeStyle = "#FFFFFF";
                //context.lineWidth = LINE_WIDTH;
                context.fillStyle = "rgba(" + rgbColor.r + ", " + rgbColor.g + ", " + rgbColor.b + ", 0.25)";
                context.arc(center.x, center.y, radius, 0, 2 * Math.PI, false);
                context.fill();
                context.beginPath();
                context.fillStyle = fillColor;
                context.arc(center.x, center.y, radius - LINE_WIDTH, 0, 2 * Math.PI, false);
                context.fill();
                context.font = fontSize + 'px "Proxima Nova", sans-serif';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillStyle = 'white';
                context.fillText(quantity, canvas.width / 2, canvas.height / 2);
                iconData = {
                    anchor: { x:canvas.width / 2, y: canvas.height / 2},
                    size: {width: canvas.width, height: canvas.height},
                    url: canvas.toDataURL()
                };

                window.sessionStorage[iconIdentifier] = JSON.stringify(iconData);
            }

            return iconData;
        }
    }
});
