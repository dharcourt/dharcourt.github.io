/**
 * @module logic/projection-utilities.js
 */
var proj4 = require("proj4");
var Montage = require("montage").Montage;
var Enum = require("montage/core/enum").Enum;
var SRID = exports.SRID = ["102100", "3857", "900913", "27700", "MGRS"];
var Projections = exports.Projections = Enum.initWithMembers.apply(new Enum(), SRID);
var Units = exports.Units = new Enum().initWithMembers("decimal degrees", "meters");

proj4.defs('EPSG:102100', "+title= Google Mercator EPSG:900913 +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
proj4.defs('EPSG:900913', "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
proj4.defs["EPSG:27700"] = "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +datum=OSGB36 +units=m +no_defs";

/**
 * @class ProjectionUtilities
 * @extends Montage
 *
 * This class provides utilities for converting between different coordinate systems.
 */
var ProjectionUtilities = exports.ProjectionUtilities = Montage.specialize(/** @lends ProjectionUtilities */ {}, {
    bbox: {
        value: function (extent, projection, units) {

            var bbox;
            switch(units) {
                case Units["decimal degrees"]:
                    bbox = extent;
                    break;
                case Units["meters"]:
                    var min = ProjectionUtilities.project(projection, [extent.xmin, extent.ymin]),
                        max = ProjectionUtilities.project(projection, [extent.xmax, extent.ymax]);
                    bbox = {
                        xmin: min[0],
                        ymin: min[1],
                        xmax: max[0],
                        ymax: max[1]
                    };
                    break;
                default:
                    console.error("Supplied units", units, "are not valid.");
                    break;
            }

            return bbox;

        }
    },

    _mgrsAccuracy: {
        value: 5
    },

    project: {
        value: function (projection, coordinate) {

            var projectedCoordinate;

            switch(projection) {
                case Projections["102100"]:
                    projectedCoordinate = proj4("EPSG:102100", coordinate);
                    break;
                case Projections["3857"]:
                    projectedCoordinate = proj4("EPSG:3857", coordinate);
                    break;
                case Projections["900913"]:
                    projectedCoordinate = proj4("EPSG:900913", coordinate);
                    break;
                case Projections["27700"]:
                    projectedCoordinate = proj4(proj4.defs["EPSG:27700"], coordinate);
                    break;
                case Projections["MGRS"]:
                    projectedCoordinate = proj4.mgrs.forward(coordinate, ProjectionUtilities._mgrsAccuracy);
                    break;
                default:
                    console.warn("Supplied projection", projection, "is not supported.");
                    break;
            }

            return projectedCoordinate;

        }
    },

    inverse: {
        value: function (projection, coordinate) {

            var projectedCoordinate;

            switch(projection) {
                case Projections["102100"]:
                    projectedCoordinate = proj4("EPSG:102100").inverse(coordinate);
                    break;
                case Projections["3857"]:
                    projectedCoordinate = proj4("EPSG:3857").inverse(coordinate);
                    break;
                case Projections["900913"]:
                    projectedCoordinate = proj4("EPSG:900913").inverse(coordinate);
                    break;
                case Projections["MGRS"]:
                    projectedCoordinate = proj4.mgrs.toPoint(coordinate);
                    break;
                default:
                    //console.warn("Supplied projection", projection, "is not supported.");
                    console.trace("Supplied projection", projection, "is not supported.");
                    break;
            }

            return projectedCoordinate;

        }
    },

    fromLatLngToPoint: {
        value: function (lat, lng) {
            var x = (lng + 180) / 360 * 256;
            var y = ((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, 0)) * 256;
            return { x: x, y:y };
        }
    },

    fromPointToLatLng: {
        value: function (x, y) {
            var lng = x / 256 * 360 - 180;
            var n = Math.PI - 2 * Math.PI * y / 256;
            var lat = (180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));
            return [lat, lng];
        }
    },

    fromTileIdentifierToLatLng: {
        value: function (x, y, z) {

            var n = Math.pow(2, z),
                longitudeInDegrees = x / n * 360.0 - 180.0,
                latitudeInRadians = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))),
                latitudeInDegrees = latitudeInRadians * (180.0 / Math.PI);

            return [latitudeInDegrees, longitudeInDegrees];
        }
    },

    extentForTile: {
        value: function (tileParts) {

            var northWest = ProjectionUtilities.fromTileIdentifierToLatLng(tileParts[0], tileParts[1], tileParts[2]),
                southEast = ProjectionUtilities.fromTileIdentifierToLatLng(parseInt(tileParts[0]) + 1, parseInt(tileParts[1]) + 1, tileParts[2]);

            if (southEast[1] === -180) {
                southEast[1] = Math.abs(southEast[1]);
            } else if (northWest[1] === 180) {
                northWest[1] *= -1;
            }

            return {
                xmin: northWest[1],
                xmax: southEast[1],
                ymin: southEast[0],
                ymax: northWest[0]
            }
        }
    }

});
