/**
 * @module logic/class-breaks-renderer.js
 */
var Renderer = require("logic/map/renderer").Renderer;

/**
 * @class ClassBreaksRenderer
 * @extends Renderer
 *
 * This object is used by a feature layer to render it's feature data
 * provided that the feature layer is configured to use a "ClassBreaksRenderer".
 */
exports.ClassBreaksRenderer = Renderer.specialize(/** @lends ClassBreaksRenderer.prototype */ {

    constructor: {
        value: function ClassBreaksRenderer(field, minValue, classBreaks, transparency) {
            this.field = field;
            this.minValue = minValue;
            this.classBreaks = classBreaks;
            this.transparency = transparency;
        }
    },

    _renderPoint: {
        value: function (properties) {

            var classBreak = this._classBreak(properties);

            if (! classBreak.style) {

                var url = Renderer.symbolUrl(classBreak.symbol),
                    dimensions = Renderer.getDimensions(url),
                    anchor = {
                        x: parseInt(dimensions.width / 2),
                        y: parseInt(dimensions.height / 2)
                    };

                classBreak.style = {
                    anchor: anchor,
                    size: { width: dimensions.width, height: dimensions.height },
                    url: url
                };
            }

            return classBreak.style;
        }
    },

    _renderLine: {
        value: function (properties) {

            var classBreak = this._classBreak(properties),
                opacity = properties.layerOpacity;

            if (! classBreak.style || opacity && opacity !== classBreak.style.opacity) {
                classBreak.style = {
                    opacity: opacity,
                    strokeOpacity: opacity || 1.0,
                    strokeWeight: classBreak.symbol.width,
                    strokeColor: Renderer.rgbToHex(classBreak.symbol.color)
                };
            }

            return classBreak.style;
        }
    },

    _renderPolygon: {
        value: function (properties) {

            var classBreak = this._classBreak(properties),
                opacity = properties.layerOpacity;

            if (! classBreak.style || opacity && opacity !== classBreak.style.opacity) {
                classBreak.style = {
                    fillColor: Renderer.rgbToHex(classBreak.symbol.color),
                    fillOpacity: opacity || 1.0,
                    opacity: opacity,
                    strokeColor: Renderer.rgbToHex(classBreak.symbol.outline.color),
                    strokeOpacity: opacity || 1.0,
                    strokeWeight: classBreak.symbol.outline.width
                };
            }

            return classBreak.style;
        }
    },

    _legendSymbolsForPointRenderer: {
        value: function () {
            var legendItems = [], i, n, classBreak;
            for (i = 0, n = this.classBreaks.length; i < n; i++) {
                classBreak = this.classBreaks[i];
                legendItems.push({
                    url: Renderer.symbolUrl(classBreak.symbol),
                    label: classBreak.label
                });
            }
            return legendItems;
        }
    },

    _legendSymbolsForLineRenderer: {
        value: function () {
            var legendItems = [], i, n, classBreak;
            for (i = 0, n = this.classBreaks.length; i < n; i++) {
                classBreak = this.classBreaks[i];
                legendItems.push({
                    strokeWeight: classBreak.symbol.width,
                    strokeColor: Renderer.rgbToHex(classBreak.symbol.color),
                    type: "line",
                    label: classBreak.label
                });
            }
            return legendItems;
        }
    },

    _legendSymbolsForPolygonRenderer: {
        value: function () {
            var legendItems = [], i, n, classBreak;
            for (i = 0, n = this.classBreaks.length; i < n; i++) {
                classBreak = this.classBreaks[i];
                legendItems.push({
                    fillColor: Renderer.rgbToHex(classBreak.symbol.color),
                    strokeColor: Renderer.rgbToHex(classBreak.symbol.outline.color),
                    strokeWeight: classBreak.symbol.outline.width,
                    type: "polygon",
                    label: classBreak.label
                });
            }
            return legendItems;
        }
    },

    _classBreak: {
        value: function (properties) {

            var fieldValue = properties[this.field],
                classBreak;

            for (var n in this.classBreaks) {
                classBreak = this.classBreaks[n];
                if (fieldValue <= classBreak.classMaxValue) {
                    break;
                }
            }

            return classBreak;
        }
    },

    export: {
        value: function (properties) {
            var classBreak = this._classBreak(properties),
                style = this.render(properties);
            style.symbolUrl = classBreak.symbol.url;
            return style;
        }
    }

}, {

    forDefinition: {
        value: function (definition) {
            return new this(
                definition.field,
                definition.minValue,
                definition.classBreakInfos,
                definition.transparency
            );
        }
    }

});
