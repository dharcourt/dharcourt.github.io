/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Latitude/longitude spherical geodesy formulae & scripts           (c) Chris Veness 2002-2015  */
/*   - www.movable-type.co.uk/scripts/latlong.html                                   MIT Licence  */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
var Montage = require("montage").Montage,
    L = require("leaflet"),
    ProjectionUtilities = require("logic/map/projection-utilities").ProjectionUtilities,
    simplify = require("simplify-js"),
    DATUM = {
        ellipsoid: {
            a: 6378137,
            b: 6356752.31425,
            f: 1 / 298.257223563
        }
    };

/**
 * @const {Array}
 */
var ZoomLevelScales = [
    1128.497220, 2256.994440, 4513.988880, 9027.977761, 18055.955520, 36111.911040, 72223.822090, 144447.644200,
    288895.288400, 577790.576700, 1155581.153000, 2311162.307000, 4622324.614000, 9244649.227000, 18489298.450000,
    36978596.910000, 73957193.820000, 147914387.600000, 295828775.300000, 591657550.500000
];

/**
 * @class GeometryUtilities
 * @extends Montage
 *
 * This class provides convenience utilities for geometry.
 */
var GeometryUtilities = exports.GeometryUtilities = Montage.specialize(/** @lends GeometryUtilities */ {}, {
    EARTH_RADIUS: {
        value: 6371e3
    },

    DATUM: {
        value: {
            ellipsoid: {}
        }
    },

    _boundingBoxContainsFeature: {
        value: function (boundingBox, feature) {
            var geometryType = feature.geometry.type,
                doesContain = false;

            if (geometryType === "Point") {
                doesContain = GeometryUtilities.boundingBoxContainsPointFeature(boundingBox, feature);
            } else if (geometryType === "MultiPoint") {
                doesContain = GeometryUtilities.boundingBoxContainsMultiPointFeature(boundingBox, feature);
            } else if (geometryType === "LineString") {
                doesContain = GeometryUtilities.boundingBoxContainsLineString(boundingBox, feature.geometry.coordinates);
            } else if (geometryType === "MultiLineString") {
                doesContain = GeometryUtilities.boundingBoxContainsMultiLineStringFeature(boundingBox, feature);
            } else if (geometryType === "Polygon") {
                doesContain = GeometryUtilities.boundingBoxContainsPolygonFeature(boundingBox, feature);
            } else if (geometryType === "MultiPolygon") {
                doesContain = GeometryUtilities.boundingBoxContainsMultiPolygonFeature(boundingBox, feature);
            }

            return doesContain;
        }
    },

    //http://www.movable-type.co.uk/scripts/latlong.html
    bearingToPoint: {
        value: function (start, end) {
            var thetaOne = GeometryUtilities.toRadians(start[1]),
                thetaTwo = GeometryUtilities.toRadians(end[1]),
                deltaLambda = GeometryUtilities.toRadians(end[0] - start[0]),
                y = Math.sin(deltaLambda) * Math.cos(thetaTwo),
                x = Math.cos(thetaOne) * Math.sin(thetaTwo) - Math.sin(thetaOne) * Math.cos(thetaTwo) * Math.cos(deltaLambda),
                theta = Math.atan2(y, x);

            return (GeometryUtilities.toDegrees(theta) + 360) % 360;
        }
    },

    /**
     * Returns the midpoint between 'this' point and the supplied point.
     *
     * @param   {LatLon} point - Latitude/longitude of destination point.
     * @returns {LatLon} Midpoint between this point and the supplied point.
     *
     * @example
     *     var p1 = new LatLon(52.205, 0.119), p2 = new LatLon(48.857, 2.351);
     *     var pMid = p1.midpointTo(p2); // pMid.toString(): 50.5363°N, 001.2746°E
     */
    midPointTo: {
        value: function (coordinateOne, coordinateTwo) {

            var φ1 = GeometryUtilities.toRadians(coordinateOne[1]),
                λ1 = GeometryUtilities.toRadians(coordinateOne[0]),
                φ2 = GeometryUtilities.toRadians(coordinateTwo[1]),
                Δλ = GeometryUtilities.toRadians(coordinateTwo[0] - coordinateOne[0]),
                Bx = Math.cos(φ2) * Math.cos(Δλ),
                By = Math.cos(φ2) * Math.sin(Δλ),
                φ3 = Math.atan2(Math.sin(φ1)+Math.sin(φ2), Math.sqrt((Math.cos(φ1)+Bx)*(Math.cos(φ1)+Bx) + By*By)),
                λ3 = λ1 + Math.atan2(By, Math.cos(φ1) + Bx);

            λ3 = (λ3+3*Math.PI) % (2*Math.PI) - Math.PI; // normalise to -180..+180°
            return [GeometryUtilities.toDegrees(λ3), GeometryUtilities.toDegrees(φ3)];
        }
    },

    _boundingBoxContainsCoordinate: {
        value: function (boundingBox, coordinate) {
            return coordinate[0] <= boundingBox[2] &&
                coordinate[0] >= boundingBox[0] &&
                coordinate[1] >= boundingBox[1] &&
                coordinate[1] <= boundingBox[3];
        }
    },

    boundingBoxContainsCoordinate: {
        value: function (boundingBox, coordinate) {
            if (boundingBox[0] > boundingBox[2]) {
                var westBox = [boundingBox[0], boundingBox[1], 180, boundingBox[3]],
                    eastBox = [-180, boundingBox[1], boundingBox[2], boundingBox[3]];
                return this._boundingBoxContainsCoordinate(westBox, coordinate) || this._boundingBoxContainsCoordinate(eastBox, coordinate);
            } else {
                return this._boundingBoxContainsCoordinate(boundingBox, coordinate);
            }
        }
    },

    boundingBoxContainsFeature: {
        value: function (boundingBox, feature) {
            var doesContain = false;

            if (boundingBox[0] > boundingBox[2]) {
                var westBox = [boundingBox[0], boundingBox[1], 180, boundingBox[3]],
                    eastBox = [-180, boundingBox[1], boundingBox[2], boundingBox[3]];

                doesContain = GeometryUtilities._boundingBoxContainsFeature(westBox, feature) ||
                    GeometryUtilities._boundingBoxContainsFeature(eastBox, feature);
            } else {
                doesContain = GeometryUtilities._boundingBoxContainsFeature(boundingBox, feature);
            }

            return doesContain;
        }
    },

    boundingBoxContainsLineString: {
        value: function (boundingBox, lineString) {
            var doesContain = false,
                i, length,
                j, a, b, point1, point2, point3, point4;

            for (i = 0, length = lineString.length; i < length; i++) {
                doesContain = GeometryUtilities.boundingBoxContainsCoordinate(boundingBox, lineString[i]);
                if (doesContain) {
                    break;
                }
            }

            if (!doesContain) {
                var extentPoints = [
                    [boundingBox[2], boundingBox[1]],
                    [boundingBox[0], boundingBox[1]],
                    [boundingBox[0], boundingBox[3]],
                    [boundingBox[2], boundingBox[3]]
                ];

                for (i = 0, j = lineString.length - 1; i < lineString.length; j = i++) {
                    point3 = lineString[i];
                    point4 = lineString[j];
                    for (a = 0; a < 4; a++) {
                        b = a + 1;
                        if (b === 4) {
                            b = 0;
                        }
                        point1 = extentPoints[a];
                        point2 = extentPoints[b];

                        doesContain = GeometryUtilities.doLinesIntersect(
                            point1[0], point1[1],
                            point2[0], point2[1],
                            point3[0], point3[1],
                            point4[0], point4[1]
                        );

                        if (doesContain) {
                            break;
                        }
                    }
                }
            }

            return doesContain;
        }
    },

    boundingBoxContainsMultiLineStringFeature: {
        value: function (boundingBox, feature) {
            var doesContain = false,
                lineStringArray = feature.geometry.coordinates,
                i, length;

            for (i = 0, length = lineStringArray.length; i < length; i++) {
                doesContain = GeometryUtilities.boundingBoxContainsLineString(boundingBox, lineStringArray[i]);
                if (doesContain) {
                    break;
                }
            }

            return doesContain;
        }
    },

    boundingBoxContainsMultiPointFeature: {
        value: function (boundingBox, feature) {
            var doesContain = false,
                coordinates = feature.geometry.coordinates,
                i, length;

            for (i = 0, length = coordinates.length; i < length; i++) {
                doesContain = GeometryUtilities.boundingBoxContainsCoordinate(boundingBox, coordinates[i]);
                if (doesContain) {
                    break;
                }
            }

            return doesContain;
        }
    },

    boundingBoxContainsPolygonFeature: {
        value: function (boundingBox, feature) {
            var doesContain = false,
                path = feature.geometry.coordinates[0],
                i, j, n;
            for (i = 0, n = path.length; i < n; i++) {
                doesContain = GeometryUtilities.boundingBoxContainsCoordinate(boundingBox, path[i]);
                if (doesContain) {
                    break;
                }
            }
            if (!doesContain) {
                outerPointInPolygonLoop:
                for (i = 0; i < 2; i++) {
                    innerPointInPolygonLoop:
                    for (j = 0; j < 2; j++) {
                        var x = i === 0 ? 0 : 2,
                            y = j === 0 ? 1 : 3;
                        doesContain = GeometryUtilities.isPointInPolygon(
                            [boundingBox[x], boundingBox[y]],
                            path
                        );
                        if (doesContain) {
                            break outerPointInPolygonLoop;
                        }
                    }
                }
            }
            return doesContain;
        }
    },

    boundingBoxContainsMultiPolygonFeature: {
        value: function (boundingBox, feature) {
            var doesContain = false,
                paths = feature.geometry.coordinates,
                path,
                i, j, length, pathLength;

            boundingBoxContainsCoordinateOuterLoop:
            for (i = 0, length = paths.length; i < length; i++) {
                path = paths[i];
                for (j = 0, pathLength = path.length; j < pathLength; j++) {
                    doesContain = GeometryUtilities.boundingBoxContainsCoordinate(boundingBox, path[j]);
                    if (doesContain) {
                        break boundingBoxContainsCoordinateOuterLoop;
                    }
                }
            }

            if (!doesContain) {
                outerPointInPolygonLoop:
                for (i = 0; i < 2; i++) {
                    innerPointInPolygonLoop:
                    for (j = 0; j < 2; j++) {
                        var x = i === 0 ? 0 : 2,
                            y = j === 0 ? 1 : 3;

                        doesContain = GeometryUtilities.isPointInPolygon(
                            [boundingBox[x], boundingBox[y]],
                            paths[0]
                        );

                        if (doesContain) {
                            var pointInPolygonHole = false,
                                k, holesLength;
                            for (k = 1, holesLength = paths.length; k < holesLength; k++) {
                                pointInPolygonHole = GeometryUtilities.isPointInPolygon(
                                    [boundingBox[x], boundingBox[y]],
                                    paths[k]
                                );
                                if (pointInPolygonHole) {
                                    doesContain = false;
                                    break innerPointInPolygonLoop;
                                }
                            }
                        }

                        if (doesContain) {
                            break outerPointInPolygonLoop;
                        }
                    }
                }
            }

            return doesContain;
        }
    },

    boundingBoxContainsPointFeature: {
        value: function (boundingBox, feature) {
            var doesContain = false,
                coordinate = feature.geometry.coordinates;

            if (boundingBox[0] > boundingBox[2]) {
                var west = [boundingBox[0], boundingBox[1], 180, boundingBox[3]],
                    east = [-180, boundingBox[1], boundingBox[2], boundingBox[3]];
                doesContain = GeometryUtilities.boundingBoxContainsCoordinate(west, coordinate);
                if (!doesContain) {
                    doesContain = GeometryUtilities.boundingBoxContainsCoordinate(east, coordinate);
                }
            } else {
                doesContain = GeometryUtilities.boundingBoxContainsCoordinate(boundingBox, coordinate);
            }

            return doesContain;
        }
    },

    // Ported from the Leaflet.draw implementation. See https://github.com/Leaflet/Leaflet.draw/blob/master/src/ext/GeometryUtil.js#L3
    calculateAreaOfPolygonFigure: {
        value: function (figure) {
            var coordinates = figure.coordinates,
                pointsCount = coordinates.length,
                area = 0.0,
                d2r = L.LatLng.DEG_TO_RAD,
                p1, p2;

            if (pointsCount > 2) {
                for (var i = 0; i < pointsCount; i++) {
                    p1 = coordinates[i];
                    p2 = coordinates[(i + 1) % pointsCount];
                    area += ((p2[1] - p1[1]) * d2r) *
                        (2 + Math.sin(p1[0] * d2r) + Math.sin(p2[0] * d2r));
                }
                area = area * 6378137.0 * 6378137.0 / 2.0;
            }
            return Math.abs(area / 1E6);
        }
    },

    getCenter: {
        value: function (coordinates) {
            if (coordinates.length === 1) {
                return coordinates[0];
            }

            var centralLongitude,
                centralSquareRoot,
                centralLatitude,
                i, length = coordinates.length,
                x = 0,
                y = 0,
                z = 0;

            for (i = 0; i < length; i++) {
                var coordinate = coordinates[i],
                    latitude = GeometryUtilities.toRadians(coordinate[1]),
                    longitude = GeometryUtilities.toRadians(coordinate[0]);

                x += Math.cos(latitude) * Math.cos(longitude);
                y += Math.cos(latitude) * Math.sin(longitude);
                z += Math.sin(latitude);
            }

            x = x / length;
            y = y / length;
            z = z / length;

            centralLongitude = Math.atan2(y, x);
            centralSquareRoot = Math.sqrt(x * x + y * y);
            centralLatitude = Math.atan2(z, centralSquareRoot);

            return [GeometryUtilities.toDegrees(centralLongitude), GeometryUtilities.toDegrees(centralLatitude)];
        }
    },

    circleArcCoordinates: {
        value: function (center, radius, steps) {
            var coordinates = [],
                angle,
                arc = 360,
                stepSize = arc / steps,
                theta = 0,
                i;

            for (i = 0; i < steps; i++) {
                angle = theta + (stepSize * i);
                var point = GeometryUtilities.vincentyDirect(center, DATUM, radius, angle).point;
                coordinates.push({
                    bearing: angle,
                    coordinate: [GeometryUtilities.normalizedLongitude(point[0]), point[1]]
                });
            }

            return coordinates;
        }
    },

    normalizedLongitude: {
        value: function (longitude) {
            while (longitude < -180) longitude += 360;
            while (longitude > 180) longitude -= 360;
            return longitude;
        }
    },

    /**
     * Returns the destination point having travelled the given distance along a geodesic given by
     * initial bearing from ‘this’ point, using Vincenty direct solution.
     *
     * @param   {number[]} startPoint - the starting point.
     * @param   {number} distance - Distance travelled along the geodesic in metres.
     * @param   {number} initialBearing - Initial bearing in degrees from north.
     * @returns {LatLon} Destination point.
     *
     * @example
     *   var p1 = new LatLon(-37.95103, 144.42487);
     *   var p2 = p1.destinationPoint(54972.271, 306.86816); // p2.toString(): 37.6528°S, 143.9265°E
     */
    destinationPoint: {
        value: function (startPoint, distance, bearing) {
            var delta = Number(distance) / GeometryUtilities.EARTH_RADIUS,
                theta = GeometryUtilities.toRadians(Number(bearing)),
                thetaOne = GeometryUtilities.toRadians(startPoint[1]),
                lambdaOne = GeometryUtilities.toRadians(startPoint[0]),
                thetaTwo = Math.asin(Math.sin(thetaOne) * Math.cos(delta) + Math.cos(thetaOne) * Math.sin(delta) * Math.cos(theta)),
                lambdaTwo = lambdaOne + Math.atan2(
                        Math.sin(theta) * Math.sin(delta) * Math.cos(thetaOne),
                        Math.cos(delta) - Math.sin(thetaOne) * Math.sin(thetaTwo)
                    );

            lambdaTwo = (lambdaTwo + 3 * Math.PI) % (2 * Math.PI) - Math.PI;

            return [GeometryUtilities.toDegrees(lambdaTwo), GeometryUtilities.toDegrees(thetaTwo)];
        }
    },

    boundingBoxForCircle: {
        value: function (center, radius) {
            var north = GeometryUtilities.rhumbDestinationPoint(center, radius, 0)[1],
                south = GeometryUtilities.rhumbDestinationPoint(center, radius, 180)[1],
                west = GeometryUtilities.rhumbDestinationPoint(center, radius, 270)[0],
                east = GeometryUtilities.rhumbDestinationPoint(center, radius, 90)[0];

            return [west, south, east, north];
        }
    },

    /**
     * Calculates the distance between two latlng locations in km.
     * @see http://www.movable-type.co.uk/scripts/latlong.html
     *
     * @param {Point} from The first array of lng lat coordinates.
     * @param {Point} to The second array of lng lat coordinates.
     * @return {number} The distance between the two points in km.
     * @private
     */
    distanceBetweenGeographicPoints: {
        value: function (from, to) {
            // Not sure why this is a guarded statement?
            if (!from || !to) {
                return 0;
            }

            var earthRadius = 6371,
                dLat = (to[1] - from[1]) * Math.PI / 180,
                dLon = (to[0] - from[0]) * Math.PI / 180,
                a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(from[1] * Math.PI / 180) * Math.cos(to[1] * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2),
                c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return earthRadius * c;

        }
    },

    doLinesIntersect: {
        value: function (x1, y1, x2, y2, x3, y3, x4, y4) {
            return GeometryUtilities.orientation(x1, y1, x3, y3, x4, y4) !== GeometryUtilities.orientation(x2, y2, x3, y3, x4, y4) &&
                GeometryUtilities.orientation(x1, y1, x2, y2, x3, y3) !== GeometryUtilities.orientation(x1, y1, x2, y2, x4, y4);
        }
    },

    fromCoordinateToPoint: {
        value: function (coordinate, zoomLevel) {
            var x = (coordinate[0] + 180) / 360 * 256;
            var y = ((1 - Math.log(Math.tan(coordinate[1] * Math.PI / 180) + 1 / Math.cos(coordinate[1] * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoomLevel)) * 256;
            return {x: x, y: y};
        }
    },

    intersection: {
        value: function (pointOne, bearingOne, pointTwo, bearingTwo) {
            // see http://williams.best.vwh.net/avform.htm#Intersection

            var φ1 = GeometryUtilities.toRadians(pointOne[1]), λ1 = GeometryUtilities.toRadians(pointOne[0]);
            var φ2 = GeometryUtilities.toRadians(pointTwo[1]), λ2 = GeometryUtilities.toRadians(pointTwo[0]);
            var θ13 = GeometryUtilities.toRadians(bearingOne), θ23 = GeometryUtilities.toRadians(bearingTwo);
            var Δφ = φ2 - φ1, Δλ = λ2 - λ1;

            var δ12 = 2 * Math.asin(Math.sqrt(Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2)));
            if (δ12 == 0) return null;

            // initial/final bearings between points
            var θ1 = Math.acos((Math.sin(φ2) - Math.sin(φ1) * Math.cos(δ12)) /
                (Math.sin(δ12) * Math.cos(φ1)));
            if (isNaN(θ1)) θ1 = 0; // protect against rounding
            var θ2 = Math.acos((Math.sin(φ1) - Math.sin(φ2) * Math.cos(δ12)) /
                (Math.sin(δ12) * Math.cos(φ2)));

            var θ12, θ21;
            if (Math.sin(λ2 - λ1) > 0) {
                θ12 = θ1;
                θ21 = 2 * Math.PI - θ2;
            } else {
                θ12 = 2 * Math.PI - θ1;
                θ21 = θ2;
            }

            var α1 = (θ13 - θ12 + Math.PI) % (2 * Math.PI) - Math.PI; // angle 2-1-3
            var α2 = (θ21 - θ23 + Math.PI) % (2 * Math.PI) - Math.PI; // angle 1-2-3

            if (Math.sin(α1) == 0 && Math.sin(α2) == 0) return null; // infinite intersections
            if (Math.sin(α1) * Math.sin(α2) < 0) return null;      // ambiguous intersection

            //α1 = Math.abs(α1);
            //α2 = Math.abs(α2);
            // ... Ed Williams takes abs of α1/α2, but seems to break calculation?

            var α3 = Math.acos(-Math.cos(α1) * Math.cos(α2) +
                Math.sin(α1) * Math.sin(α2) * Math.cos(δ12));
            var δ13 = Math.atan2(Math.sin(δ12) * Math.sin(α1) * Math.sin(α2),
                Math.cos(α2) + Math.cos(α1) * Math.cos(α3));
            var φ3 = Math.asin(Math.sin(φ1) * Math.cos(δ13) +
                Math.cos(φ1) * Math.sin(δ13) * Math.cos(θ13));
            var Δλ13 = Math.atan2(Math.sin(θ13) * Math.sin(δ13) * Math.cos(φ1),
                Math.cos(δ13) - Math.sin(φ1) * Math.sin(φ3));
            var λ3 = λ1 + Δλ13;
            λ3 = (λ3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°

            return [GeometryUtilities.toDegrees(λ3), GeometryUtilities.toDegrees(φ3)];
        }
    },

    /**
     * Vincenty inverse calculation.
     *
     * @private
     * @param   {Number[]} p1 - longitude/latitude of start point.
     * @param   {Number[]} p2 - longitude/latitude of destination point.
     * @returns {Object} Object including distance, initialBearing, finalBearing.
     * @throws  {Error}  If formula failed to converge.
     */
    inverse: {
        value: function (p1, p2, datum) {
            var φ1 = GeometryUtilities.toRadians(p1[1]), λ1 = GeometryUtilities.toRadians(p1[0]);
            var φ2 = GeometryUtilities.toRadians(p2[1]), λ2 = GeometryUtilities.toRadians(p2[0]);

            var a = datum.ellipsoid.a, b = datum.ellipsoid.b, f = datum.ellipsoid.f;

            var L = λ2 - λ1;
            var tanU1 = (1 - f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1;
            var tanU2 = (1 - f) * Math.tan(φ2), cosU2 = 1 / Math.sqrt((1 + tanU2 * tanU2)), sinU2 = tanU2 * cosU2;

            var sinλ, cosλ, sinSqσ, sinσ, cosσ, σ, sinα, cosSqα, cos2σM, C;

            var λ = L, λʹ, iterations = 0;
            do {
                sinλ = Math.sin(λ);
                cosλ = Math.cos(λ);
                sinSqσ = (cosU2 * sinλ) * (cosU2 * sinλ) + (cosU1 * sinU2 - sinU1 * cosU2 * cosλ) * (cosU1 * sinU2 - sinU1 * cosU2 * cosλ);
                sinσ = Math.sqrt(sinSqσ);
                if (sinσ == 0) return 0;  // co-incident points
                cosσ = sinU1 * sinU2 + cosU1 * cosU2 * cosλ;
                σ = Math.atan2(sinσ, cosσ);
                sinα = cosU1 * cosU2 * sinλ / sinσ;
                cosSqα = 1 - sinα * sinα;
                cos2σM = cosσ - 2 * sinU1 * sinU2 / cosSqα;
                if (isNaN(cos2σM)) cos2σM = 0;  // equatorial line: cosSqα=0 (§6)
                C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));
                λʹ = λ;
                λ = L + (1 - C) * f * sinα * (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));
            } while (Math.abs(λ - λʹ) > 1e-12 && ++iterations < 200);
            if (iterations >= 200) throw new Error('Formula failed to converge');

            var uSq = cosSqα * (a * a - b * b) / (b * b);
            var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
            var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
            var Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -
                B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));

            var s = b * A * (σ - Δσ);

            var α1 = Math.atan2(cosU2 * sinλ, cosU1 * sinU2 - sinU1 * cosU2 * cosλ);
            var α2 = Math.atan2(cosU1 * sinλ, -sinU1 * cosU2 + cosU1 * sinU2 * cosλ);

            α1 = (α1 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360
            α2 = (α2 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360

            s = Number(s.toFixed(3)); // round to 1mm precision
            return {
                distance: s,
                initialBearing: GeometryUtilities.toDegrees(α1),
                finalBearing: GeometryUtilities.toDegrees(α2)
            };
        }
    },

    isPointInPolygon: {
        value: function (point, polygon) {
            var x = point[0],
                y = point[1],
                inPolygon = false,
                i, j, length,
                x1, y1, x2, y2;

            for (i = 0, j = polygon.length - 1, length = polygon.length; i < length; j = i++) {
                x1 = polygon[i][0];
                y1 = polygon[i][1];
                x2 = polygon[j][0];
                y2 = polygon[j][1];

                if ((y1 < y && y2 >= y || y2 < y && y1 >= y) && (x1 <= x || x2 <= x)) {
                    if (x1 + (y - y1) / (y2 - y1) * (x2 - x1) < x) {
                        inPolygon = !inPolygon;
                    }
                }
            }

            return inPolygon;
        }
    },

    orientation: {
        value: function (tx1, ty1, tx2, ty2, tx3, ty3) {
            var clockWise = ((ty3 - ty1) * (tx2 - tx1)) - ((ty2 - ty1) * (tx3 - tx1));
            return clockWise > 0 ? true : clockWise < 0 ? false : true /* colinear */;
        }
    },

    simplify: {
        value: function (points, tolerance, highestQuality) {
            return simplify(points, tolerance, highestQuality);
        }
    },

    toDegrees: {
        value: function (radians) {
            return radians * 57.29577951308233; // 180 divided by PI;
        }
    },

    toRadians: {
        value: function (degrees) {
            return degrees * (Math.PI / 180.0); // PI divided by 180;
        }
    },

    /**
     * Returns the distance travelling from 'this' point to destination point along a rhumb line.
     *
     * @param   {LatLon} point - Latitude/longitude of destination point.
     * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).
     * @returns {number} Distance in km between this point and destination point (same units as radius).
     *
     * @example
     *     var p1 = new LatLon(51.127, 1.338), p2 = new LatLon(50.964, 1.853);
     *     var d = p1.distanceTo(p2); // Number(d.toPrecision(4)): 40310
     */
    rhumbDistanceBetweenPoints: {
        value: function (startPoint, endPoint, radius) {
            radius = (radius === undefined) ? 6371e3 : Number(radius);

            // see http://williams.best.vwh.net/avform.htm#Rhumb

            var R = radius;
            var φ1 = GeometryUtilities.toRadians(startPoint[1]), φ2 = GeometryUtilities.toRadians(endPoint[1]);
            var Δφ = φ2 - φ1;
            var Δλ = GeometryUtilities.toRadians(Math.abs(endPoint[0] - startPoint[0]));
            // if dLon over 180° take shorter rhumb line across the anti-meridian:
            if (Math.abs(Δλ) > Math.PI) Δλ = Δλ > 0 ? -(2 * Math.PI - Δλ) : (2 * Math.PI + Δλ);

            // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'
            // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it
            var Δψ = Math.log(Math.tan(φ2 / 2 + Math.PI / 4) / Math.tan(φ1 / 2 + Math.PI / 4));
            var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1);

            // distance is pythagoras on 'stretched' Mercator projection
            var δ = Math.sqrt(Δφ * Δφ + q * q * Δλ * Δλ); // angular distance in radians
            var dist = δ * R;

            return dist / 1000;
        }
    },

    rhumbDestinationPoint: {
        value: function (startPoint, distance, bearing, radius) {
            radius = (radius === undefined) ? 6371e3 : Number(radius);

            var δ = Number(distance) / radius; // angular distance in radians
            var φ1 = GeometryUtilities.toRadians(startPoint[1]), λ1 = GeometryUtilities.toRadians(startPoint[0]);
            var θ = GeometryUtilities.toRadians(bearing);

            var Δφ = δ * Math.cos(θ);

            var φ2 = φ1 + Δφ;
            // check for some daft bugger going past the pole, normalise latitude if so
            if (Math.abs(φ2) > Math.PI / 2) φ2 = φ2 > 0 ? Math.PI - φ2 : -Math.PI - φ2;

            var Δψ = Math.log(Math.tan(φ2 / 2 + Math.PI / 4) / Math.tan(φ1 / 2 + Math.PI / 4));
            var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // E-W course becomes ill-conditioned with 0/0

            var Δλ = δ * Math.sin(θ) / q;

            var λ2 = λ1 + Δλ;

            λ2 = (λ2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // normalise to -180..+180°
            return [GeometryUtilities.toDegrees(λ2), GeometryUtilities.toDegrees(φ2)];
        }
    },

    /**
     * Vincenty direct calculation.
     * https://github.com/chrisveness/geodesy/blob/master/latlon-vincenty.js
     * @private
     * @param   {number} distance - Distance along bearing in metres.
     * @param   {number} initialBearing - Initial bearing in degrees from north.
     * @returns (Object} Object including point (destination point), finalBearing.
     * @throws  {Error}  If formula failed to converge.
     */
    vincentyDirect: {
        value: function (point, datum, distance, initialBearing) {
            datum = datum || DATUM;

            var φ1 = GeometryUtilities.toRadians(point[1]), λ1 = GeometryUtilities.toRadians(point[0]);
            var α1 = GeometryUtilities.toRadians(initialBearing);
            var s = distance;

            var a = datum.ellipsoid.a, b = datum.ellipsoid.b, f = datum.ellipsoid.f;

            var sinα1 = Math.sin(α1);
            var cosα1 = Math.cos(α1);

            var tanU1 = (1 - f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1;
            var σ1 = Math.atan2(tanU1, cosα1);
            var sinα = cosU1 * sinα1;
            var cosSqα = 1 - sinα * sinα;
            var uSq = cosSqα * (a * a - b * b) / (b * b);
            var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
            var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));

            var cos2σM, sinσ, cosσ, Δσ;

            var σ = s / (b * A), σʹ, iterations = 0;
            do {
                cos2σM = Math.cos(2 * σ1 + σ);
                sinσ = Math.sin(σ);
                cosσ = Math.cos(σ);
                Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -
                    B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));
                σʹ = σ;
                σ = s / (b * A) + Δσ;
            } while (Math.abs(σ - σʹ) > 1e-12 && ++iterations < 200);
            if (iterations >= 200) throw new Error('Formula failed to converge'); // not possible?

            var x = sinU1 * sinσ - cosU1 * cosσ * cosα1;
            var φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - f) * Math.sqrt(sinα * sinα + x * x));
            var λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);
            var C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));
            var L = λ - (1 - C) * f * sinα *
                (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));
            //var λ2 = (λ1+L+3*Math.PI)%(2*Math.PI) - Math.PI;  // normalise to -180...+180
            var λ2 = (λ1 + L); // do not normalize
            var α2 = Math.atan2(sinα, -x);
            α2 = (α2 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360

            return {
                point: [GeometryUtilities.toDegrees(λ2), GeometryUtilities.toDegrees(φ2)],
                finalBearing: GeometryUtilities.toDegrees(α2)
            };
        }
    },

    zoomLevelForRange: {
        value: function (range) {
            var zoom = 19 - Math.log(range / 1000 * 5.508) / Math.LN2;
            if (zoom < 1) {
                return 1;
            }
            return Math.round(zoom);
        }
    },

    rangeForZoomLevel: {
        value: function (zoomLevel) {
            //this equation is a transformation of the angular size equation solving for D. See: http://en.wikipedia.org/wiki/Forced_perspective
            var range,
                angularHeight = .05 * ((591657550.5 / (Math.pow(2, (zoomLevel - 1)))) / 2);//amount displayed is .05 meters and map scale =591657550.5/(Math.pow(2,(mapzoom-1))))
            //this bit ^ essentially gets the h value in the angular size eq then divides it by 2
            range = angularHeight * (Math.cos(GeometryUtilities.toRadians(85.362 / 2)) / (Math.sin(GeometryUtilities.toRadians(85.362 / 2)))); //85.362 is angle which google maps displays on a 5cm wide screen
            return range;
        }
    },

    zoomLevelForScale: {
        value: function (scale) {
            var closestDistance = Infinity,
                zoomLevel = 0,
                distance, i, length;

            if (scale) {
                for (i = 0, length = ZoomLevelScales.length; i < length; i++) {
                    distance = Math.abs(ZoomLevelScales[i] - scale);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        zoomLevel = ZoomLevelScales.length - i;
                    }
                }
            }

            return zoomLevel;
        }
    }

});
