/**
 * @module logic/map/converters/geojson.js
 * @requires montage
 */
var Montage = require("montage").Montage;

exports.GeoJson = Montage.specialize({}, {
    toKml: {
        value: function parse(geojson, options) {
            options = options || {
                    documentName: undefined,
                    documentDescription: undefined,
                    name: "Name",
                    description: "Description",
                    simplestyle: true,
                    timestamp: "timestamp"
                };

            return "<?xml version='1.0' encoding='UTF-8'?>" +
                StrXML.tag("kml",
                    StrXML.tag("Document",
                        this._documentName(options) +
                        this._documentDescription(options) +
                        this._root(geojson, options)
                    ), [["xmlns", "http://www.opengis.net/kml/2.2"]]);
        }
    },
    toGpx: {
        value: function toGpx(geojson, options) {
            options = (function (defaults, options) {
                for (var k in defaults) {
                    if (options.hasOwnProperty(k))
                        defaults[k] = options[k];
                }
                return defaults;
            })({
                creator: "togpx",
                metadata: undefined,
                featureTitle: get_feature_title,
                featureDescription: get_feature_description,
                featureLink: undefined
            }, options || {});

            function get_feature_title(props) {
                // a simple default heuristic to determine a title for a given feature
                // uses a nested `tags` object or the feature's `properties` if present
                // and then searchs for the following properties to construct a title:
                // `name`, `ref`, `id`
                if (typeof props.tags === "object") {
                    var tags_title = get_feature_title(props.tags);
                    if (tags_title !== "")
                        return tags_title;
                }
                if (props.name)
                    return props.name;
                if (props.ref)
                    return props.ref;
                if (props.id)
                    return props.id;
                return "";
            }
            function get_feature_description(props) {
                // constructs a description for a given feature
                // uses a nested `tags` object or the feature's `properties` if present
                // and then concatenates all properties to construct a description.
                if (typeof props.tags === "object")
                    return get_feature_description(props.tags);
                var res = "";
                for (var k in props) {
                    if (typeof props[k] === "object")
                        continue;
                    res += k+"="+props[k]+"\n";
                }
                return res.substr(0,res.length-1);
            }
            function add_feature_link(o, f) {
                if (options.featureLink)
                    o.link = { "@href": options.featureLink(f.properties) }
            }
            // make gpx object
            var gpx = {"gpx": {
                "@xmlns":"http://www.topografix.com/GPX/1/1",
                "@xmlns:xsi":"http://www.w3.org/2001/XMLSchema-instance",
                "@xsi:schemaLocation":"http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd",
                "@version":"1.1",
                "wpt": [],
                "trk": [],
            }};
            if (options.creator)
                gpx.gpx["@creator"] = options.creator;
            if (options.metadata)
                gpx.gpx["metadata"] = options.metadata;

            var features;
            if (geojson.type === "FeatureCollection")
                features = geojson.features;
            else if (geojson.type === "Feature")
                features = [geojson];
            else
                features = [{type:"Feature", properties: {}, geometry: geojson}];
            features.forEach(function mapFeature(f) {
                switch (f.geometry.type) {
                    // POIs
                    case "Point":
                    case "MultiPoint":
                        var coords = f.geometry.coordinates;
                        if (f.geometry.type == "Point") coords = [coords];
                        coords.forEach(function (coordinates) {
                            o = {
                                "@lat": coordinates[1],
                                "@lon": coordinates[0],
                                "name": options.featureTitle(f.properties),
                                "desc": options.featureDescription(f.properties)
                            };
                            add_feature_link(o,f);
                            gpx.gpx.wpt.push(o);
                        });
                        break;
                    // LineStrings
                    case "LineString":
                    case "MultiLineString":
                        var coords = f.geometry.coordinates;
                        if (f.geometry.type == "LineString") coords = [coords];
                        o = {
                            "name": options.featureTitle(f.properties),
                            "desc": options.featureDescription(f.properties)
                        };
                        add_feature_link(o,f);
                        o.trkseg = [];
                        coords.forEach(function(coordinates) {
                            var seg = {trkpt: []};
                            coordinates.forEach(function(c) {
                                seg.trkpt.push({"@lat": c[1], "@lon":c[0]});
                            });
                            o.trkseg.push(seg);
                        });
                        gpx.gpx.trk.push(o);
                        break;
                    // Polygons / Multipolygons
                    case "Polygon":
                    case "MultiPolygon":
                        o = {
                            "name": options.featureTitle(f.properties),
                            "desc": options.featureDescription(f.properties)
                        };
                        add_feature_link(o,f);
                        o.trkseg = [];
                        var coords = f.geometry.coordinates;
                        if (f.geometry.type == "Polygon") coords = [coords];
                        coords.forEach(function(poly) {
                            poly.forEach(function(ring) {
                                var seg = {trkpt: []};
                                ring.forEach(function(c) {
                                    seg.trkpt.push({"@lat": c[1], "@lon":c[0]});
                                });
                                o.trkseg.push(seg);
                            });
                        });
                        gpx.gpx.trk.push(o);
                        break;
                    case "GeometryCollection":
                        f.geometry.geometries.forEach(function (geometry) {
                            var pseudo_feature = {
                                "properties": f.properties,
                                "geometry": geometry
                            };
                            mapFeature(pseudo_feature);
                        });
                        break;
                    default:
                        console.log("warning: unsupported geometry type: "+f.geometry.type);
                }
            });
            gpx_str = JXON.stringify(gpx);
            return gpx_str;
        }
    },
    fromGpx: {
        value: function (doc) {
            // all Y children of X
            function get(x, y) { return x.getElementsByTagName(y); }

            function attr(x, y) { return x.getAttribute(y); }

            function attrf(x, y) { return parseFloat(attr(x, y)); }

            // one Y child of X, if any, otherwise null
            function get1(x, y) {
                var n = get(x, y);
                return n.length ? n[0] : null;
            }

            // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize
            function norm(el) {
                if (el.normalize) {
                    el.normalize();
                }
                return el;
            }

            function clean(x) {
                var o = {}, i;
                for (i in x) {
                    if (x[i]) {
                        o[i] = x[i];
                    }
                }
                return o;
            }

            // get the content of a text node, if any
            function nodeVal(x) {
                if (x) {
                    norm(x);
                }
                return (x && x.textContent) || "";
            }

            function coordPair(x) {
                var ll = [attrf(x, "lon"), attrf(x, "lat")],
                    ele = get1(x, "ele"),
                    heartRate = get1(x, "gpxtpx:hr") || get1(x, "hr"), // handle namespaced attribute in browser
                    time = get1(x, "time"),
                    e;
                if (ele) {
                    e = parseFloat(nodeVal(ele));
                    if (!isNaN(e)) {
                        ll.push(e);
                    }
                }
                return {
                    coordinates: ll,
                    time: time ? nodeVal(time) : null,
                    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null
                };
            }

            // create a new feature collection parent object
            function fc() {
                return {
                    type: "FeatureCollection",
                    features: []
                };
            }

            var i,
                tracks = get(doc, "trk"),
                routes = get(doc, "rte"),
                waypoints = get(doc, "wpt"),
                gj = fc(), // a feature collection

                feature;
            for (i = 0; i < tracks.length; i++) {
                feature = getTrack(tracks[i]);
                if (feature) gj.features.push(feature);
            }
            for (i = 0; i < routes.length; i++) {
                feature = getRoute(routes[i]);
                if (feature) gj.features.push(feature);
            }
            for (i = 0; i < waypoints.length; i++) {
                gj.features.push(getPoint(waypoints[i]));
            }
            function getPoints(node, pointname) {
                var pts = get(node, pointname),
                    line = [],
                    times = [],
                    heartRates = [],
                    l = pts.length,
                    i, c;

                if (l < 2) return {};  // Invalid line in GeoJSON

                for (i = 0; i < l; i++) {
                    c = coordPair(pts[i]);
                    line.push(c.coordinates);
                    if (c.time) times.push(c.time);
                    if (c.heartRate) heartRates.push(c.heartRate);
                }

                return {
                    line: line,
                    times: times,
                    heartRates: heartRates
                };
            }

            function getTrack(node) {
                var segments = get(node, "trkseg"),
                    track = [],
                    times = [],
                    heartRates = [],
                    line, i, properties;

                for (i = 0; i < segments.length; i++) {
                    line = getPoints(segments[i], "trkpt");
                    if (line.line) track.push(line.line);
                    if (line.times && line.times.length) times.push(line.times);
                    if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);
                }

                if (track.length === 0) return;
                properties = getProperties(node);
                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;
                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;
                return {
                    type: "Feature",
                    properties: properties,
                    geometry: {
                        type: track.length === 1 ? "LineString" : "MultiLineString",
                        coordinates: track.length === 1 ? track[0] : track
                    }
                };
            }

            function getRoute(node) {
                var line = getPoints(node, "rtept"),
                    routeObj;

                if (!line) return;
                routeObj = {
                    type: "Feature",
                    properties: getProperties(node),
                    geometry: {
                        type: "LineString",
                        coordinates: line.line
                    }
                };
                return routeObj;
            }

            function getPoint(node) {
                var prop = getProperties(node);
                prop.sym = nodeVal(get1(node, "sym"));
                return {
                    type: "Feature",
                    properties: prop,
                    geometry: {
                        type: "Point",
                        coordinates: coordPair(node).coordinates
                    }
                };
            }

            function getProperties(node) {
                var meta = ["name", "desc", "author", "copyright", "link",
                        "time", "keywords"],
                    prop = {},
                    k;
                for (k = 0; k < meta.length; k++) {
                    prop[meta[k]] = nodeVal(get1(node, meta[k]));
                }
                return clean(prop);
            }

            return gj;
        }
    },
    _feature: {
        value: function _feature(options) {
            return function (_) {
                var styleDefinition = "",
                    styleReference = "",
                    geometryString, styleUrl;

                if (options.simplestyle && this._hasStyle(_.properties)) {
                    if (!this._allreadyAddStyle(_.properties)) {
                        styleDefinition = this._style(_.properties);
                    }
                    styleReference = StrXML.tag("styleUrl", "#" + this._getStyleUrl(_.properties));
                }
                if (!_.properties || !Geometry.valid(_.geometry)) return "";

                geometryString = Geometry.any(_.geometry);

                if (!geometryString) return "";
                return styleDefinition + StrXML.tag("Placemark",
                        this._name(_.properties, options) +
                        this._description(_.properties, options) +
                        this._extendeddata(_.properties) +
                        this._timestamp(_.properties, options) +
                        geometryString +
                        styleReference);
            };
        }
    },
    _root: {
        value: function _root(_, options) {
            if (!_.type) return "";
            switch (_.type) {
                case "FeatureCollection":
                    if (!_.features) return "";
                    return _.features.map(this._feature(options).bind(this)).join("");
                case "Feature":
                    return this._feature(options)(_);
                default:
                    return this._feature(options)({
                        type: "Feature",
                        geometry: _,
                        properties: {}
                    });
            }
        }
    },
    _documentName: {
        value: function _documentName(options) {
            return (options.documentName !== undefined) ? StrXML.tag("name", options.documentName) : "";
        }
    },
    _documentDescription: {
        value: function _documentDescription(options) {
            return (options.documentDescription !== undefined) ? StrXML.tag("description", options.documentDescription) : "";
        }
    },
    _name: {
        value: function _name(_, options) {
            return _[options.name] ? StrXML.tag("name", StrXML.encode(_[options.name])) : "";
        }
    },
    _description: {
        value: function _description(_, options) {
            return _[options.description] ? StrXML.tag("description", StrXML.encode(_[options.description])) : "";
        }
    },
    _timestamp: {
        value: function _timestamp(_, options) {
            return _[options.timestamp] ? StrXML.tag("TimeStamp", StrXML.tag("when", StrXML.encode(_[options.timestamp]))) : "";
        }
    },
    _extendeddata: {
        value: function _extendeddata(_) {
            return StrXML.tag("ExtendedData", this._pairs(_).map(this._data.bind(this)).join(""));
        }
    },
    _data: {
        value: function _data(_) {
            if (!_[1] || typeof _[1] === "object") {
                return "";
            }
            return StrXML.tag("Data", StrXML.tag("value", StrXML.encode(_[1])), [["name", StrXML.encode(_[0])]]);
        }
    },
    _style: {
        value: function _iconstyle(_) {
            var style = _.style;
            return StrXML.tag("Style",
                this._iconStyle(style) +
                this._polyStyle(style) +
                this._lineStyle(style),
                [["id", this._getStyleUrl(_)]]
            );
        }
    },
    _polyStyle: {
        value: function (_) {
            if (!_.fillColor) {
                return "";
            }
            return StrXML.tag("PolyStyle",
                _.fillColor ? StrXML.tag("color", this._getColor(_.fillColor, _.fillOpacity)) : "" +
                StrXML.tag("fill", 1) +
                (_.strokeWeight || _.strokeColor) ? StrXML.tag("outline", 1) : ""
            );
        }
    },
    _lineStyle: {
        value: function (_) {
            if (!_.strokeColor && !_.strokeWeight) {
                return "";
            }
            return StrXML.tag("LineStyle",
                _.strokeColor ? StrXML.tag("color", this._getColor(_.strokeColor, _.strokeOpacity)) : "" +
                _.strokeWeight ? StrXML.tag("width", _.strokeWeight) : ""
            );
        }
    },
    _iconStyle: {
        value: function (_) {
            var url = this._iconUrl(_);
            return url ? StrXML.tag("IconStyle",
                StrXML.tag("Icon",
                    StrXML.tag("href", url)) +
                this._iconSize(_)
            ) : "";
        }
    },
    _iconUrl: {
        value: function _iconUrl(_) {
            return _.url;
        }
    },
    _iconSize: {
        value: function _iconSize(_) {
            var units = "fraction",
                scale = 1,
                x = 0.5,
                y = 0.5;

            if (_.size && _.scaledSize) {
                scale = _.scaledSize.width / _.size.width;
            }

            if (_.anchor) {
                units = "pixels";
                x = _.anchor.x;
                y = _.anchor.y;
            }

            return StrXML.tag("scale", scale) +
                StrXML.tag("hotSpot", "", [
                    ["xunits", units],
                    ["yunits", units],
                    ["x", x],
                    ["y", y]
                ]);
        }
    },
    _styleCounter: {
        value: 0
    },
    _getStyleUrl: {
        value: function _getStyleUrl(_) {
            if (!_.style) {
                return null;
            }
            return _.style["#styleUrl"] || (_.style["#styleUrl"] = "Style" + this._styleCounter++);
        }
    },
    _allreadyAddStyle: {
        value: function (_) {
            return _.style && _.style["#styleUrl"];
        }
    },
    _hasStyle: {
        value: function (_) {
            return !!_.style;
        }
    },
    _pairs: {
        value: function _pairs(_) {
            var o = [], i;
            for (i in _) {
                if (_.hasOwnProperty(i)) {
                    o.push([i, _[i]]);
                }
            }
            return o;
        }
    },

    _getFeatureTitle: {
        value: function _getFeatureTitle(props) {
            var tagsTitle;

            if (typeof props.tags === "object") {
                tagsTitle = this._getFeatureTitle(props.tags);
                if (tagsTitle !== "") {
                    return tagsTitle;
                }
            }
            if (props.name) {
                return props.name;
            }
            if (props.ref) {
                return props.ref;
            }
            if (props.id) {
                return props.id;
            }
            return "";
        }
    },
    _getFeatureDescription: {
        value: function _getFeatureDescription(props) {
            var res = "",
                k;

            if (typeof props.tags === "object") {
                return this._getFeatureDescription(props.tags);
            }

            for (k in props) {
                if (props.hasOwnProperty(k)) {
                    if (typeof props[k] === "object") {
                        continue;
                    }
                    res += k + "=" + props[k] + "\n";
                }
            }
            return res.substr(0, res.length - 1);
        }
    },
    _getColor: {
        value: function (color, opactiy) {
            color = color.replace("#", "");
            if (opactiy !== undefined) {
                opactiy = Math.round((255 * opactiy)).toString(16);
            } else {
                opactiy = "ff";
            }
            return opactiy + color[4] + color[5] + color[2] + color[3] + color[0] + color[1];
        }
    }
});

var StrXML = Montage.specialize({}, {
        attr: {
            /**
             * @param {Array} _ an array of attributes
             * @returns {string}
             */
            value: function attr(_) {
                return (_ && _.length) ? (" " + _.map(function (a) {
                    return a[0] + "='" + a[1] + "'";
                }).join(" ")) : "";
            }
        },
        tagClose: {
            /**
             * @param {string} el element name
             * @param {Array} attributes array of pairs
             * @returns {string}
             */
            value: function tagClose(el, attributes) {
                return "<" + el + this.attr(attributes) + "/>";
            }
        },
        tag: {
            /**
             * @param {string} el element name
             * @param {string} contents innerXML
             * @param {Array} attributes array of pairs
             * @returns {string}
             */
            value: function tag(el, contents, attributes) {
                return "<" + el + this.attr(attributes) + (contents ? (">" + contents + "</" + el + ">") : "/>");
            }
        },
        encode: {
            /**
             * @param {string} _ a string of attribute
             * @returns {string}
             */
            value: function encode(_) {
                return (_ === null ? "" : _.toString()).replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;");
            }
        }
    }),
    Geometry = Montage.specialize({}, {
        Point: {
            value: function (_) {
                return StrXML.tag("Point", StrXML.tag("coordinates", _.coordinates.join(",")));
            }
        },
        LineString: {
            value: function (_) {
                return StrXML.tag("LineString", StrXML.tag("coordinates", Geometry._linearring(_.coordinates)));
            }
        },
        Polygon: {
            value: function (_) {
                if (!_.coordinates.length) return "";
                var outer = _.coordinates[0],
                    inner = _.coordinates.slice(1),
                    outerRing = StrXML.tag("outerBoundaryIs", StrXML.tag("LinearRing", StrXML.tag("coordinates", Geometry._linearring(outer)))),
                    innerRings = inner.map(function (i) {
                        return StrXML.tag("innerBoundaryIs",
                            StrXML.tag("LinearRing", StrXML.tag("coordinates", Geometry._linearring(i))));
                    }).join("");
                return StrXML.tag("Polygon", outerRing + innerRings);
            }
        },
        MultiPoint: {
            value: function (_) {
                if (!_.coordinates.length) return "";
                return StrXML.tag("MultiGeometry", _.coordinates.map(function (c) {
                    return Geometry.Point({coordinates: c});
                }).join(""));
            }
        },
        MultiPolygon: {
            value: function (_) {
                if (!_.coordinates.length) return "";
                return StrXML.tag("MultiGeometry", _.coordinates.map(function (c) {
                    return Geometry.Polygon({coordinates: c});
                }).join(""));
            }
        },
        MultiLineString: {
            value: function (_) {
                if (!_.coordinates.length) return "";
                return StrXML.tag("MultiGeometry", _.coordinates.map(function (c) {
                    return Geometry.LineString({coordinates: c});
                }).join(""));
            }
        },
        GeometryCollection: {
            value: function (_) {
                return StrXML.tag("MultiGeometry",
                    _.geometries.map(Geometry.any).join(""));
            }
        },
        valid: {
            value: function (_) {
                return _ && _.type && (_.coordinates ||
                    _.type === "GeometryCollection" && _.geometries.every(Geometry.valid));
            }
        },
        any: {
            value: function (_) {
                if (Geometry[_.type]) {
                    return Geometry[_.type](_);
                } else {
                    return "";
                }
            }
        },
        _linearring: {
            value: function _linearring(_) {
                return _.map(function (cds) { return cds.join(","); }).join(" ");
            }
        }
    }),
    JXON = new (function () {
    var
        sValueProp = "keyValue", sAttributesProp = "keyAttributes", sAttrPref = "@", /* you can customize these values */
        aCache = [], rIsNull = /^\s*$/, rIsBool = /^(?:true|false)$/i;

    function parseText (sValue) {
        if (rIsNull.test(sValue)) { return null; }
        if (rIsBool.test(sValue)) { return sValue.toLowerCase() === "true"; }
        if (isFinite(sValue)) { return parseFloat(sValue); }
        if (isFinite(Date.parse(sValue))) { return new Date(sValue); }
        return sValue;
    }

    function EmptyTree () { }
    EmptyTree.prototype.toString = function () { return "null"; };
    EmptyTree.prototype.valueOf = function () { return null; };

    function objectify (vValue) {
        return vValue === null ? new EmptyTree() : vValue instanceof Object ? vValue : new vValue.constructor(vValue);
    }

    function createObjTree (oParentNode, nVerb, bFreeze, bNesteAttr) {
        var
            nLevelStart = aCache.length, bChildren = oParentNode.hasChildNodes(),
            bAttributes = oParentNode.hasAttributes(), bHighVerb = Boolean(nVerb & 2);

        var
            sProp, vContent, nLength = 0, sCollectedTxt = "",
            vResult = bHighVerb ? {} : /* put here the default value for empty nodes: */ true;

        if (bChildren) {
            for (var oNode, nItem = 0; nItem < oParentNode.childNodes.length; nItem++) {
                oNode = oParentNode.childNodes.item(nItem);
                if (oNode.nodeType === 4) { sCollectedTxt += oNode.nodeValue; } /* nodeType is "CDATASection" (4) */
                else if (oNode.nodeType === 3) { sCollectedTxt += oNode.nodeValue.trim(); } /* nodeType is "Text" (3) */
                else if (oNode.nodeType === 1 && !oNode.prefix) { aCache.push(oNode); } /* nodeType is "Element" (1) */
            }
        }

        var nLevelEnd = aCache.length, vBuiltVal = parseText(sCollectedTxt);

        if (!bHighVerb && (bChildren || bAttributes)) { vResult = nVerb === 0 ? objectify(vBuiltVal) : {}; }

        for (var nElId = nLevelStart; nElId < nLevelEnd; nElId++) {
            sProp = aCache[nElId].nodeName.toLowerCase();
            vContent = createObjTree(aCache[nElId], nVerb, bFreeze, bNesteAttr);
            if (vResult.hasOwnProperty(sProp)) {
                if (vResult[sProp].constructor !== Array) { vResult[sProp] = [vResult[sProp]]; }
                vResult[sProp].push(vContent);
            } else {
                vResult[sProp] = vContent;
                nLength++;
            }
        }

        if (bAttributes) {
            var
                nAttrLen = oParentNode.attributes.length,
                sAPrefix = bNesteAttr ? "" : sAttrPref, oAttrParent = bNesteAttr ? {} : vResult;

            for (var oAttrib, nAttrib = 0; nAttrib < nAttrLen; nLength++, nAttrib++) {
                oAttrib = oParentNode.attributes.item(nAttrib);
                oAttrParent[sAPrefix + oAttrib.name.toLowerCase()] = parseText(oAttrib.value.trim());
            }

            if (bNesteAttr) {
                if (bFreeze) { Object.freeze(oAttrParent); }
                vResult[sAttributesProp] = oAttrParent;
                nLength -= nAttrLen - 1;
            }
        }

        if (nVerb === 3 || (nVerb === 2 || nVerb === 1 && nLength > 0) && sCollectedTxt) {
            vResult[sValueProp] = vBuiltVal;
        } else if (!bHighVerb && nLength === 0 && sCollectedTxt) {
            vResult = vBuiltVal;
        }

        if (bFreeze && (bHighVerb || nLength > 0)) { Object.freeze(vResult); }

        aCache.length = nLevelStart;

        return vResult;
    }

    function loadObjTree (oXMLDoc, oParentEl, oParentObj) {
        var vValue, oChild;

        if (oParentObj instanceof String || oParentObj instanceof Number || oParentObj instanceof Boolean) {
            oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toString())); /* verbosity level is 0 */
        } else if (oParentObj.constructor === Date) {
            oParentEl.appendChild(oXMLDoc.createTextNode(oParentObj.toGMTString()));
        }

        for (var sName in oParentObj) {
            vValue = oParentObj[sName];
            if (isFinite(sName) || vValue instanceof Function) { continue; } /* verbosity level is 0 */
            if (sName === sValueProp) {
                if (vValue !== null && vValue !== true) { oParentEl.appendChild(oXMLDoc.createTextNode(vValue.constructor === Date ? vValue.toGMTString() : String(vValue))); }
            } else if (sName === sAttributesProp) { /* verbosity level is 3 */
                for (var sAttrib in vValue) { oParentEl.setAttribute(sAttrib, vValue[sAttrib]); }
            } else if (sName.charAt(0) === sAttrPref) {
                oParentEl.setAttribute(sName.slice(1), vValue);
            } else if (vValue.constructor === Array) {
                for (var nItem = 0; nItem < vValue.length; nItem++) {
                    oChild = oXMLDoc.createElement(sName);
                    loadObjTree(oXMLDoc, oChild, vValue[nItem]);
                    oParentEl.appendChild(oChild);
                }
            } else {
                oChild = oXMLDoc.createElement(sName);
                if (vValue instanceof Object) {
                    loadObjTree(oXMLDoc, oChild, vValue);
                } else if (vValue !== null && vValue !== true) {
                    oChild.appendChild(oXMLDoc.createTextNode(vValue.toString()));
                }
                oParentEl.appendChild(oChild);
            }
        }
    }

    this.build = function (oXMLParent, nVerbosity /* optional */, bFreeze /* optional */, bNesteAttributes /* optional */) {
        var _nVerb = arguments.length > 1 && typeof nVerbosity === "number" ? nVerbosity & 3 : /* put here the default verbosity level: */ 1;
        return createObjTree(oXMLParent, _nVerb, bFreeze || false, arguments.length > 3 ? bNesteAttributes : _nVerb === 3);
    };

    this.unbuild = function (oObjTree) {
        var oNewDoc = document.implementation.createDocument("", "", null);
        loadObjTree(oNewDoc, oNewDoc, oObjTree);
        return oNewDoc;
    };

    this.stringify = function (oObjTree) {
        return (new XMLSerializer()).serializeToString(JXON.unbuild(oObjTree));
    };
})();
