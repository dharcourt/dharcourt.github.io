/**
 * @module logic/map/converters/map-data-converter.js
 * @requires montage/ui/component
 */
var Montage = require("montage").Montage,
    Target = require("montage/core/target").Target;

// from http://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-clone-a-javascript-object
// http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone
function clone(obj) {
    if (obj === null || typeof obj != "object") {
        return obj;
    }
    if (obj.cloneNode) {
        return obj.cloneNode(true);
    }
    var temp = new obj.constructor();
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            temp[key] = clone(obj[key]);
        }
    }
    return temp;
}

var KmlHelper = exports.KmlHelper = Montage.specialize({}, {
        _domParser: {
            value: null
        },
        domParser: {
            get: function () {
                if (!this._domParser) {
                    this._domParser = new DOMParser();
                }
                return this._domParser;
            }
        },

        KML_NS: {
            value: "http://www.opengis.net/kml/2.2"
        },
        GX_NS: {
            value: "http://www.google.com/kml/ext/2.2"
        },

        /**
         * Parses a XML string.
         *
         * <p>Parses the given XML string and returns the parsed document in a
         * DOM data structure. This function will return an empty DOM node if
         * XML parsing is not supported in this browser.</p>
         *
         * @param {string} str XML string.
         * @return {Document | null} return null if str isn"t a string.
         */
        parseXml: {
            value: function parseXml(str) {
                if (typeof str !== "string") {
                    return null;
                }
                return this.domParser.parseFromString(str, "text/xml");
            }
        },
        nodeValue: {
            /**
             * Extract the text value of a DOM node, with leading and trailing whitespace trimmed.
             *
             * @param {Element} node XML node/element.
             * @param {Any} defVal Default value if the node doesn't exist.
             * @return {string|null}
             */
            value: function nodeValue(node, defVal) {
                var retStr = "";
                if (!node) {
                    return (typeof defVal === "undefined" || defVal === null) ? null : defVal;
                }
                if (node.nodeType === 3 || node.nodeType === 4 || node.nodeType === 2) {
                    retStr += node.nodeValue;
                } else if (node.nodeType === 1 || node.nodeType === 9 || node.nodeType === 11) {
                    for (var i = 0; i < node.childNodes.length; ++i) {
                        retStr += nodeValue(node.childNodes[i]);
                    }
                }

                return retStr;
            }
        },
        nodeValueByTagNameNs: {
            value: function nodeValueNs(node, ns, tagName, defVal) {
                node = node.getElementsByTagNameNS(ns, tagName)[0];
                if (!node) {
                    return defVal;
                }
                return this.nodeValue(node, defVal);
            }
        },
        nodeValueByTagName: {
            value: function nodeValueByTagName(node, tagName, defVal) {
                node = node.getElementsByTagName(tagName)[0];
                if (!node) {
                    return defVal;
                }
                return this.nodeValue(node, defVal);
            }
        },
        getBooleanValue: {
            /**
             * Loosely translate various values of a DOM node to a boolean.
             *
             * @param {Element} node XML node/element.
             * @param {boolean} defVal Default value if the node doesn't exist.
             * @return {boolean|null}
             */
            value: function getBooleanValue(node, defVal) {
                var nodeContents = this.nodeValue(node);

                if (nodeContents === null) return defVal || false;

                nodeContents = parseInt(nodeContents);

                return isNaN(nodeContents) || nodeContents !== 0;
            }
        },
        getBooleanValueByTagName: {
            value: function getBooleanValueByTagName(node, tagName, defVal) {
                node = node.getElementsByTagName(tagName)[0];
                if (!node) {
                    return defVal;
                }
                return this.getBooleanValue(node, defVal);
            }
        },
        getBaloonVisibility: {
            value: function getBaloonVisibility(node) {
                var nodes = node.getElementsByTagNameNS(KmlHelper.GX_NS, "balloonVisibility");
                return this.getBooleanValue(nodes[0], false);
            }
        },
        getOpacity: {
            /**
             * Extract opacity from KML color value
             *
             * @param {string} kmlColor - color in #FFFFFF like format
             * @returns {number} Returns number between 0 and 1
             */
            value: function getOpacity(kmlColor) {
                // Extract opacity encoded in a KML color value. Returns a number between 0 and 1.
                if (!!kmlColor &&
                    (kmlColor !== "") &&
                    (kmlColor.length === 8)) {
                    var transparency = parseInt(kmlColor.substr(0, 2), 16);
                    return transparency / 255;
                } else {
                    return 1;
                }
            }
        },
        kmlColor: {
            value: function (kmlIn, colorMode) {
                var kmlColor = {};
                kmlIn = kmlIn || "ffffffff";  // white (KML 2.2 default)

                var aa = kmlIn.substr(0, 2),
                    bb = kmlIn.substr(2, 2),
                    gg = kmlIn.substr(4, 2),
                    rr = kmlIn.substr(6, 2);

                kmlColor.opacity = parseInt(aa, 16) / 256;
                kmlColor.color = (colorMode === "random") ? this.randomColor(rr, gg, bb) : "#" + rr + gg + bb;
                return kmlColor;
            }
        },
        randomColor: {
            value: function randomColor(rr, gg, bb) {
                var col = {
                    rr: rr,
                    gg: gg,
                    bb: bb
                };

                for (var k in col) {
                    if (col.hasOwnProperty(k)) {
                        var v = col[k];

                        if (v === null) {
                            v = "ff";
                        }

                        // RGB values are limiters for random numbers (ie: 7f would be a random value between 0 and 7f)
                        v = Math.round(Math.random() * parseInt(rr, 16)).toString(16);
                        if (v.length === 1) {
                            v = "0" + v;
                        }
                        col[k] = v;
                    }
                }

                return "#" + col.rr + col.gg + col.bb;
            }
        },
        processCoordinates: {
            value: function processCoordinates(node) {
                var coords = KmlHelper.nodeValue(node).trim(),
                    coordinates = [],
                    len, path;

                coords = coords.replace(/,\s+/g, ",");
                path = coords.split(/\s+/g);
                len = path.length;

                for (var k = 0; k < len; k++) {
                    coords = path[k].split(",").map(parseFloat);
                    if (!isNaN(coords[0]) && !isNaN(coords[1])) {
                        coordinates.push(coords);
                    }
                }

                if (coordinates.length === 1) {
                    return coordinates[0];
                }

                return coordinates;
            }
        },
        processSimpleGeometry: {
            value: function processSimpleGeometry(node, type) {
                var points = node.getElementsByTagName(type),
                    len = points.length,
                    geometry = [],
                    i, coordNode;

                for (i = 0; i < len; i++) {
                    coordNode = points[i].getElementsByTagName("coordinates")[0];
                    geometry.push({
                        type: type,
                        coordinates: this.processCoordinates(coordNode)
                    });
                }
                return geometry;
            }
        },
        processPoints: {
            value: function processPoints(node) {
                return this.processSimpleGeometry(node, "Point");
            }
        },
        processLineStrings: {
            value: function processLineStrings(node) {
                return this.processSimpleGeometry(node, "LineString");
            }
        },
        processPolygons: {
            value: function processPolygons(node) {
                var polygons = node.getElementsByTagName("Polygon"),
                    len = polygons.length,
                    geometry = [],
                    i, polygon, outerBoundaryIs, innerBoundaryIs,
                    coordNodes, coordinates;

                for (i = 0; i < len; i++) {
                    coordinates = [];

                    polygon = polygons[i];

                    outerBoundaryIs = polygon.getElementsByTagName("outerBoundaryIs")[0];
                    innerBoundaryIs = polygon.getElementsByTagName("innerBoundaryIs")[0];

                    if (!outerBoundaryIs) {
                        continue;
                    }

                    coordNodes = outerBoundaryIs.getElementsByTagName("coordinates");

                    if (coordNodes.length === 0) {
                        continue;
                    }

                    coordNodes = [].slice.call(coordNodes);

                    if (innerBoundaryIs) {
                        coordNodes = [].concat.apply(coordNodes, innerBoundaryIs.getElementsByTagName("coordinates"));
                    }

                    coordinates = coordNodes.map(this.processCoordinates);

                    geometry.push({
                        type: "Polygon",
                        coordinates: coordinates
                    });
                }

                return geometry;
            }
        }
    }),
    UrlHelper = exports.UrlHelper = Montage.specialize({}, {
        toAbsURL: {
            /**
             * Turn a directory + relative URL into an absolute one.
             *
             * @private
             * @param {string} d Base directory.
             * @param {string} s Relative URL.
             * @return {string} Absolute URL.
             * @author Brendan Byrd
             */
            value: function (d, s) {
                var p, f, i,
                    h = location.protocol + "://" + location.host;

                if (!s.length)           return "";
                if (/^\w+:/.test(s))     return s;
                if (s.indexOf("/") === 0) return h + s;

                p = d.replace(/\/[^\/]*$/, "");
                f = s.match(/\.\.\//g);
                if (f) {
                    s = s.substring(f.length * 3);
                    for (i = f.length; i--;) {
                        p = p.substring(0, p.lastIndexOf("/"));
                    }
                }

                return h + p + "/" + s;
            }
        },

        defileURL: {
            /**
             * Remove filename from URL
             *
             * @private
             * @param {string} s Relative URL.
             * @return {string} Base directory.
             * @author Brendan Byrd
             */
            value: function (s) {
                return s ? s.substr(0, s.lastIndexOf("/") + 1) : "/";
            }
        },
        dehostURL: {
            /**
             * Remove current host from URL
             *
             * @private
             * @param {string} s Absolute or relative URL.
             * @return {string} Root-based relative URL.
             * @author Brendan Byrd
             */
            value: function (s) {
                var h = location.protocol + "://" + location.host;
                h = h.replace(/([\.\\\+\*\?\[\^\]\$\(\)])/g, "\\$1");
                return s.replace(new RegExp("^" + h, "i"), "");
            }
        },
        cleanURL: {
            /**
             * Removes all query strings, #IDs, "../" references, and
             * hosts from a URL.
             *
             * @private
             * @param {string} d Base directory.
             * @param {string} s Absolute or relative URL.
             * @return {string} Root-based relative URL.
             * @author Brendan Byrd
             */
            value: function (d, s) {
                if (d) {
                    d = d.split("#")[0].split("?")[0];
                } else {
                    d = UrlHelper.defileURL(location.pathname);
                }

                if (s) {
                    s = s.split("#")[0].split("?")[0];
                } else {
                    s = "";
                }

                var url = UrlHelper.toAbsURL(d, s);

                return UrlHelper.dehostURL(url);
            }
        },
        internalSrc: {
            value: function (src) {
                // This gets the full url
                var url = document.location.href;

                // This removes everything after the last slash in the path
                url = url.substring(0, url.lastIndexOf("/") + 1);
                return url + src;
            }
        }
    });

exports.Kml = Target.specialize({
    styles: {
        value: {}
    },
    features: {
        value: []
    },
    networkLinks: {
        value: []
    },
    _loading: {
        value: 0
    },

    loaded: {
        value: function () {
            this._loading--;
            if (this._loading <= 0) {
                this.dispatchEventNamed("parsed", true, true, {
                    type: "FeatureCollection",
                    features: this.features
                });
            }
        }
    },

    error: {
        value: function error(msg) {
            this.dispatchEventNamed("ParseError", true, true, msg);
        }
    },

    fetch: {
        value: function fetch(url) {
            var self = this,
                xhr = new XMLHttpRequest();

            xhr.open("GET", url, true);

            xhr.send();

            this._loading++;

            xhr.onreadystatechange = function () {
                if (xhr.readyState !== 4) return;

                if (xhr.status !== 200) {
                    console.warn(xhr.status + ": " + xhr.statusText);
                } else {
                    self.parse(xhr.responseText);
                    self.loaded();
                }
            };
        }
    },

    // @TODO add processing of styleUrl and remote kml files
    // @TODO add network links support if needed
    parse: {
        /**
         * Parse kml string and return GeoJson with styles
         *
         * @param {string} kml - string to parse
         * @return {Object|null}
         */
        value: function parse(kml) {
            if (typeof kml === "string") {
                try {
                    kml = KmlHelper.parseXml(kml);
                } catch (e) {
                    kml = null;
                }
            }

            if (!(kml instanceof Document)) {
                this.error("Wrong data sent to parse function. Data can't be properly parsed.");
                return;
            }

            this.features = [];
            this.styles = {};

            this.parseStyles(kml);
            this.parsePlacemarks(kml);
            this.parseGroundOverlays(kml);

            return {
                type: "FeatureCollection",
                features: this.features
            };
        }
    },

    parseStyles: {
        value: function prepareStyles(kml) {
            var nodes = kml.getElementsByTagName("Style"),
                len = nodes.length,
                i, node, styleID;

            // Parse Style nodes
            for (i = 0; i < len; i++) {
                node = nodes[i];
                styleID = node.getAttribute("id");
                if (!!styleID) {
                    this.processStyle(node, styleID);
                }
            }

            // Parse StyleMap nodes
            nodes = kml.getElementsByTagName("StyleMap");
            len = nodes.length;
            for (i = 0; i < len; i++) {
                node = nodes[i];
                styleID = node.getAttribute("id");
                if (!!styleID) {
                    this.processStyleMap(node, styleID);
                }
            }
        }
    },

    parsePlacemarks: {
        value: function parsePlacemarks(kml) {
            var nodes = kml.getElementsByTagName("Placemark"),
                i, j, len, node, style, styleUrl, styleId,
                geometry, properties;

            len = nodes.length;

            for (i = 0; i < len; i++) {
                // Init the placemark object
                node = nodes[i];
                styleUrl = this.processStyleUrl(node);
                styleId = styleUrl[1];

                properties = {
                    id: node.getAttribute("id"),
                    name: KmlHelper.nodeValueByTagName(node, "name"),
                    description: KmlHelper.nodeValueByTagName(node, "description"),
                    visibility: KmlHelper.getBooleanValueByTagName(node, "visibility", true),
                    balloonVisibility: KmlHelper.getBaloonVisibility(node)
                };

                style = this.styles[styleId];

                // inline style overrides shared style
                var inlineStyles = node.getElementsByTagName("Style");
                if (inlineStyles && inlineStyles.length > 0) {
                    style = this.processStyle(node);
                }

                properties.style = style;

                geometry = {
                    type: "GeometryCollection",
                    geometries: []
                };

                // record list of variables for substitution
                properties.vars = {
                    display: {
                        name: "Name",
                        description: "Description",
                        address: "Street Address",
                        id: "ID",
                        Snippet: "Snippet",
                        geDirections: "Directions"
                    },
                    val: {
                        id: node.getAttribute("id") || "",
                        name: properties.name || "",
                        description: properties.description || "",
                        address: KmlHelper.nodeValueByTagName(node, "address", ""),
                        Snippet: KmlHelper.nodeValueByTagName(node, "Snippet", "")
                    },
                    directions: [
                        "f=d",
                        "source=KmlParser"
                    ]
                };

                // process MultiGeometry

                var geometries = [
                    KmlHelper.processPoints(node),
                    KmlHelper.processPolygons(node),
                    KmlHelper.processLineStrings(node)
                ];

                geometries = [].concat.apply([], geometries);

                for (j = 0; j < geometries.length; j++) {
                    this.features.push({
                        type: "Feature",
                        properties: properties,
                        geometry: geometries[j]
                    });
                }

                // add extended data to variables
                var extDataNodes = node.getElementsByTagName("ExtendedData");
                if (!!extDataNodes && extDataNodes.length > 0) {
                    node = extDataNodes[0];
                    var dataNodes = node.getElementsByTagName("Data");

                    for (var d = 0; d < dataNodes.length; d++) {
                        var dn = dataNodes[d],
                            name = dn.getAttribute("name");

                        if (!name) {
                            continue;
                        }

                        properties.vars.val[name] = KmlHelper.nodeValueByTagName(dn, "value");
                        properties.vars.display[name] = KmlHelper.nodeValueByTagName(dn, "displayName", name);
                    }
                }
            }
        }
    },

    parseGroundOverlays: {
        value: function parseGroundOverlays(node) {
            var groundNodes = node.getElementsByTagName("GroundOverlay"),
                properties, geometry,
                i, len, url, groundNode, color;

            len = groundNodes.length;

            for (i = 0; i < len; i++) {
                groundNode = groundNodes[i];

                url = KmlHelper.nodeValueByTagName(groundNode, "href");

                if (!url) { // ground overlay doesn't make sense without image url
                    continue;
                }

                properties = {
                    name: KmlHelper.nodeValueByTagName(groundNode, "name"),
                    description: KmlHelper.nodeValueByTagName(groundNode, "description"),
                    url: url
                };

                geometry = {
                    type: "GroundOverlay",
                    coordinates: [
                        [
                            parseFloat(KmlHelper.nodeValueByTagName(groundNode, "south")),
                            parseFloat(KmlHelper.nodeValueByTagName(groundNode, "west"))
                        ],
                        [
                            parseFloat(KmlHelper.nodeValueByTagName(groundNode, "north")),
                            parseFloat(KmlHelper.nodeValueByTagName(groundNode, "east"))
                        ]
                    ]
                };

                // Opacity is encoded in the color node
                color = KmlHelper.nodeValueByTagName(groundNode, "color");
                if (color) {
                    properties.opacity = KmlHelper.getOpacity(color);
                } else {
                    properties.opacity = 1.0;  // KML default
                }

                this.features.push({
                    type: "Feature",
                    properties: properties,
                    geometry: geometry
                });
            }
        }
    },

    processStyleUrl: {
        value: function processStyleUrl(node) {
            var styleUrlStr = KmlHelper.nodeValueByTagName(node, "styleUrl");

            if (!!styleUrlStr && styleUrlStr.indexOf("#") !== -1) {
                return styleUrlStr.split("#");
            }

            return ["", ""];
        }
    },

    processStyle: {
        value: function processStyle(node, styleId) {
            var style = this.styles[styleId] = this.styles[styleId] || {},
                styleNode = node.getElementsByTagName("BalloonStyle")[0],
                mode, text;

            // Info Window styles
            if (styleNode) {
                mode = KmlHelper.nodeValueByTagName(styleNode, "displayMode");
                text = KmlHelper.nodeValueByTagName(styleNode, "text");
                if (text && mode !== "hide") {
                    style.infoWindow = {
                        "background-color": KmlHelper.nodeValueByTagName(styleNode, "bgColor", "ffffff"),
                        "color": KmlHelper.nodeValueByTagName(styleNode, "color", "#ff0000"),
                        "content": text
                    };
                }
            }

            // style.list = (unsupported; doesn't make sense in Google Maps)

            // Icon Styles
            styleNode = node.getElementsByTagName("IconStyle")[0];

            if (styleNode) {
                var scale = parseFloat(KmlHelper.nodeValueByTagName(styleNode, "scale", 1.0)),
                    self = this,
                    dim, hotSpot;

                styleNode = node.getElementsByTagName("Icon")[0];
                if (styleNode) {
                    style.url = KmlHelper.nodeValueByTagName(styleNode, "href");

                    // Support for icon palettes and exact size dimensions
                    dim = {
                        x: KmlHelper.nodeValueByTagNameNs(styleNode, KmlHelper.GX_NS, "x", 0), // from left part of palette
                        y: KmlHelper.nodeValueByTagNameNs(styleNode, KmlHelper.GX_NS, "y", 0), // from bottom part of palette
                        width: KmlHelper.nodeValueByTagNameNs(styleNode, KmlHelper.GX_NS, "w", 0),
                        height: KmlHelper.nodeValueByTagNameNs(styleNode, KmlHelper.GX_NS, "h", 0)
                    };

                    styleNode = node.getElementsByTagName("hotSpot")[0];
                    if (styleNode) {
                        hotSpot = {
                            x: parseFloat(styleNode.getAttribute("x")),
                            y: parseFloat(styleNode.getAttribute("y")),
                            xunits: styleNode.getAttribute("xunits") || "fraction",
                            yunits: styleNode.getAttribute("yunits") || "fraction"
                        };
                        hotSpot.x = !isNaN(hotSpot.x) ? hotSpot.x : 0.5;
                        hotSpot.y = !isNaN(hotSpot.y) ? hotSpot.y : 0.5;
                    }

                    if (dim.x > 0 || dim.y > 0) {
                        style.origin = {
                            x: dim.x * scale,
                            y: dim.y * scale
                        };
                    }

                    if (dim.width > 0 || dim.height > 0) {
                        style.size = {
                            width: dim.width * scale,
                            height: dim.height * scale
                        };
                    }

                    var img = new Image(),
                        onload = function () {
                            var width = this.width * scale,
                                height = this.height * scale;

                            if (style.size || scale !== 1) {
                                style.scaledSize = {
                                    width: width,
                                    height: height
                                };
                            }

                            if (!style.anchor) {
                                if (hotSpot) {
                                    var x, y;

                                    switch (hotSpot.xunits) {
                                        case "fraction":
                                            x = parseInt(hotSpot.x * width);
                                            break;
                                        case "insetPixels":
                                            x = parseInt(width - (hotSpot.x * scale));
                                            break;
                                        default:
                                            x = parseInt(hotSpot.x);
                                            break;  // already pixels
                                    }

                                    if (hotSpot.yunits === "fraction") {
                                        y = height * hotSpot.y;
                                    } else {
                                        y = hotSpot.y * scale;
                                    }

                                    style.anchor = {
                                        x: x,
                                        y: height - y
                                    };
                                } else {
                                    style.anchor = {
                                        x: parseInt(width / 2),
                                        y: parseInt(height / 2)
                                    };
                                }
                            }

                            self.loaded();
                        };

                    // sometimes the file is already cached and it never calls onLoad
                    if (img.width > 0) {
                        onload.call(img);
                    } else {
                        img.onload = onload;
                    }

                    this._loading++;
                    img.src = style.url;
                }
            }

            var fill, outline, colorMode, strokeColor, fillColor;

            // Line styles
            styleNode = node.getElementsByTagName("LineStyle")[0];
            if (styleNode) {
                colorMode = KmlHelper.nodeValueByTagName(styleNode, "colorMode", "normal");
                strokeColor = KmlHelper.nodeValueByTagName(styleNode, "color", "ffffffff");
                strokeColor = KmlHelper.kmlColor(strokeColor);

                style.strokeColor = strokeColor.color;
                style.strokeOpacity = strokeColor.opacity;
                style.strokeWeight = parseFloat(KmlHelper.nodeValueByTagName(styleNode, "width", 1.0));
            }

            // Polygons styles
            styleNode = node.getElementsByTagName("PolyStyle")[0];
            if (styleNode) {
                colorMode = KmlHelper.nodeValueByTagName(styleNode, "colorMode", "normal");
                outline = KmlHelper.nodeValueByTagName(styleNode, "outline", true);
                fill = KmlHelper.nodeValueByTagName(styleNode, "fill", true);

                if (!outline) {
                    style.strokeOpacity = style.strokeWeight = 0;
                }

                if (fill) {
                    fillColor = KmlHelper.nodeValueByTagName(styleNode, "color", "ffffffff");
                    fillColor = KmlHelper.kmlColor(fillColor);

                    style.fillColor = fillColor.color;
                    style.fillOpacity = fillColor.opacity;
                }
            }

            if (Object.keys(style).length === 0) {
                delete this.styles[styleId];
                return null;
            }

            return style;
        }
    },

    processStyleMap: {
        value: function processStyleMap(thisNode, styleID) {
            var pairs = thisNode.getElementsByTagName("Pair"),
                map = {},
                pair, pairKey, pairStyle, pairStyleUrl, pairStyleId;

            // add each key to the map
            for (var pr = 0; pr < pairs.length; pr++) {
                pair = pairs[pr];

                pairKey = KmlHelper.nodeValueByTagName(pair, "key");
                pairStyle = KmlHelper.nodeValueByTagName(pair, "Style");
                pairStyleUrl = this.processStyleUrl(pair);
                pairStyleId = pairStyleUrl[1];

                if (!!pairStyle) {
                    map[pairKey] = this.processStyle(pairStyle, pairStyleId);
                } else if (!!pairStyleId && !!this.styles[pairStyleId]) {
                    map[pairKey] = clone(this.styles[pairStyleId]);
                }
            }

            if (!!map["normal"]) {
                this.styles[styleID] = clone(map["normal"]);
            } else {
                this.styles[styleID] = {};
            }

            if (!!map["highlight"]) {
                this.styles[styleID].hoverStyle = clone(map["highlight"]);
            }
        }
    }
});
