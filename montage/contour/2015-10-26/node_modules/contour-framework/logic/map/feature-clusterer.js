/**
 * @module logic/feature-clusterer.js
 */
var Montage = require("montage").Montage,
    FeatureCluster = require("logic/map/feature-cluster").FeatureCluster,
    GeometryUtilities = require("logic/map/geometry-utilities").GeometryUtilities,
    Layer = require("logic/mock-model/layer").Layer,
    Protocol = require("logic/model/protocol").Protocol;

// I'm not sure what is going on here.  Need help please.
var ClusterIconRenderer;
setTimeout(function () {
    ClusterIconRenderer = require("logic/map/cluster-icon-renderer").ClusterIconRenderer;
}, 0);

/**
 * @class FeatureClusterer
 * @extends Montage
 *
 * This objects creates and manages per-zoom-level feature clusters for large amounts of
 * markers.  Based on the Google Marker Clusterer:
 * http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/
 *
 */
var FeatureClusterer = exports.FeatureClusterer = Montage.specialize(/** @lends FeatureClusterer# */ {

    constructor: {
        value: function FeatureClusterer(component, options) {

            this._component = component;
            this._gridSize = options.gridSize;
            this._protocol = options.protocol;
            this._clusters = [];
            switch (this._protocol) {
                case Layer.Protocol.AGS:
                case Layer.Protocol.Camera:
                case Protocol.ARCGIS:
                    this._renderer = new ClusterIconRenderer();
                    break;
                case Layer.Protocol.Product:
                    this._renderer = new ClusterIconRenderer();
                    this._renderer.color = "#3AB218";
                    break;
            }
        }
    },

    /**
     * Adds a feature to a cluster, or creates a new cluster.
     *
     * @param {Feature} feature The feature to add.
     * @private
     */
    _addToCluster: {
        value: function (feature) {

            var closestDistance = 40000,
                distance,
                distanceToWestEdge,
                distanceToEastEdge,
                closestCluster = null,
                offset = 0,
                i, cluster;

            if (feature.properties.mercatorPoint === undefined) {
                feature.properties.mercatorPoint = this.engine.coordinateToMercatorPoint(feature.properties.point);
            }

            for (i = 0; cluster = this._clusters[i]; i++) {
                distance = this._clusters[i].distanceToFeature(feature);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestCluster = cluster;
                }
            }

            distanceToWestEdge = this._featureShortestDistanceToAntiMeridian(feature, "WEST");
            if (distanceToWestEdge < closestDistance) {
                for (i = 0; cluster = this._clusters[i]; i++) {
                    if (cluster.point.x > feature.properties.mercatorPoint.x + 128) {
                        distance = this._clusters[i].distanceToFeature(feature, -256);
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestCluster = cluster;
                            offset = this._mapSize;
                        }
                    }
                }
            } else {
                distanceToEastEdge = this._featureShortestDistanceToAntiMeridian(feature);
                if (distanceToEastEdge < closestDistance) {
                    for (i = 0; cluster = this._clusters[i]; i++) {
                        if (cluster.point.x < feature.properties.mercatorPoint.x - 128) {
                            distance = this._clusters[i].distanceToFeature(feature, 256);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestCluster = cluster;
                                offset = -(this._mapSize);
                            }
                        }
                    }
                }
            }

            if (closestCluster && closestCluster.featureWithinBounds(feature, this._mapSize)) {
                closestCluster.addFeature(feature, offset);
            } else {
                cluster = new FeatureCluster(this);
                cluster.addFeature(feature);
                this._clusters.push(cluster);
            }
        }
    },

    _assets: {
        value: null
    },

    _createClusters: {
        value: function () {

            if (!this.engine || !this.engine.bounds) {
                return;
            }

            var bounds = this.engine.bounds,
                //extendedBounds,
                feature,
                featureId,
                inBounds,
                mapBounds;

            this.zoomLevelCoefficient = Math.pow(2, this.engine.position.zoom);
            this._mapSize = this.zoomLevelCoefficient * 256;

            if (bounds.west > bounds.east) {
                mapBounds = [
                    this.engine.createBounds(
                        [bounds.southWest.lng, bounds.southWest.lat],
                        [180, bounds.northEast.lat]
                    ),
                    this.engine.createBounds(
                        [-180, bounds.southWest.lat],
                        [bounds.northEast.lng, bounds.northEast.lat]
                    )
                ];
            } else {
                mapBounds = this.engine.createBounds(
                    [bounds.southWest.lng, bounds.southWest.lat],
                    [bounds.northEast.lng, bounds.northEast.lat]
                );
            }

            for (featureId in this.featureCache) {
                feature = this.featureCache[featureId];
                inBounds = this._isFeatureInBounds(feature, mapBounds);
                if (! feature.properties.isAdded && inBounds) {
                    this._addToCluster(feature);
                } else if (! inBounds) {
                    this.removeFeature(feature);
                }
            }
        }
    },

    _component: {
        value: null
    },

    _featureCache: {
        value: null
    },

    _featureShortestDistanceToAntiMeridian: {
        value: function (feature, direction) {
            var closestPoint;
            if (direction && direction === "WEST") {
                closestPoint = {
                    x: 0,
                    y: feature.properties.mercatorPoint.y
                };
            } else {
                closestPoint = {
                    x: 256,
                    y: feature.properties.mercatorPoint.y
                };
            }
            return Math.sqrt(
                Math.pow(feature.properties.mercatorPoint.x - closestPoint.x, 2) +
                Math.pow(feature.properties.mercatorPoint.y - closestPoint.y, 2)
            );
        }
    },

    featureCache: {
        get: function () {
            if (this._featureCache === null) {
                this._featureCache = {};
            }
            return this._featureCache;
        },
        set: function (value) {
            this._featureCache = value;
        }
    },

    _gridSize: {
        writeable: true,
        value: 60
    },

    _isFeatureInBounds: {
        value: function (feature, bounds) {

            var inBounds = false;

            if (this._component.layer.areFeaturesGlobal) {
                inBounds = true;
            } else {
                if (Array.isArray(bounds)) {
                    inBounds = this.engine.pointWithinBounds(feature.properties.point, bounds[0]) ||
                        this.engine.pointWithinBounds(feature.properties.point, bounds[1]);
                } else {
                    inBounds = this.engine.pointWithinBounds(feature.properties.point, bounds);
                }
            }
            return inBounds;
        }
    },

    _mapSize: {
        value: 256
    },

    _needsDraw: {
        value: false
    },

    _renderer: {
        value: null
    },

    _addFeature: {
        value: function (feature) {
            if (this.featureCache[feature.id] === undefined) {
                this.featureCache[feature.id] = feature;
            }
        }
    },

    addFeature: {
        value: function () {
            var i, n;
            for (i = 0, n = arguments.length; i < n; i++) {
                this._addFeature(arguments[i]);
            }
        }
    },

    assets: {
        get: function () {
            if (this._assets === null) {
                this._assets = [];
            }
            return this._assets;
        }
    },

    clusters: {
        get: function () {
            return this._clusters;
        }
    },

    /**
     * A method that returns the clusters that can be found within the provided bounds.
     * @param {array} an array that defines a bbox.
     * @return {array} the clusters that are within the provided bbox.
     */
    clustersInBounds: {
        value: function (bbox) {
            return this.clusters.filter(function (cluster) {
                return GeometryUtilities.boundingBoxContainsCoordinate(bbox, cluster.center);
            });
        }
    },

    engine: {
        writeable: false,
        get: function () {
            return this._component.engine;
        }
    },

    extendBounds: {
        value: function (bounds) {
            return this.engine.extendBounds(bounds, this._gridSize)
        }
    },

    padCluster: {
        value: function (point) {
            var amount = this._gridSize;
            return [
                {x: point.x - amount, y: point.y + amount},
                {x: point.x + amount, y: point.y - amount}
            ];
        }
    },

    hasFeature: {
        value: function (feature) {
            return this.featureCache && this.featureCache[feature.id] !== undefined;
        }
    },

    protocol: {
        get: function () {
            return this._protocol;
        }
    },

    needsDraw: {
        get: function () {
            return this._needsDraw;
        },
        set: function (value) {
            this._needsDraw = value;
        }
    },

    recalculateClusters: {
        value: function () {
            this.reset();
            this.redraw();
            this.needsDraw = true;
        }
    },

    redraw: {
        value: function () {
            this._createClusters();
        }
    },

    renderer: {
        get: function () {
            return this._renderer;
        }
    },

    removeFeature: {
        value: function (feature) {
            delete this.featureCache[feature.id];
            this.needsDraw = true;
        }
    },

    removeFeatures: {
        value: function (features) {
            if (features) {
                for (var i = 0, length = features.length; i < length; i++) {
                    this.removeFeature(features[i]);
                }
            }
        }
    },

    reset: {
        value: function (removeFeatures) {

            var i, cluster, feature;

            removeFeatures = removeFeatures || false;
            for (i = 0; cluster = this._clusters[i]; i++) {
                cluster.remove();
            }

            if (removeFeatures) {
                this.featureCache = {};
            } else {
                for (var featureId in this.featureCache) {
                    feature = this.featureCache[featureId];
                    feature.properties.isAdded = false;
                }
            }
            this._clusters = [];
        }
    },

    zoomLevelCoefficient: {
        value: 0
    }

});
