var Montage = require("montage").Montage,
    base64Characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    EsriGeometryType = require("logic/map/esri-geometry-type").EsriGeometryType;

/**
 * This super class contains logic and methods that are common to all renderers.
 *
 * @class Renderer
 * @extends Montage
 */
var Renderer = exports.Renderer = Montage.specialize(/** @lends Renderer.prototype */ {

    constructor: {
        value: function Renderer() {
            console.error("Do not directly initialize this object.  Use one of it's subclasses");
        }
    },

    render: {
        value: function (attributes) {
            var styleObject;
            switch (this.geometryType) {
                case EsriGeometryType["esriGeometryMultipoint"]:
                case EsriGeometryType["esriGeometryPoint"]:
                    styleObject = this._renderPoint(attributes);
                    break;
                case EsriGeometryType["esriGeometryPolyline"]:
                    styleObject = this._renderLine(attributes);
                    break;
                case EsriGeometryType["esriGeometryPolygon"]:
                    styleObject = this._renderPolygon(attributes);
                    break;
            }
            return styleObject;
        }
    },

    legendSymbols: {
        get: function () {
            if (this._legendSymbols === undefined) {
                switch (this.geometryType) {
                    case EsriGeometryType["esriGeometryMultipoint"]:
                    case EsriGeometryType["esriGeometryPoint"]:
                        this._legendSymbols = this._legendSymbolsForPointRenderer();
                        break;
                    case EsriGeometryType["esriGeometryPolyline"]:
                        this._legendSymbols = this._legendSymbolsForLineRenderer();
                        break;
                    case EsriGeometryType["esriGeometryPolygon"]:
                        this._legendSymbols = this._legendSymbolsForPolygonRenderer();
                        break;
                }
            }
            return this._legendSymbols;

        }
    },

    export: {
        value: function (attributes) {
            return this.render(attributes);
        }
    },

    _legendSymbolsForLineRenderer: {
        value: function () {
            //console.warn("-------------------------");
            //console.warn("Legend items are not implemented for this renderer (", this, ")");
        }
    },

    _legendSymbolsForPointRenderer: {
        value: function () {
            //console.warn("-------------------------");
            //console.warn("Legend items are not implemented for this renderer (", this, ")");
        }
    },

    _legendSymbolsForPolygonRenderer: {
        value: function () {
            //console.warn("-------------------------");
            //console.warn("Legend items are not implemented for this renderer (", this, ")");
        }
    },

    _renderLine: {
        value: function (attributes) {}
    },

    _renderPoint: {
        value: function (attributes) {}
    },

    _renderPolygon: {
        value: function (attributes) {}
    }

}, {

    hexToRGB: {
        value: function (hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
    },

    rgbToHex: {
        value: function (rgb) {
            hex = ["#"];
            for(var i = 0; i < 3; i++) {
                var component = rgb[i].toString(16);
                component = component.length == 1 ? "0" + component : component;
                hex[i+1] = component;
            }
            return hex.join("");
        }
    },

    getAlphaFromRgb: {
        value: function (color) {
            var regex = /^rgba\(\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*\)$/g,
                alpha = 1.0;
            if (regex.test(color)) {
                var matches = color.match(regex);
                if (matches.length === 4) {
                    alpha = matches[3];
                }
            }
            return alpha;
        }
    },

    toRgba: {
        value: function (hex, opacity) {
            var color = Renderer.hexToRGB(hex);
            return color ? "rgba(" +
                color.r + "," +
                color.g + "," +
                color.b + "," +
                opacity + ")" : "rgba(0, 0, 0, 1.0)";
        }
    },

    getDimensions: {
        value: function (url) {
            var data = Renderer._base64Decode(url.substring(22))
            return {
                width: Renderer._toInt32(data.slice(16, 20)),
                height: Renderer._toInt32(data.slice(20, 24))
            };
        }
    },

    _toInt32: {
        value: function (bytes) {
            return (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3];
        }
    },

    _base64Decode: {
        value: function (data) {
            var result = [];
            var current = 0;

            for (var i = 0, c; c = data.charAt(i); i++) {

                if (c === '=') {
                    if (i !== data.length - 1 && (i !== data.length - 2 || data.charAt(i + 1) !== '=')) {
                        throw new SyntaxError('Unexpected padding character.');
                    }
                    break;
                }

                var index = base64Characters.indexOf(c);

                if (index === -1) {
                    throw new SyntaxError('Invalid Base64 character.');
                }

                current = (current << 6) | index;

                if (i % 4 === 3) {
                    result.push(current >> 16, (current & 0xff00) >> 8, current & 0xff);
                    current = 0;
                }
            }

            if (i % 4 === 1) {
                throw new SyntaxError('Invalid length for a Base64 string.');
            }

            if (i % 4 === 2) {
                result.push(current >> 4);
            } else if (i % 4 === 3) {
                current <<= 6;
                result.push(current >> 16, (current & 0xff00) >> 8);
            }

            return result;

        }
    },

    //makeTransparentImage: {
    //    value: function (dataUrl, opacity) {
    //
    //    }
    //},

    symbolUrl: {
        value: function (symbol) {
            var url = "data:";
            url += symbol.contentType;
            url += ";base64,";
            url += symbol.imageData;
            return url;
        }
    }
});
