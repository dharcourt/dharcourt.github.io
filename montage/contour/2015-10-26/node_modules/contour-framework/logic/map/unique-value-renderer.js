/**
 * @module logic/class-breaks-renderer.js
 */

EsriGeometryType = require("logic/map/esri-geometry-type").EsriGeometryType;

var Renderer = require("logic/map/renderer").Renderer,
    ErsiSymbolType = {
        SIMPLE_MARKER: "esriSMS",
        SIMPLE_LINE: "esriSLS",
        SIMPLE_FILL: "esriSFS",
        SIMPLE_FILL_NULL: "esriSFSNull",
        PICTURE_MARKER: "esriPMS",
        PICTURE_FILL: "esriPFS"
    },
    ErsiSimpleSymbolType = {
        SIMPLE_CIRCLE: "esriSMSCircle",
        SIMPLE_SQUARE: "esriSMSSquare"
    },
    /**
     * @class UniqueValueRenderer
     * @extends Renderer
     *
     * This object is used by a feature layer to render it's feature data
     * provided that the feature layer is configured to use a "UniqueValueRenderer".
     */
    UniqueValueRenderer = exports.UniqueValueRenderer = Renderer.specialize(/** @lends UniqueValueRenderer.prototype */ {

        constructor: {
            value: function (field1, field2, field3, fieldDelimeter, uniqueValueInfos, defaultSymbol) {
                this.field1 = field1;
                this.field2 = field2;
                this.field3 = field3;
                this.fieldDelimeter = fieldDelimeter;
                this.uniqueValueInfos = uniqueValueInfos;
                this.defaultSymbol = defaultSymbol;
                return this;
            }
        },

        _renderPoint: {
            value: function (properties) {
                var uniqueValueInfo = this._uniqueValue(properties);

                if (!uniqueValueInfo.style) {
                    var url = UniqueValueRenderer.symbolUrl(uniqueValueInfo.symbol),
                        dimensions = Renderer.getDimensions(url),
                        anchor = [
                            parseInt(dimensions.width / 2),
                            parseInt(dimensions.height / 2)
                        ];

                    uniqueValueInfo.style = {
                        anchor: {x: anchor[0], y: anchor[1]},
                        size: {width: dimensions.width, height: dimensions.height},
                        url: url
                    };
                }

                return uniqueValueInfo.style;
            }
        },

        _renderLine: {
            value: function (properties) {
                var uniqueValueInfo = this._uniqueValue(properties),
                    opacity = properties.layerOpacity;

                if (!uniqueValueInfo.style || opacity && uniqueValueInfo.style.opacity !== opacity) {
                    var symbol = uniqueValueInfo.symbol,
                        color = symbol.outline ? symbol.outline.color : symbol.color,
                        width = symbol.outline ? symbol.outline.width : symbol.width;
                    uniqueValueInfo.style = {
                        opacity: opacity,
                        strokeColor: Renderer.rgbToHex(color),
                        strokeOpacity: opacity || 1.0,
                        strokeWeight: width
                    };
                }

                return uniqueValueInfo.style;
            }
        },

        _renderPolygon: {
            value: function (properties) {
                var uniqueValueInfo = this._uniqueValue(properties),
                    opacity = properties.layerOpacity;

                if (!uniqueValueInfo.style || opacity && uniqueValueInfo.style.opacity !== opacity) {
                    var symbol = uniqueValueInfo.symbol;
                    uniqueValueInfo.style = {
                        fillColor: Renderer.rgbToHex(symbol.color),
                        fillOpacity: opacity || 1.0,
                        opacity: opacity,
                        strokeColor: Renderer.rgbToHex(symbol.outline.color),
                        strokeWeight: symbol.outline.width,
                        strokeOpacity: opacity || 1.0
                    };
                }

                return uniqueValueInfo.style;
            }
        },

        _uniqueValue: {
            value: function (properties) {
                var fieldValue = properties[this.field1],
                    uniqueValueInfo;

                for (var n in this.uniqueValueInfos) {
                    if (this.uniqueValueInfos.hasOwnProperty(n)) {
                        uniqueValueInfo = this.uniqueValueInfos[n];
                        // double equal on purpose.
                        if (fieldValue === uniqueValueInfo.value) {
                            break;
                        }
                    }
                }

                return uniqueValueInfo;
            }
        },

        _legendSymbolsForPointRenderer: {
            value: function () {
                var legendItems = [], i, n, uniqueValue;
                for (i = 0, n = this.uniqueValueInfos.length; i < n; i++) {
                    uniqueValue = this.uniqueValueInfos[i];
                    legendItems.push({
                        url: UniqueValueRenderer.symbolUrl(uniqueValue.symbol),
                        label: uniqueValue.label
                    });
                }
                return legendItems;
            }
        },

        _legendSymbolsForLineRenderer: {
            value: function () {
                var legendItems = [], i, n, uniqueValue;
                for (i = 0, n = this.uniqueValueInfos.length; i < n; i++) {
                    uniqueValue = this.uniqueValueInfos[i];
                    var symbol = uniqueValue.symbol,
                        color = symbol.outline ? symbol.outline.color : symbol.color,
                        width = symbol.outline ? symbol.outline.width : symbol.width;
                    legendItems.push({
                        strokeColor: Renderer.rgbToHex(color),
                        strokeWeight: width,
                        type: "line",
                        label: uniqueValue.label
                    });
                }
                return legendItems;
            }
        },

        _legendSymbolsForPolygonRenderer: {
            value: function () {
                var legendItems = [], i, n, uniqueValue;
                for (i = 0, n = this.uniqueValueInfos.length; i < n; i++) {
                    uniqueValue = this.uniqueValueInfos[i];
                    legendItems.push({
                        fillColor: Renderer.rgbToHex(uniqueValue.symbol.color),
                        strokeColor: Renderer.rgbToHex(uniqueValue.symbol.outline.color),
                        strokeWeight: uniqueValue.symbol.outline.width,
                        type: "polygon",
                        label: uniqueValue.label
                    });
                }
                return legendItems;
            }
        },

        export: {
            value: function (properties) {
                var uniqueValueInfo = this._uniqueValue(properties),
                    style = this.render(properties);
                style.symbolUrl = uniqueValueInfo.symbol.url;
                return style;
            }
        }
    }, {
        canvas: {
            value: document.createElement("canvas")
        },

        forDefinition: {
            value: function (definition) {
                return new this(
                    definition.field1,
                    definition.field2,
                    definition.field3,
                    definition.fieldDelimeter,
                    definition.uniqueValueInfos,
                    definition.defaultSymbol
                );
            }
        },

        symbolUrl: {
            value: function (symbolOptions) {
                switch (symbolOptions.type) {
                    case ErsiSymbolType.SIMPLE_MARKER:
                        var data = {
                            size: symbolOptions.size,
                            strokeWidth: symbolOptions.outline ? symbolOptions.outline.width : null,
                            strokeColor: symbolOptions.outline ? symbolOptions.outline.color : null,
                            fillColor: symbolOptions.style !== ErsiSymbolType.SIMPLE_FILL_NULL ? symbolOptions.color : null
                        };
                        switch (symbolOptions.style) {
                            case ErsiSimpleSymbolType.SIMPLE_CIRCLE:
                                return this._simpleCircleSymbol(data);
                            case ErsiSimpleSymbolType.SIMPLE_SQUARE:
                                return this._simpleSquareSymbol(data);
                            default:
                                return this._simpleSquareSymbol(data);
                        }
                        break;
                    case ErsiSymbolType.PICTURE_MARKER:
                        return "data:" + symbolOptions.contentType + ";base64," + symbolOptions.imageData;
                }
            }
        },

        _prepareCanvas: {
            value: function (symbol) {
                var strokeWidth = symbol.strokeWidth || 0;
                this.canvas.width = symbol.size + strokeWidth * 2;
                this.canvas.height = symbol.size + strokeWidth * 2;

                var context = this.canvas.getContext("2d");

                if (symbol.strokeColor) {
                    context.strokeStyle = this._parseColorToRgba(symbol.strokeColor);
                }
                if (symbol.fillColor) {
                    context.fillStyle = this._parseColorToRgba(symbol.fillColor);
                }
                context.lineWidth = strokeWidth;

                console.log(symbol);
            }
        },

        _simpleCircleSymbol: {
            value: function (symbol) {
                var context = this.canvas.getContext("2d");

                this._prepareCanvas(symbol);

                context.rect(symbol.strokeWidth || 0, symbol.strokeWidth || 0, symbol.size, symbol.size);
                context.fill();
                context.stroke();

                return this.canvas.toDataURL();
            }
        },

        _simpleSquareSymbol: {
            value: function (symbol) {
                var context = this.canvas.getContext("2d");

                this._prepareCanvas(symbol);

                context.rect(symbol.strokeWidth || 0, symbol.strokeWidth || 0, symbol.size, symbol.size);
                context.fill();
                context.stroke();
                return this.canvas.toDataURL();
            }
        },

        _parseColorToRgba: {
            value: function (color) {
                return "rgba(" + [
                        this._normalizeColor(color[0]),
                        this._normalizeColor(color[1]),
                        this._normalizeColor(color[2]),
                        this._normalizeAlpha(color[3])
                    ].join(",") + ")";
            }
        },

        _normalizeColor: {
            value: function (color) {
                return (color > 0.0 && color < 1.0) ? Math.floor(color * 255) : color;
            }
        },

        _normalizeAlpha: {
            value: function (alpha) {
                return (alpha / 255);
            }
        }
    });
