/**
 * @module logic/simple-renderer.js
 */
var Renderer = require("logic/map/renderer").Renderer;

/**
 * @class SimpleRenderer
 * @extends Renderer
 *
 * This object is used by a feature layer to render it's feature data
 * provided that the feature layer is configured to use a "SimpleRenderer".
 */
exports.SimpleRenderer = Renderer.specialize(/** @lends SimpleRenderer.prototype */ {

    constructor: {
        value: function SimpleRenderer(symbol) {
            this.symbol = symbol;
        }
    },

    //__transparentImages: {
    //    value: undefined
    //},
    //
    //_transparentImages: {
    //    writeable: false,
    //    get: function () {
    //        if (this.__transparentImages === undefined) {
    //            this.__transparentImages = {};
    //        }
    //        return this.__transparentImages;
    //    }
    //},

    _legendSymbolsForPointRenderer: {
        value: function () {
            return [this._renderPoint({})];
        }
    },

    _legendSymbolsForPolygonRenderer: {
        value: function () {
            return [{
                fillColor: Renderer.rgbToHex(this.symbol.color),
                strokeColor: Renderer.rgbToHex(this.symbol.outline.color),
                strokeWeight: this.symbol.outline.width,
                type: "polygon"
            }];
        }
    },

    _renderPoint: {
        value: function(properties) {
            var opacity = properties.layerOpacity;
            if (! this.style || opacity !== undefined && this.style.opacity !== opacity) {

                if(this.symbol.imageData !== undefined) {

                    var url = Renderer.symbolUrl(this.symbol),
                        dimensions = Renderer.getDimensions(url),
                        anchor = {
                            x: parseInt(dimensions.width / 2),
                            y: parseInt(dimensions.height / 2)
                        };
                    this.style = {
                        anchor: anchor,
                        size: { width: dimensions.width, height: dimensions.height },
                        url: url
                    };

                } else {

                    this.style = {
                        fillColor: Renderer.rgbToHex(this.symbol.color),
                        fillOpacity: opacity || 1.0,
                        path: this.symbol.style,
                        scale: this.symbol.size,
                        strokeColor: Renderer.rgbToHex(this.symbol.outline.color),
                        strokeWeight: this.symbol.outline.width,
                        strokeOpacity: opacity || 1.0
                    };

                }

                this.style.opacity = opacity || undefined;

            }
            return this.style;
        }
    },

    _renderLine: {
        value: function(properties) {
            return {};
        }
    },

    _renderPolygon: {
        value: function(properties) {
            var opacity = properties.layerOpacity;
            if (! this.style || opacity !== undefined && this.style.opacity !== opacity) {
                this.style = {
                    fillColor: Renderer.rgbToHex(this.symbol.color),
                    strokeColor: Renderer.rgbToHex(this.symbol.outline.color),
                    strokeWeight: this.symbol.outline.width
                };

                if (this.symbol.color.length === 4) {
                    this.style.fillOpacity = this.symbol.color[3] / 255;
                } else {
                    this.style.fillOpacity = 1.0;
                }
                if (this.symbol.outline.color.length === 4) {
                    this.style.strokeOpacity = this.symbol.outline.color[3] / 255;
                } else {
                    this.style.strokeOpacity = 1.0;
                }

                if (opacity !== undefined) {
                    this.style.fillOpacity = this.style.fillOpacity * opacity;
                    this.style.strokeOpacity = this.style.strokeOpacity * opacity;
                    this.style.opacity = opacity;
                }
            }

            return this.style;
        }
    },

    legendItems: {
        get: function () {

        }
    }

}, {

    forDefinition: {
        value: function (definition) {
            return new this(definition.symbol);
        }
    }

});
